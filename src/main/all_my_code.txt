
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\module-info.java" 
/** JPMS descriptor for Helios chess engine. */
open module Helios {          // use `open` if reflection is needed elsewhere
    requires java.management;
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\constants\CoreConstants.java" 
package core.constants;

/**
 * Central place for *all* engine-wide compile-time constants.
 *
 * <p>Anything that is a plain literal value (scores, depth limits,
 * magic numbers, …) belongs here so that the rest of the code has
 * zero hard-wired numbers.</p>
 */
public final class CoreConstants {

    private CoreConstants() {}            // utility class – not instantiable

    /* ────────────── Search / stack limits ────────────── */
    /** Maximum ply this engine will ever search (½-moves). */
    public static final int MAX_PLY = 127;
    /** Maximum ply for quiescence search. */
    public static final int QSEARCH_MAX_PLY = 8;

    /* ─────────────── Evaluation score space ───────────── */
    /** “Infinity” for alpha-beta – must be ≥ every other score. */
    public static final int SCORE_INF = 32_767;

    public static final int SCORE_MATE               = 32_000;
    public static final int SCORE_MATE_IN_MAX_PLY    = SCORE_MATE - MAX_PLY;
    public static final int SCORE_TB_WIN_IN_MAX_PLY  = SCORE_MATE_IN_MAX_PLY - 1;
    public static final int SCORE_TB_LOSS_IN_MAX_PLY = -SCORE_TB_WIN_IN_MAX_PLY;

    /** Used when no meaningful score is available yet. */
    public static final int SCORE_NONE = 32_002;
    /** A perfectly even position. */
    public static final int SCORE_DRAW = 0;
    /** Returned when no legal move but not in check. */
    public static final int SCORE_STALEMATE = SCORE_DRAW;

    /* ─────────────── Aspiration window params ─────────── */
    public static final int ASP_WINDOW_START_DEPTH   = 5;
    public static final int ASP_WINDOW_INITIAL_DELTA = 15;


    /* ========================================================================
     * Time Management Heuristics
     * ======================================================================== */

    /**
     * The minimum depth required before the time-extension heuristics are activated.
     */
    public static final int TM_HEURISTICS_MIN_DEPTH = 4;

    /**
     * Coefficients for the Best Move Stability heuristic. A lower value for
     * low stability (the first element) makes the engine less likely to extend
     * the search when the best move changes.
     */
    public static final double[] TM_STABILITY_COEFF = {1.4, 1.2, 1.1, 1.0, 1.0, 0.95, 0.9};

    /**
     * Multiplier for the Node Time Management heuristic. A lower value reduces the
     * impact of node distribution on time extension.
     */
    public static final double TM_NODE_TM_MULT = 1.35;

    /**
     * Factor for the Score Stability heuristic. A lower value reduces the impact
     * of evaluation swings on time extension.
     */
    public static final double TM_SCORE_STABILITY_FACTOR = 0.025;


    /* ========================================================================
     * Late Move Reduction (LMR) Constants
     * ======================================================================== */
    public static final int LMR_MIN_DEPTH = 3;
    public static final int LMR_MIN_MOVE_COUNT = 2;
}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\Evaluator.java" 
package core.contracts;

public interface Evaluator {
    int evaluate(long[] bb);  // centipawns from side to move
    default void reset() {}   // clear caches between games
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\InfoHandler.java" 
package core.contracts;

import core.records.SearchInfo;

/**
 * Callback for incremental search updates (“info” lines in UCI terms).
 *
 * <p>The engine should call {@link #onInfo} every time it has new data to
 * report: a deeper ply reached, a better PV found, etc.  GUI front-ends or
 * test harnesses can then render or record the progress without parsing
 * textual UCI output.</p>
 */
@FunctionalInterface
public interface InfoHandler {

    /**
     * Invoked by the search whenever it generates a new {@link SearchInfo}
     * snapshot.
     *
     * @param info immutable data object describing the current search state
     */
    void onInfo(SearchInfo info);
}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\MoveGenerator.java" 
package core.contracts;

public interface MoveGenerator {
  int generateCaptures(long[] packedPosition, int[] mv, int n);

  int generateQuiets(long[] packedPosition, int[] mv, int n);

  int generateEvasions(long[] packedPosition, int[] mv, int n);

  boolean kingAttacked(long[] bb, boolean moverWasWhite);

  boolean castleLegal(long[] packedPosition, int from, int to);
}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\MoveOrderer.java" 
package core.contracts;

/**
 * A service that scores and sorts a list of moves in-place to improve
 * alpha-beta search efficiency. An instance of this class is designed
 * to be reused across different nodes in the search tree to reduce
 * memory allocations.
 */
public interface MoveOrderer {
    /**
     * Scores and sorts the provided move list in-place, with the best
     * moves appearing first.
     *
     * @param bb     The current board state.
     * @param moves  The array containing pseudo-legal moves. This array will be modified.
     * @param count  The number of moves in the array.
     * @param ttMove The move from the transposition table, if any, to prioritize.
     */
    void orderMoves(long[] bb, int[] moves, int count, int ttMove, int[] killers);

    /**
     * Applies Static Exchange Evaluation (SEE) to prune losing captures.
     * It reorders the move list in-place so that only moves with a non-negative
     * SEE score remain at the beginning of the list.
     *
     * @param bb    The current board state.
     * @param moves The array of moves to be pruned (typically captures).
     * @param count The number of moves in the array.
     * @return The number of moves remaining after pruning.
     */
    int seePrune(long[] bb, int[] moves, int count);
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\PositionFactory.java" 
package core.contracts;

public interface PositionFactory {

  /* ───────── Piece indices ──────── */
  int WP = 0, WN = 1, WB = 2, WR = 3, WQ = 4, WK = 5;
  int BP = 6, BN = 7, BB = 8, BR = 9, BQ = 10, BK = 11;
  int META = 12;
  int DIFF_META = 13;
  int DIFF_INFO = 14;

  /* ───────── Board array layout (indices) ───────── */
  int HASH      = 15; // 64-bit Zobrist key
  int COOKIE_SP = 16; // stack pointer
  int COOKIE_BASE = 17;
  int COOKIE_CAP  = 1000;
  int BB_LEN      = COOKIE_BASE + COOKIE_CAP; // New total length

  long EP_NONE = 63;
  long STM_MASK = 1L;
  int CR_SHIFT = 1;
  long CR_MASK = 0b1111L << CR_SHIFT;
  int EP_SHIFT = 5;
  long EP_MASK = 0x3FL << EP_SHIFT;
  int HC_SHIFT = 11;
  long HC_MASK = 0x7FL << HC_SHIFT;
  int FM_SHIFT = 18;
  long FM_MASK = 0x1FFL << FM_SHIFT;

  /* fast helpers – **signatures only** */
  boolean makeMoveInPlace(long[] bb, int move, MoveGenerator gen);
  void undoMoveInPlace(long[] bb);

  long[] fromFen(String fen);

  String toFen(long[] bb);

  long zobrist(long[] bb);

  long zobrist50(long[] bb);
  boolean hasNonPawnMaterial(long[] bb);

  static boolean whiteToMove(long meta) {
    return (meta & STM_MASK) == 0;
  }

  static long castling(long meta) {
    return (meta & CR_MASK) >>> CR_SHIFT;
  }

  static long epSquare(long meta) {
    return (meta & EP_MASK) >>> EP_SHIFT;
  }

  static long halfClock(long meta) {
    return (meta & HC_MASK) >>> HC_SHIFT;
  }

  static long fullMove(long meta) {
    return 1 + ((meta & FM_MASK) >>> FM_SHIFT);
  }
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\Search.java" 
package core.contracts;

import core.records.SearchResult;
import core.records.SearchSpec;

import java.util.concurrent.CompletableFuture;

public interface Search extends AutoCloseable {

    void setEvaluator(Evaluator evaluator);
    void setTranspositionTable(TranspositionTable tt);
    void setThreads(int workerCount);
    void setWorkerPool(WorkerPool pool);
    void setTimeManager(TimeManager timeManager); // Added this line

    SearchResult search(long[] bb, SearchSpec spec, InfoHandler ih);
    CompletableFuture<SearchResult> searchAsync(long[] bb, SearchSpec spec, InfoHandler ih);

    void stop();
    void ponderHit();
    @Override
    void close();
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\SearchWorker.java" 
package core.contracts;

import core.records.SearchResult;
import core.records.SearchSpec;

public interface SearchWorker {
    void prepareForSearch(long[] bb, SearchSpec spec, PositionFactory pf, MoveGenerator mg, Evaluator eval, TranspositionTable tt, TimeManager tm);
    void terminate();
    SearchResult getSearchResult();
    void setInfoHandler(InfoHandler handler);
    void join() throws InterruptedException; // Added for thread management
    long getNodes();
}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\SearchWorkerFactory.java" 
package core.contracts;

/**
 * A factory for creating instances of {@link SearchWorker}.
 *
 * <p>This abstraction allows the {@link WorkerPool} to create search workers
 * without being coupled to a specific implementation.</p>
 */
public interface SearchWorkerFactory {

    /**
     * Creates a new search worker.
     *
     * @param isMainThread Whether this worker will be the main one,
     * responsible for driving iterative deepening.
     * @param pool         The worker pool this worker will belong to.
     * @return A new instance of a {@link SearchWorker}.
     */
    SearchWorker create(boolean isMainThread, WorkerPool pool);
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\TimeManager.java" 
package core.contracts;

import core.records.SearchSpec;
import core.records.TimeAllocation;

/**
 * Calculates the optimal and maximum thinking time for a single move.
 * This is a stateless service.
 */
public interface TimeManager {

    /**
     * Calculates the time allocation for the upcoming search.
     * @param spec The search specification from the GUI (containing wtime, btime, etc.).
     * @param isWhiteToMove True if it is white's turn to move, false otherwise.
     * @return A {@link TimeAllocation} record containing the optimal and maximum move times.
     */
    TimeAllocation calculate(SearchSpec spec, boolean isWhiteToMove);
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\TranspositionTable.java" 
package core.contracts;

import static core.constants.CoreConstants.SCORE_MATE_IN_MAX_PLY;
import static core.constants.CoreConstants.SCORE_TB_LOSS_IN_MAX_PLY;
import static core.constants.CoreConstants.SCORE_TB_WIN_IN_MAX_PLY;
import static core.constants.CoreConstants.SCORE_NONE;

/**
 * Lock-free transposition-table abstraction using a flat long[] for entries.
 * This design achieves **zero allocations** on the hot path.
 *
 * Each entry is 16 bytes (2 longs).
 *
 * • Call {@link #resize(int)} once at start-up or after a "setoption Hash" change.
 * • Call {@link #clear()} at the beginning of every *game*.
 * • Call {@link #incrementAge()} exactly once at the start of each *root* search.
 *
 * {@link #probe(long)} returns an index to either a live hit or a replacement victim.
 * Test the returned index with {@link #wasHit(int, long)} to know which one it is.
 */
public interface TranspositionTable {
    /* ─────────── Bound Flags (Lower 2 bits of packed meta-data) ────────── */

    int FLAG_NONE = 0;
    int FLAG_LOWER = 1;
    int FLAG_UPPER = 2;
    int FLAG_EXACT = FLAG_LOWER | FLAG_UPPER;

    /* ─────────── Primary Ops ─────────── */

    /**
     * Probes the table for a given Zobrist key.
     *
     * @param zobrist The Zobrist key of the position.
     * @return The array index for a matching entry or for a victim entry to be replaced.
     * The index always points to the first of two longs representing the entry.
     */
    int probe(long zobrist);

    /**
     * Checks if the probe resulted in a successful hit.
     *
     * @param entryIndex The index returned by {@link #probe(long)}.
     * @param zobrist    The Zobrist key used for the probe.
     * @return {@code true} if the entry at the index matches the key and is not empty.
     */
    boolean wasHit(int entryIndex, long zobrist);


    /* ─────────── Entry Data Accessors (operating on an entry index) ─────────── */

    int getDepth(int entryIndex);
    int getBound(int entryIndex);
    int getMove(int entryIndex);
    int getStaticEval(int entryIndex);
    boolean wasPv(int entryIndex);

    /**
     * Retrieves the score, adjusting for mate distance from the current ply.
     *
     * @param entryIndex The entry index.
     * @param ply        The current search depth (from the root).
     * @return The mate-adjusted score.
     */
    default int getScore(int entryIndex, int ply) {
        int s = getRawScore(entryIndex);
        if (s == SCORE_NONE) return SCORE_NONE;
        if (s >= SCORE_TB_WIN_IN_MAX_PLY) return s - ply;
        if (s <= SCORE_TB_LOSS_IN_MAX_PLY) return s + ply;
        return s;
    }

    /**
     * Gets the raw, unadjusted score from the table.
     * @param entryIndex The entry index.
     * @return The raw score.
     */
    int getRawScore(int entryIndex);

    /**
     * Stores a new or updated entry in the transposition table.
     * The replacement policy is handled internally.
     *
     * @param entryIndex The index returned by {@link #probe(long)}.
     * @param zobrist    The Zobrist key of the position.
     * @param bound      The bound type (FLAG_EXACT, FLAG_LOWER, FLAG_UPPER).
     * @param depth      The search depth for this entry.
     * @param move       The best move found.
     * @param score      The score of the position.
     * @param staticEval The static evaluation of the position.
     * @param isPv       Whether this was a PV node.
     * @param ply        The current search ply.
     */
    void store(int entryIndex, long zobrist, int bound, int depth, int move,
               int score, int staticEval, boolean isPv, int ply);

    /* ─────────── Life-cycle ─────────── */

    void resize(int megaBytes);
    void clear();
    void incrementAge();
    byte getCurrentAge();
    int hashfull();
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\UciHandler.java" 
package core.contracts;

/**
 * Defines the contract for a class that handles the Universal Chess Interface (UCI)
 * command loop. An implementation of this interface is responsible for parsing
 * commands from a standard input stream (e.g., from a chess GUI) and
 * orchestrating the engine's response.
 */
public interface UciHandler {

    /**
     * Starts the main loop that continuously reads and processes UCI commands
     * until a "quit" command is received or the input stream is closed.
     */
    void runLoop();
}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\UciOptions.java" 
package core.contracts;

/**
 * Defines the contract for a class that manages UCI (Universal Chess Interface)
 * options for the engine. An implementation of this interface is responsible for
 * parsing and applying option settings received from a UCI-compatible GUI.
 */
public interface UciOptions {

    /**
     * Parses a "setoption" command line and applies the given value
     * to the corresponding engine parameter.
     *
     * @param line The full "setoption ..." command line from the GUI.
     */
    void setOption(String line);

    /**
     * Prints all available UCI options to standard output in the format
     * required by the UCI protocol. This is typically sent in response
     * to the "uci" command.
     */
    void printOptions();

    /**
     * Provides access to the transposition table, allowing options
     * (like changing its size) to be applied directly.
     *
     * @return The TranspositionTable instance managed by the options handler.
     */
    TranspositionTable getTranspositionTable();

    String getOptionValue(String name);

    void attachSearch(Search s);
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\contracts\WorkerPool.java" 
package core.contracts;

import core.records.SearchResult;
import core.records.SearchSpec;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Thread-pool façade identical to Obsidian’s design:
 * – fixed-size pool created once
 * – work handed out via a blocking queue
 * – helpers are completely fire-and-forget
 * – stop() flips one shared AtomicBoolean
 */
public interface WorkerPool extends AutoCloseable {

    /* one-off configuration */
    void setParallelism(int threads);

    /* search life-cycle */
    CompletableFuture<SearchResult> startSearch(long[] root,
                                                SearchSpec spec,
                                                PositionFactory pf,
                                                MoveGenerator mg,
                                                Evaluator      eval,
                                                TranspositionTable tt,
                                                TimeManager    tm,
                                                InfoHandler    ih);

    void stopSearch();
    AtomicBoolean getStopFlag();
    long totalNodes();

    /* infra */
    @Override void close();

    long getOptimumMs();
    long getMaximumMs();
}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\EvaluatorImpl.java" 
package core.impl;

import core.contracts.Evaluator;
import core.contracts.PositionFactory;

/**
 * Very small but noticeably stronger evaluation function.
 * Completely stateless, allocation-free and thread-safe.
 */
public final class EvaluatorImpl implements Evaluator {

    /* ----------------------------------------------------------------------
     *                         Static pre-computed data
     * ------------------------------------------------------------------- */

    /** Material values in centipawns, aligned with {@link PositionFactory} indices. */
    private static final int[] VALUE = {
            100, 320, 330, 500, 900, 0,   // White P, N, B, R, Q, K
            100, 320, 330, 500, 900, 0    // Black p, n, b, r, q, k
    };

    /** Bishop-pair bonus (per side). */
    private static final int BISHOP_PAIR_BONUS = 30;

    /** Pawn-structure penalties. */
    private static final int DOUBLED_PAWN_PENALTY   = 15;
    private static final int ISOLATED_PAWN_PENALTY  = 10;

    /** Central-square bonus. */
    private static final int KNIGHT_CENTER_BONUS = 10;
    private static final int ROOK_CENTER_BONUS   = 10;
    private static final int OTHER_CENTER_BONUS  = 5;

    /** Masks for the eight files (a-file = 0). */
    private static final long[] FILE_MASKS = {
            0x0101010101010101L, 0x0202020202020202L,
            0x0404040404040404L, 0x0808080808080808L,
            0x1010101010101010L, 0x2020202020202020L,
            0x4040404040404040L, 0x8080808080808080L
    };

    /** 16 central squares: c-d-e-f files on ranks 3-6 (0-based). */
    private static final long CENTER_16 =
            0x00003C3C3C3C0000L; //   0b0000000000000000001111001111001111000000000000000000000000000000

    /* ────────────────────────────────────────────────────────────────────
     *                Very small Piece-Square Tables (PST)
     *
     *  Tables are given from White’s point of view, starting at a1 = 0.
     *  For Black we mirror the square index with (sq ^ 56).
     *  Source: Slightly smoothed version of the classical “Simplified
     *          Evaluation Function” PSTs by Tomasz Michniewski.
     * ─────────────────────────────────────────────────────────────────── */

    private static final int[] PST_PAWN = {
            0,  0,  0,  0,  0,  0,  0,  0,
            5, 10, 10,-20,-20, 10, 10,  5,
            5, -5,-10,  0,  0,-10, -5,  5,
            0,  0,  0, 20, 20,  0,  0,  0,
            5,  5, 10, 25, 25, 10,  5,  5,
            10, 10, 20, 30, 30, 20, 10, 10,
            50, 50, 50, 50, 50, 50, 50, 50,
            0,  0,  0,  0,  0,  0,  0,  0
    };

    private static final int[] PST_KNIGHT = {
            -50,-40,-30,-30,-30,-30,-40,-50,
            -40,-20,  0,  5,  5,  0,-20,-40,
            -30,  5, 10, 15, 15, 10,  5,-30,
            -30,  0, 15, 20, 20, 15,  0,-30,
            -30,  5, 15, 20, 20, 15,  5,-30,
            -30,  0, 10, 15, 15, 10,  0,-30,
            -40,-20,  0,  0,  0,  0,-20,-40,
            -50,-40,-30,-30,-30,-30,-40,-50
    };

    private static final int[] PST_BISHOP = {
            -20,-10,-10,-10,-10,-10,-10,-20,
            -10,  5,  0,  0,  0,  0,  5,-10,
            -10, 10, 10, 10, 10, 10, 10,-10,
            -10,  0, 10, 10, 10, 10,  0,-10,
            -10,  5,  5, 10, 10,  5,  5,-10,
            -10,  0,  5, 10, 10,  5,  0,-10,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -20,-10,-10,-10,-10,-10,-10,-20
    };

    private static final int[] PST_ROOK = {
            0,  0,  5, 10, 10,  5,  0,  0,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            5, 10, 10, 10, 10, 10, 10,  5,
            0,  0,  0,  0,  0,  0,  0,  0
    };

    private static final int[] PST_QUEEN = {
            -20,-10,-10, -5, -5,-10,-10,-20,
            -10,  0,  5,  0,  0,  0,  0,-10,
            -10,  5,  5,  5,  5,  5,  0,-10,
            0,  0,  5,  5,  5,  5,  0, -5,
            -5,  0,  5,  5,  5,  5,  0, -5,
            -10,  0,  5,  5,  5,  5,  0,-10,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -20,-10,-10, -5, -5,-10,-10,-20
    };

    private static final int[] PST_KING = {
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -20,-30,-30,-40,-40,-30,-30,-20,
            -10,-20,-20,-20,-20,-20,-20,-10,
            20, 20,  0,  0,  0,  0, 20, 20,
            20, 30, 10,  0,  0, 10, 30, 20
    };

    /* For easy PST lookup. */
    private static final int[][] PST = {
            PST_PAWN,      // P
            PST_KNIGHT,    // N
            PST_BISHOP,    // B
            PST_ROOK,      // R
            PST_QUEEN,     // Q
            PST_KING       // K
    };

    /* ----------------------------------------------------------------------
     *                               Evaluation
     * ------------------------------------------------------------------- */

    @Override
    public int evaluate(long[] bb) {

        int white = 0;
        int black = 0;

        /* ========= 1. Material + Piece-Square tables ========= */
        for (int p = PositionFactory.WP; p <= PositionFactory.WK; ++p) {
            long pieces = bb[p];
            int type = p - PositionFactory.WP;           // 0-5
            while (pieces != 0) {
                long sqBit = pieces & -pieces;           // extract LS1B
                int sq = Long.numberOfTrailingZeros(sqBit);
                pieces -= sqBit;

                white += VALUE[p] + PST[type][sq];
                /* Central bonus */
                if ((CENTER_16 & sqBit) != 0) {
                    white += (type == 1 || type == 3) ? KNIGHT_CENTER_BONUS : OTHER_CENTER_BONUS; // N,R = 10, else 5
                }
            }
        }

        for (int p = PositionFactory.BP; p <= PositionFactory.BK; ++p) {
            long pieces = bb[p];
            int type = p - PositionFactory.BP;           // 0-5
            while (pieces != 0) {
                long sqBit = pieces & -pieces;
                int sq = Long.numberOfTrailingZeros(sqBit);
                pieces -= sqBit;

                /* Mirror square for PST lookup */
                int mirrorSq = sq ^ 56;
                black += VALUE[p] + PST[type][mirrorSq];

                if ((CENTER_16 & sqBit) != 0) {
                    black += (type == 1 || type == 3) ? KNIGHT_CENTER_BONUS : OTHER_CENTER_BONUS;
                }
            }
        }

        /* ========= 2. Bishop pair ========= */
        if (Long.bitCount(bb[PositionFactory.WB]) >= 2) white += BISHOP_PAIR_BONUS;
        if (Long.bitCount(bb[PositionFactory.BB]) >= 2) black += BISHOP_PAIR_BONUS;

        /* ========= 3. Pawn structure (doubled / isolated) ========= */
        white -= pawnStructurePenalty(bb[PositionFactory.WP]);
        black -= pawnStructurePenalty(bb[PositionFactory.BP]);

        /* ========= 4. Side to move ========= */
        int diff = white - black;            // >0: White is better
        long meta = bb[PositionFactory.META];
        return PositionFactory.whiteToMove(meta) ? diff : -diff;
    }

    /**
     * Very small pawn-structure assessment.
     * Counts doubled and isolated pawns only – cheap yet effective.
     */
    private static int pawnStructurePenalty(long pawns) {
        int penalty = 0;

        for (int file = 0; file < 8; ++file) {
            long pawnsOnFile = pawns & FILE_MASKS[file];
            int cnt = Long.bitCount(pawnsOnFile);

            if (cnt > 1) {
                penalty += DOUBLED_PAWN_PENALTY * (cnt - 1);
            }
            if (cnt == 1) {
                boolean left  = file > 0 && (pawns & FILE_MASKS[file - 1]) != 0;
                boolean right = file < 7 && (pawns & FILE_MASKS[file + 1]) != 0;
                if (!left && !right) {
                    penalty += ISOLATED_PAWN_PENALTY;
                }
            }
        }
        return penalty;
    }

    @Override
    public void reset() {
        /* Stateless – nothing to clear. */
    }
}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\LazySmpSearchWorkerImpl.java" 
// File: LazySmpSearchWorkerImpl.java
package core.impl;

import core.constants.CoreConstants;
import core.contracts.*;
import core.records.SearchInfo;
import core.records.SearchResult;
import core.records.SearchSpec;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import static core.constants.CoreConstants.*;
import static core.contracts.PositionFactory.HASH;
import static core.contracts.PositionFactory.META;

public final class LazySmpSearchWorkerImpl implements Runnable, SearchWorker {
    private final LazySmpWorkerPoolImpl pool;
    final boolean isMainThread;

    /* ── threading primitives ─────────── */
    private final Lock mutex = new ReentrantLock();
    private final Condition startCondition = mutex.newCondition();
    private final Condition finishedCondition = mutex.newCondition();
    private volatile boolean searching = false;
    private volatile boolean quit = false;

    /* ── per-search state ────────── */
    private long[] rootBoard;
    private SearchSpec spec;
    private PositionFactory pf;
    private MoveGenerator mg;
    private Evaluator eval;
    private TimeManager tm;
    private InfoHandler ih;
    private TranspositionTable tt;
    private MoveOrderer moveOrderer;

    private int lastScore;
    private boolean mateScore;
    private long elapsedMs;
    private int completedDepth;
    private long nodes;
    private int bestMove;
    private int ponderMove;
    private List<Integer> pv = new ArrayList<>();
    private List<Long> gameHistory;
    private final long[] searchPathHistory = new long[MAX_PLY + 2];

    /* ── Heuristics for Time Management ── */
    private int stability;
    private int lastBestMove;
    private final List<Integer> searchScores = new ArrayList<>();
    private final long[][] nodeTable = new long[64][64];
    private final int[][] killers = new int[MAX_PLY + 2][2];

    /* ── History Heuristic ────────── */
    private final int[][] history = new int[64][64];  // from-to scores for quiet moves

    /* ── scratch buffers ─────────────── */
    private final SearchFrame[] frames = new SearchFrame[MAX_PLY + 2];
    private final int[][] moves = new int[MAX_PLY + 2][256];
    private static final int LIST_CAP = 256;

    private static final class SearchFrame {
        int[] pv = new int[MAX_PLY];
        int len;

        void set(int[] childPv, int childLen, int move) {
            pv[0] = move;
            if (childLen > 0) {
                System.arraycopy(childPv, 0, pv, 1, childLen);
            }
            len = childLen + 1;
        }
    }

    public LazySmpSearchWorkerImpl(boolean isMainThread, LazySmpWorkerPoolImpl pool) {
        this.isMainThread = isMainThread;
        this.pool = pool;
        for (int i = 0; i < frames.length; ++i) {
            frames[i] = new SearchFrame();
        }
    }

    @Override
    public void run() {
        idleLoop();
    }

    private void idleLoop() {
        while (true) {
            mutex.lock();
            try {
                searching = false;
                finishedCondition.signal(); // Signal that we are done

                while (!searching && !quit) {
                    try {
                        startCondition.await();
                    } catch (InterruptedException e) {
                        // ignore
                    }
                }

                if (quit) {
                    return;
                }
            } finally {
                mutex.unlock();
            }

            if (isMainThread) {
                mainThreadSearch();
            } else {
                search();
            }
        }
    }

    private void mainThreadSearch() {
        tt.incrementAge();
        pool.startHelpers();
        search();
        pool.waitForHelpersFinished();
        pool.finalizeSearch(getSearchResult());
    }


    private void search() {
        // Reset counters and heuristics
        this.nodes = 0;
        this.completedDepth = 0;
        this.lastScore = 0;
        this.mateScore = false;
        this.elapsedMs = 0;
        this.pv.clear();

        this.stability = 0;
        this.lastBestMove = 0;
        this.searchScores.clear();
        this.bestMove = 0;
        for (long[] row : this.nodeTable) {
            Arrays.fill(row, 0);
        }
        for (int[] k : killers) Arrays.fill(k, 0);
        /* Reset history table before new search */
        for (int[] row : history) {
            Arrays.fill(row, 0);
        }
        // Change: Pass history to move orderer
        this.moveOrderer = new MoveOrdererImpl(history);

        long searchStartMs = pool.getSearchStartTime();
        int maxDepth = spec.depth() > 0 ? spec.depth() : CoreConstants.MAX_PLY;

        int aspirationScore = 0;

        for (int depth = 1; depth <= maxDepth; ++depth) {
            if (pool.isStopped()) break;

            int score;
            int delta = ASP_WINDOW_INITIAL_DELTA;
            int alpha = -SCORE_INF;
            int beta = SCORE_INF;

            // Set up the aspiration window if we are deep enough
            if (depth >= ASP_WINDOW_START_DEPTH) {
                alpha = aspirationScore - delta;
                beta = aspirationScore + delta;
            }

            // Aspiration search loop
            while (true) {
                score = pvs(rootBoard, depth, alpha, beta, 0);

                if (pool.isStopped()) break;

                // If the search fails low (score is below the window),
                // widen the window downwards and re-search.
                if (score <= alpha) {
                    beta = (alpha + beta) / 2; // Keep beta from previous search
                    alpha = Math.max(score - delta, -SCORE_INF);
                }
                // If the search fails high (score is above the window),
                // widen the window upwards and re-search.
                else if (score >= beta) {
                    beta = Math.min(score + delta, SCORE_INF);
                }
                // The score is inside the (alpha, beta) window. Success!
                else {
                    break;
                }

                // On failure, increase the delta for the next re-search attempt.
                delta += delta / 2;
            }

            // Store the successful score for the next iteration's aspiration window
            aspirationScore = score;

            lastScore = score;
            mateScore = Math.abs(score) >= SCORE_MATE_IN_MAX_PLY;
            completedDepth = depth;

            if (frames[0].len > 0) {
                pv = new ArrayList<>(frames[0].len);
                for (int i = 0; i < frames[0].len; i++) {
                    pv.add(frames[0].pv[i]);
                }
                bestMove = pv.get(0);
                ponderMove = pv.size() > 1 ? pv.get(1) : 0;

                if (bestMove == lastBestMove) {
                    stability++;
                } else {
                    stability = 0;
                }
                lastBestMove = bestMove;
            }
            searchScores.add(lastScore);

            elapsedMs = System.currentTimeMillis() - searchStartMs;

            if (isMainThread && ih != null) {
                long totalNodes = pool.totalNodes();
                long nps = elapsedMs > 0 ? (totalNodes * 1000) / elapsedMs : 0;
                ih.onInfo(new SearchInfo(
                        depth, completedDepth, 1, score, mateScore, totalNodes,
                        nps, elapsedMs, pv, tt.hashfull(), 0));
            }

            if (isMainThread) {
                if (mateScore || softTimeUp(searchStartMs, pool.getSoftMs())) {
                    pool.stopSearch();
                }
            }
        }
    }

    private boolean softTimeUp(long searchStartMs, long softTimeLimit) {
        if (softTimeLimit >= Long.MAX_VALUE / 2) {
            return false;
        }

        double multFactor = 1.0;
        // Use the new constant for min depth
        if (completedDepth >= TM_HEURISTICS_MIN_DEPTH && searchScores.size() >= 4 && this.nodes > 0 && lastBestMove != 0) {
            // nodeTM heuristic
            int moveFrom = (lastBestMove >>> 6) & 0x3F;
            int moveTo = lastBestMove & 0x3F;
            long nodesForBestMove = nodeTable[moveFrom][moveTo];
            double nodeRatio = (double) nodesForBestMove / this.nodes;
            // Use the new constant for nodeTM multiplier
            double nodeTM = (1.5 - nodeRatio) * TM_NODE_TM_MULT;

            // bmStability heuristic
            int stabilityMax = TM_STABILITY_COEFF.length - 1;
            double bmStability = TM_STABILITY_COEFF[Math.min(stability, stabilityMax)];

            // scoreStability heuristic
            int currentScore = searchScores.get(searchScores.size() - 1);
            int prevScore3 = searchScores.get(searchScores.size() - 4);
            double scoreDiff = prevScore3 - currentScore;
            // Use the new constant for score stability factor
            double scoreStabilityFactor = Math.max(0.85, Math.min(1.15, TM_SCORE_STABILITY_FACTOR * scoreDiff));

            multFactor = nodeTM * bmStability * scoreStabilityFactor;
        }

        long currentElapsed = System.currentTimeMillis() - searchStartMs;
        multFactor = Math.max(0.1, multFactor);
        return currentElapsed >= (long)(softTimeLimit * multFactor);
    }

    private int pvs(long[] bb, int depth, int alpha, int beta, int ply) {
        frames[ply].len = 0;
        searchPathHistory[ply] = bb[HASH];

        if (ply > 0 && (isRepetitionDraw(bb, ply) || PositionFactory.halfClock(bb[META]) >= 100)) {
            return SCORE_DRAW;
        }

        if (depth <= 0) return quiescence(bb, alpha, beta, ply);

        if (ply > 0) {
            nodes++;
            if ((nodes & 2047) == 0) {
                if(this.completedDepth >= 1)
                {
                    if (pool.isStopped() || (isMainThread && pool.shouldStop(pool.getSearchStartTime(), false))) {
                        pool.stopSearch();
                        return 0;
                    }
                }
            }
            if (ply >= MAX_PLY) return eval.evaluate(bb);
        }

        boolean isPvNode = (beta - alpha) > 1;
        long key = pf.zobrist(bb);

        int ttIndex = tt.probe(key);
        if (tt.wasHit(ttIndex, key) && tt.getDepth(ttIndex) >= depth && ply > 0) {
            int score = tt.getScore(ttIndex, ply);
            int flag = tt.getBound(ttIndex);
            if (flag == TranspositionTable.FLAG_EXACT ||
                    (flag == TranspositionTable.FLAG_LOWER && score >= beta) ||
                    (flag == TranspositionTable.FLAG_UPPER && score <= alpha)) {
                return score; // TT Hit
            }
        }

        boolean inCheck = mg.kingAttacked(bb, PositionFactory.whiteToMove(bb[META]));
        if (inCheck) depth++;

        if (!inCheck && depth >= 3 && !isPvNode && ply > 0) {  // Conditions to apply null move
            // Make null move (flip side to move, no other changes)
            long oldMeta = bb[META];
            bb[META] ^= PositionFactory.STM_MASK;  // Flip STM
            bb[HASH] ^= PositionFactoryImpl.SIDE_TO_MOVE;  // Update hash for STM flip

            // Search with reduced depth (R=2)
            int nullScore = -pvs(bb, depth - 1 - 2, -beta, -beta + 1, ply + 1);

            // Undo null move
            bb[META] = oldMeta;
            bb[HASH] ^= PositionFactoryImpl.SIDE_TO_MOVE;

            if (nullScore >= beta) {
                return beta;  // Cutoff: if passing move is good, real moves are even better
            }
        }

        int[] list = moves[ply];
        int nMoves;
        int capturesEnd;

        if (inCheck) {
            nMoves = mg.generateEvasions(bb, list, 0);
            capturesEnd = nMoves;
        } else {
            capturesEnd = mg.generateCaptures(bb, list, 0);
            nMoves = mg.generateQuiets(bb, list, capturesEnd);
        }

        if (nMoves == 0) return inCheck ? -(SCORE_MATE_IN_MAX_PLY - ply) : SCORE_STALEMATE;

        int ttMove = 0;
        if (tt.wasHit(ttIndex, key)) {
            ttMove = tt.getMove(ttIndex);
            if (ttMove != 0) {
                for (int i = 0; i < nMoves; i++) {
                    if (list[i] == ttMove) {
                        list[i] = list[0];
                        list[0] = ttMove;
                        break;
                    }
                }
            }
        }

        moveOrderer.orderMoves(bb, list, nMoves, ttMove, killers[ply]);

        int bestScore = -SCORE_INF;
        int localBestMove = 0;
        int originalAlpha = alpha;

        for (int i = 0; i < nMoves; i++) {
            int mv = list[i];

            long nodesBeforeMove = this.nodes;

            if (!pf.makeMoveInPlace(bb, mv, mg)) continue;

            boolean isCapture = (i < capturesEnd);
            boolean isPromotion = ((mv >>> 14) & 0x3) == 1;
            boolean isTactical = isCapture || isPromotion;

            int score;
            if (i == 0) {
                score = -pvs(bb, depth - 1, -beta, -alpha, ply + 1);
            } else {
                int lmrDepth = depth - 1;

                // Use the new constants for LMR
                if (depth >=LMR_MIN_DEPTH && i >= LMR_MIN_MOVE_COUNT && !isTactical && !inCheck) {
                    int reduction = (int) (0.75 + Math.log(depth) * Math.log(i) / 2.0);
                    lmrDepth -= Math.max(0, reduction);
                }

                score = -pvs(bb, lmrDepth, -alpha - 1, -alpha, ply + 1);

                if (score > alpha && lmrDepth < depth - 1) {
                    score = -pvs(bb, depth - 1, -alpha - 1, -alpha, ply + 1);
                }
                if (score > alpha && isPvNode) {
                    score = -pvs(bb, depth - 1, -beta, -alpha, ply + 1);
                }
            }

            pf.undoMoveInPlace(bb);
            if (pool.isStopped()) return 0;

            if (ply == 0) {
                long nodesAfterMove = this.nodes;
                long nodesForThisMove = nodesAfterMove - nodesBeforeMove;
                int from = (mv >>> 6) & 0x3F;
                int to = mv & 0x3F;
                nodeTable[from][to] += nodesForThisMove;
            }

            if (score > bestScore) {
                bestScore = score;
                localBestMove = mv;
                if (score > alpha) {
                    alpha = score;
                    if (isPvNode) {
                        frames[ply].set(frames[ply + 1].pv, frames[ply + 1].len, mv);
                    }
                    if (score >= beta) {
                        if (!isTactical) {
                            int from = (mv >>> 6) & 0x3F;
                            int to = mv & 0x3F;
                            history[from][to] += depth * depth;  // Increment by depth^2 for stronger weighting
                        }

                        if (!isTactical) {
                            if (killers[ply][0] != mv) {
                                killers[ply][1] = killers[ply][0];
                                killers[ply][0] = mv;
                            }
                        }
                        break;
                    }
                }
            }
        }

        int flag = (bestScore >= beta) ? TranspositionTable.FLAG_LOWER
                : (bestScore > originalAlpha) ? TranspositionTable.FLAG_EXACT
                : TranspositionTable.FLAG_UPPER;

        tt.store(ttIndex, key, flag, depth, localBestMove, bestScore, SCORE_NONE, isPvNode, ply);

        return bestScore;
    }

    /* ... quiescence and other methods are correct ... */
    private int quiescence(long[] bb, int alpha, int beta, int ply) {
        searchPathHistory[ply] = bb[HASH];
        if (ply > 0 && (isRepetitionDraw(bb, ply) || PositionFactory.halfClock(bb[META]) >= 100)) {
            return SCORE_DRAW;
        }

        if ((nodes & 2047) == 0) {
            if (pool.isStopped()) {
                return 0;
            }
        }

        if (ply >= MAX_PLY) return eval.evaluate(bb);

        nodes++;

        // NEW: Check if the side to move is in check
        boolean whiteToMove = PositionFactory.whiteToMove(bb[META]);
        boolean inCheck = mg.kingAttacked(bb, whiteToMove);

        int standPat = eval.evaluate(bb);
        if (standPat >= beta) return beta;
        if (standPat > alpha) alpha = standPat;

        // NEW: Delta pruning (only if not in check)
        if (!inCheck) {
            int delta = 900; // Approximate queen value for futility
            if (standPat < alpha - delta) {
                return alpha;
            }
        }

        int[] list = moves[ply];
        int nMoves;

        // NEW: If in check, generate evasions (including quiets that evade check); else, captures only
        if (inCheck) {
            nMoves = mg.generateEvasions(bb, list, 0);
        } else {
            nMoves = mg.generateCaptures(bb, list, 0);
        }

        // NEW: Prune and order only if not in check (evasions are already limited)
        if (!inCheck) {
            nMoves = moveOrderer.seePrune(bb, list, nMoves);
            moveOrderer.orderMoves(bb, list, nMoves, 0, killers[ply]);
        }

        // NEW: If in check and no legal evasions, it's checkmate
        if (inCheck && nMoves == 0) {
            return -(SCORE_MATE_IN_MAX_PLY - ply);
        }

        int bestScore = standPat;

        for (int i = 0; i < nMoves; i++) {
            int mv = list[i];
            if (!pf.makeMoveInPlace(bb, mv, mg)) continue;

            int score = -quiescence(bb, -beta, -alpha, ply + 1);
            pf.undoMoveInPlace(bb);

            if (pool.isStopped()) return 0;

            if (score > bestScore) {
                bestScore = score;
                if (score >= beta) return beta;
                if (score > alpha) alpha = score;
            }
        }

        return bestScore;
    }

    /**
     * Checks if the current position is a draw by repetition.
     * It looks through the history of the current search path and the game history
     * within the bounds of the 50-move rule.
     * @param bb The current board state.
     * @param ply The current search ply.
     * @return true if the position is a repetition, false otherwise.
     */
    private boolean isRepetitionDraw(long[] bb, int ply) {
        final long currentHash = bb[HASH];
        final int halfmoveClock = (int) PositionFactory.halfClock(bb[META]);

        // Iterate backwards from the previous position with the same side to move (ply - 2)
        // up to the limit of the current 50-move rule window.
        for (int i = 2; i <= halfmoveClock; i += 2) {
            int prevPly = ply - i;

            long previousHash;
            if (prevPly < 0) {
                // We've gone past the start of the search, so look in gameHistory.
                int gameHistoryIdx = gameHistory.size() + prevPly;
                if (gameHistoryIdx >= 0) {
                    previousHash = gameHistory.get(gameHistoryIdx);
                } else {
                    // We've searched past the beginning of the relevant game history.
                    break;
                }
            } else {
                // We are still within the current search path.
                previousHash = searchPathHistory[prevPly];
            }

            if (previousHash == currentHash) {
                return true; // Repetition found
            }
        }
        return false;
    }

    @Override
    public void prepareForSearch(long[] root, SearchSpec s, PositionFactory p, MoveGenerator m, Evaluator e, TranspositionTable t, TimeManager timeMgr) {
        this.rootBoard = root.clone();
        this.spec = s;
        this.pf = p;
        this.mg = m;
        this.eval = e;
        this.tt = t;
        this.tm = timeMgr;
        this.gameHistory = s.history();
    }

    public void startWorkerSearch() {
        mutex.lock();
        try {
            searching = true;
            startCondition.signal();
        } finally {
            mutex.unlock();
        }
    }

    public void waitWorkerFinished() {
        mutex.lock();
        try {
            while (searching) {
                try {
                    finishedCondition.await();
                } catch (InterruptedException e) {
                    // ignore
                }
            }
        } finally {
            mutex.unlock();
        }
    }

    @Override public void setInfoHandler(InfoHandler handler) { this.ih = handler; }
    @Override public SearchResult getSearchResult() {
        return new SearchResult(bestMove, ponderMove, pv, lastScore, mateScore, completedDepth, nodes, elapsedMs);
    }
    @Override public long getNodes() { return nodes; }
    @Override public void terminate() {
        mutex.lock();
        try {
            quit = true;
            searching = true;
            startCondition.signal();
        } finally {
            mutex.unlock();
        }
    }
    @Override public void join() throws InterruptedException { /* Handled by pool */ }
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\LazySmpWorkerPoolImpl.java" 
// File: LazySmpWorkerPoolImpl.java
package core.impl;

import core.contracts.*;
import core.records.*;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

/**
 * A thread pool that manages a fixed set of persistent worker threads.
 * This design is based on the threading model of high-performance chess engines,
 * where threads are long-lived and coordinated using condition variables.
 */
public final class LazySmpWorkerPoolImpl implements WorkerPool {

    private final SearchWorkerFactory factory;
    private int parallelism;
    private final List<LazySmpSearchWorkerImpl> workers = new ArrayList<>();
    private final List<Thread> threads = new ArrayList<>();

    final AtomicBoolean stopFlag = new AtomicBoolean(false);
    final AtomicLong totalNodes = new AtomicLong(0);

    private volatile long softTimeMs;
    private volatile long hardTimeMs;
    private volatile long searchStartMs;
    private CompletableFuture<SearchResult> searchFuture;

    public LazySmpWorkerPoolImpl(int threads, SearchWorkerFactory f) {
        this.factory = f;
        this.parallelism = threads;
        resizePool();
    }

    public LazySmpWorkerPoolImpl(SearchWorkerFactory f) {
        this(1, f);
    }

    @Override
    public synchronized void setParallelism(int threads) {
        if (threads == this.parallelism) return;
        close();
        this.parallelism = threads;
        resizePool();
    }

    private void resizePool() {
        workers.clear();
        threads.clear();
        for (int i = 0; i < parallelism; i++) {
            LazySmpSearchWorkerImpl worker = (LazySmpSearchWorkerImpl) factory.create(i == 0, this);
            workers.add(worker);
            Thread thread = new Thread(worker, "Helios-Worker-" + i);
            thread.setDaemon(true);
            threads.add(thread);
            thread.start();
        }
    }

    @Override
    public CompletableFuture<SearchResult> startSearch(
            long[] root, SearchSpec spec, PositionFactory pf, MoveGenerator mg,
            Evaluator ev, TranspositionTable tt, TimeManager tm, InfoHandler ih)
    {
        // Wait for the previous search to completely finish
        workers.get(0).waitWorkerFinished();

        // Setup for the new search
        this.stopFlag.set(false);
        this.totalNodes.set(0);
        deriveTimeLimits(spec, tm, PositionFactory.whiteToMove(root[PositionFactory.META]));
        this.searchStartMs = System.currentTimeMillis();

        this.searchFuture = new CompletableFuture<>();

        for (LazySmpSearchWorkerImpl worker : workers) {
            worker.prepareForSearch(root, spec, pf, mg, ev, tt, tm);
            worker.setInfoHandler(worker.isMainThread ? ih : null);
        }

        // Start the main worker, which will orchestrate the others
        workers.get(0).startWorkerSearch();

        return searchFuture;
    }

    // Called by the main worker to wake up helpers
    void startHelpers() {
        for (int i = 1; i < workers.size(); i++) {
            workers.get(i).startWorkerSearch();
        }
    }

    // Called by the main worker to wait for helpers to finish an iteration
    void waitForHelpersFinished() {
        for (int i = 1; i < workers.size(); i++) {
            workers.get(i).waitWorkerFinished();
        }
    }

    // Called by main worker when search is fully complete
    void finalizeSearch(SearchResult mainResult) {
        long allNodes = 0;
        for (LazySmpSearchWorkerImpl w : workers) {
            allNodes += w.getNodes();
        }

        SearchResult finalResult = new SearchResult(
                mainResult.bestMove(), mainResult.ponderMove(), mainResult.pv(),
                mainResult.scoreCp(), mainResult.mateFound(), mainResult.depth(),
                allNodes, // Use aggregate node count
                mainResult.timeMs()
        );

        if (searchFuture != null && !searchFuture.isDone()) {
            searchFuture.complete(finalResult);
        }
    }

    boolean shouldStop(long searchStartMs, boolean mateFound) {
        if (mateFound) return true;
        // This is now only the HARD limit check. Soft limit is handled by the worker.
        if (hardTimeMs >= Long.MAX_VALUE / 2) return false; // Infinite time
        long elapsed = System.currentTimeMillis() - searchStartMs;
        return elapsed >= hardTimeMs;
    }

    void reportNodeCount(long nodes) {
        // This method can be used if more frequent updates are needed.
    }

    @Override public long totalNodes() {
        long total = 0;
        for (SearchWorker w : workers) {
            total += w.getNodes();
        }
        return total;
    }

    @Override public void stopSearch() { stopFlag.set(true); }
    boolean isStopped() { return stopFlag.get(); }
    @Override public AtomicBoolean getStopFlag() { return stopFlag; }

    @Override
    public synchronized void close() {
        if (workers.isEmpty()) return;

        for (LazySmpSearchWorkerImpl worker : workers) {
            worker.terminate();
        }
        for (Thread thread : threads) {
            try {
                thread.join(100); // Wait briefly for clean exit
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        workers.clear();
        threads.clear();
    }

    public long getSoftMs() { return softTimeMs; }
    public long getSearchStartTime() { return searchStartMs; }

    // Kept for interface compatibility if other parts of the code use them.
    @Override public long getOptimumMs() { return softTimeMs; }
    @Override public long getMaximumMs() { return hardTimeMs; }

    private void deriveTimeLimits(SearchSpec spec, TimeManager tm, boolean white) {
        TimeAllocation ta = tm.calculate(spec, white);
        this.softTimeMs = ta.soft();
        this.hardTimeMs = ta.maximum();
    }
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\MoveGeneratorImpl.java" 
package core.impl;

import static core.impl.PreCompMoveGenTables.*;
import static core.contracts.PositionFactory.*;

import core.contracts.*;

public final class MoveGeneratorImpl implements MoveGenerator {
  /* ── bit-board constants ─────────────────────────────────────── */
  static final long FILE_A = 0x0101_0101_0101_0101L;
  static final long FILE_H = FILE_A << 7;

  private static final long RANK_1 = 0xFFL;
  private static final long RANK_2 = RANK_1 << 8;
  private static final long RANK_3 = RANK_1 << 16;
  private static final long RANK_6 = RANK_1 << 40;
  private static final long RANK_7 = RANK_1 << 48;
  private static final long RANK_8 = RANK_1 << 56;

  private static final int MOVER_SHIFT = 16;

  @Override
  public int generateCaptures(long[] bb, int[] mv, int n) {
    return whiteToMove(bb[META])
            ? genCapturesWhite(bb, mv, n)
            : genCapturesBlack(bb, mv, n);
  }

  /* -------- WHITE to move -------------------------------------- */
  private static int genCapturesWhite(long[] bb, int[] mv, int n) {

    /* inlined piece IDs – now compile-time constants */
    final int usP = WP, usN = WN, usB = WB, usR = WR, usQ = WQ, usK = WK;
    /* aggregate bitboards (all constant folds, no “?:” branches) */
    final long own   = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long enemy = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long occ   = own | enemy;
    final long captMask = enemy;
    final long allCapt  = captMask;          // alias (keeps old code unchanged)

    /* === copy the body of your old generateCaptures() verbatim ==
       ↓↓↓  keep every helper call, but pass “true” for ‘white’  ↓↓↓ */
    n  = addPawnCaptures(bb, /*white=*/true,  occ, enemy, mv, n, usP);
    n  = addPawnPushes   (bb[usP], true, occ, mv, n, usP,
            /*Q?*/true, /*RBN?*/false,
            /*quiet?*/false, /*double?*/false);
    n  = addKnightMoves(bb[usN], allCapt, mv, n, usN);

    long bishops = bb[usB];
    while (bishops != 0) {
      int from = Long.numberOfTrailingZeros(bishops);
      bishops &= bishops - 1;
      long tgt = bishopAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usB);
    }

    long rooks = bb[usR];
    while (rooks != 0) {
      int from = Long.numberOfTrailingZeros(rooks);
      rooks &= rooks - 1;
      long tgt = rookAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usR);
    }

    long queens = bb[usQ];
    while (queens != 0) {
      int from = Long.numberOfTrailingZeros(queens);
      queens &= queens - 1;
      long tgt = queenAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usQ);
    }

    n  = addKingMovesAndCastle(bb, /*white=*/true,  occ,
            /*enemySeen=*/0L, captMask, 0L,
            mv, n, usK);
    return n;
  }

  /* -------- BLACK to move -------------------------------------- */
  private static int genCapturesBlack(long[] bb, int[] mv, int n) {

    final int usP = BP, usN = BN, usB = BB, usR = BR, usQ = BQ, usK = BK;
    final long own   = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long enemy = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long occ   = own | enemy;
    final long captMask = enemy;
    final long allCapt  = captMask;

    n  = addPawnCaptures(bb, /*white=*/false, occ, enemy, mv, n, usP);
    n  = addPawnPushes   (bb[usP], false, occ, mv, n, usP,
            /*Q?*/true, /*RBN?*/false,
            /*quiet?*/false, /*double?*/false);
    n  = addKnightMoves(bb[usN], allCapt, mv, n, usN);

    long bishops = bb[usB];
    while (bishops != 0) {
      int from = Long.numberOfTrailingZeros(bishops);
      bishops &= bishops - 1;
      long tgt = bishopAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usB);
    }

    long rooks = bb[usR];
    while (rooks != 0) {
      int from = Long.numberOfTrailingZeros(rooks);
      rooks &= rooks - 1;
      long tgt = rookAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usR);
    }

    long queens = bb[usQ];
    while (queens != 0) {
      int from = Long.numberOfTrailingZeros(queens);
      queens &= queens - 1;
      long tgt = queenAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usQ);
    }

    n  = addKingMovesAndCastle(bb, /*white=*/false, occ,
            /*enemySeen=*/0L, captMask, 0L,
            mv, n, usK);
    return n;
  }

  @Override
  public int generateQuiets(long[] bb, int[] mv, int n) {
    return whiteToMove(bb[META])
            ? genQuietsWhite(bb, mv, n)
            : genQuietsBlack(bb, mv, n);
  }

  private static int genQuietsWhite(long[] bb, int[] mv, int n) {

    final int usP = WP, usN = WN, usB = WB, usR = WR, usQ = WQ, usK = WK;
    final long own   = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long enemy = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long occ   = own | enemy;

    long quietMask = ~occ;
    long allQuiet  = quietMask;

    n = addPawnPushes(bb[usP], /*white=*/true,  occ, mv, n, usP,
            /*Q?*/false, /*RBN?*/true,
            /*quiet?*/true,  /*double?*/true);
    n = addKnightMoves(bb[usN], allQuiet, mv, n, usN);

    for (long bishops = bb[usB]; bishops != 0; ) {
      int from = Long.numberOfTrailingZeros(bishops);
      bishops &= bishops - 1;
      long tgt = bishopAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usB);
    }
    for (long rooks = bb[usR]; rooks != 0; ) {
      int from = Long.numberOfTrailingZeros(rooks);
      rooks &= rooks - 1;
      long tgt = rookAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usR);
    }
    for (long queens = bb[usQ]; queens != 0; ) {
      int from = Long.numberOfTrailingZeros(queens);
      queens &= queens - 1;
      long tgt = queenAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usQ);
    }

    n = addKingMovesAndCastle(bb, /*white=*/true,  occ,
            /*enemySeen*/0L, /*captMask*/0L,
            quietMask, mv, n, usK);
    return n;
  }

  private static int genQuietsBlack(long[] bb, int[] mv, int n) {

    final int usP = BP, usN = BN, usB = BB, usR = BR, usQ = BQ, usK = BK;
    final long own   = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long enemy = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long occ   = own | enemy;

    long quietMask = ~occ;
    long allQuiet  = quietMask;

    n = addPawnPushes(bb[usP], /*white=*/false, occ, mv, n, usP,
            /*Q?*/false, /*RBN?*/true,
            /*quiet?*/true,  /*double?*/true);
    n = addKnightMoves(bb[usN], allQuiet, mv, n, usN);

    for (long bishops = bb[usB]; bishops != 0; ) {
      int from = Long.numberOfTrailingZeros(bishops);
      bishops &= bishops - 1;
      long tgt = bishopAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usB);
    }
    for (long rooks = bb[usR]; rooks != 0; ) {
      int from = Long.numberOfTrailingZeros(rooks);
      rooks &= rooks - 1;
      long tgt = rookAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usR);
    }
    for (long queens = bb[usQ]; queens != 0; ) {
      int from = Long.numberOfTrailingZeros(queens);
      queens &= queens - 1;
      long tgt = queenAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usQ);
    }

    n = addKingMovesAndCastle(bb, /*white=*/false, occ,
            /*enemySeen*/0L, /*captMask*/0L,
            quietMask, mv, n, usK);
    return n;
  }

  @Override
  public int generateEvasions(long[] bb, int[] mv, int n) {
    return whiteToMove(bb[META])
            ? genEvasionsWhite(bb, mv, n)
            : genEvasionsBlack(bb, mv, n);
  }

  private static int genEvasionsWhite(long[] bb, int[] mv, int n) {

    final int usP = WP, usN = WN, usB = WB, usR = WR, usQ = WQ, usK = WK;
    final long own   = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long enemy = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long occ   = own | enemy;

    int  kSq      = Long.numberOfTrailingZeros(bb[usK]);
    long checkers = attackersToSquare(bb, occ, kSq, /*usIsWhite=*/true);
    long dblCheck = checkers & (checkers - 1);

    if (dblCheck != 0) {                           // king must move
      long kingMoves = KING_ATK[kSq] & ~own;
      while (kingMoves != 0) {
        int to = Long.numberOfTrailingZeros(kingMoves);
        kingMoves &= kingMoves - 1;
        mv[n++] = mv(kSq, to, 0, usK);
      }
      return n;
    }

    int  checkerSq = Long.numberOfTrailingZeros(checkers);
    long target    = checkers | between(kSq, checkerSq);

    long kingTgt = KING_ATK[kSq] & ~own;
    while (kingTgt != 0) {
      int to = Long.numberOfTrailingZeros(kingTgt);
      kingTgt &= kingTgt - 1;
      mv[n++] = mv(kSq, to, 0, usK);
    }

    n = addPawnCapturesTarget(bb, /*white=*/true,  occ, enemy, mv, n, usP, target);
    n = addPawnPushBlocks  (bb[usP], /*white=*/true,  occ, mv, n, usP, target);

    n = addKnightEvasions(bb[usN], target, mv, n, usN);

    for (long sliders = bb[usB] | bb[usR] | bb[usQ]; sliders != 0; ) {
      int from = Long.numberOfTrailingZeros(sliders);
      sliders &= sliders - 1;

      long ray, piece;
      if ((bb[usB] & (1L << from)) != 0) {         // bishop
        ray   = bishopAtt(occ, from);
        piece = usB;
      } else if ((bb[usR] & (1L << from)) != 0) {  // rook
        ray   = rookAtt(occ, from);
        piece = usR;
      } else {                                     // queen
        ray   = queenAtt(occ, from);
        piece = usQ;
      }
      long tgt = ray & target;
      n = emitSliderMoves(mv, n, from, tgt, (int) piece);
    }

    n = addEnPassantEvasions(bb, /*white=*/true,  mv, n, usP, checkerSq, checkers);
    return n;
  }

  private static int genEvasionsBlack(long[] bb, int[] mv, int n) {

    final int usP = BP, usN = BN, usB = BB, usR = BR, usQ = BQ, usK = BK;
    final long own   = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long enemy = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long occ   = own | enemy;

    int  kSq      = Long.numberOfTrailingZeros(bb[usK]);
    long checkers = attackersToSquare(bb, occ, kSq, /*usIsWhite=*/false);
    long dblCheck = checkers & (checkers - 1);

    if (dblCheck != 0) {
      long kingMoves = KING_ATK[kSq] & ~own;
      while (kingMoves != 0) {
        int to = Long.numberOfTrailingZeros(kingMoves);
        kingMoves &= kingMoves - 1;
        mv[n++] = mv(kSq, to, 0, usK);
      }
      return n;
    }

    int  checkerSq = Long.numberOfTrailingZeros(checkers);
    long target    = checkers | between(kSq, checkerSq);

    long kingTgt = KING_ATK[kSq] & ~own;
    while (kingTgt != 0) {
      int to = Long.numberOfTrailingZeros(kingTgt);
      kingTgt &= kingTgt - 1;
      mv[n++] = mv(kSq, to, 0, usK);
    }

    n = addPawnCapturesTarget(bb, /*white=*/false, occ, enemy, mv, n, usP, target);
    n = addPawnPushBlocks  (bb[usP], /*white=*/false, occ, mv, n, usP, target);

    n = addKnightEvasions(bb[usN], target, mv, n, usN);

    for (long sliders = bb[usB] | bb[usR] | bb[usQ]; sliders != 0; ) {
      int from = Long.numberOfTrailingZeros(sliders);
      sliders &= sliders - 1;

      long ray, piece;
      if ((bb[usB] & (1L << from)) != 0) {
        ray   = bishopAtt(occ, from);
        piece = usB;
      } else if ((bb[usR] & (1L << from)) != 0) {
        ray   = rookAtt(occ, from);
        piece = usR;
      } else {
        ray   = queenAtt(occ, from);
        piece = usQ;
      }
      long tgt = ray & target;
      n = emitSliderMoves(mv, n, from, tgt, (int) piece);
    }

    n = addEnPassantEvasions(bb, /*white=*/false, mv, n, usP, checkerSq, checkers);
    return n;
  }

  @Override
  public boolean castleLegal(long[] bb, int from, int to) {

    // 1) side & pre-computed constants ------------------------------
    boolean white = from == 4; // 4→e1 / 60→e8
    int rookFrom  = white
            ? (to == 6 ? 7  : 0)          // h1  : a1
            : (to == 62 ? 63 : 56);       // h8  : a8
    long pathMask = to == 6 || to == 62
            ? /* king-side  */ (1L << (from+1)) | (1L << (from+2))
            : /* queen-side */ (1L << (from-1)) | (1L << (from-2)) | (1L << (from-3));

    // 2) required castling right still set? -------------------------
    int rights = (int)((bb[META] & CR_MASK) >>> CR_SHIFT);
    int need   = white
            ? (to == 6 ? 1 : 2)             // K / Q
            : (to == 62 ? 4 : 8);           // k / q
    if ( (rights & need) == 0 )
      return false; // right already lost

    // 3) path empty? -------------------------------------------------
    long occ =  bb[WP]|bb[WN]|bb[WB]|bb[WR]|bb[WQ]|bb[WK]
            | bb[BP]|bb[BN]|bb[BB]|bb[BR]|bb[BQ]|bb[BK];

    if ( (occ & pathMask) != 0 || (occ & (1L<<rookFrom)) == 0 )
      return false; // something blocks

    // 4) none of origin / transit / target squares may be attacked --
    int  transit = (to == 6 || to == 62) ? from+1 : from-1;

    if (squareAttacked(bb, !white, from) ||
            squareAttacked(bb, !white, transit) ||
            squareAttacked(bb, !white, to))
      return false;

    return true;
  }

  /** EP capture that removes the checking pawn. */
  private static int addEnPassantEvasions(long[] bb, boolean white,
                                          int[] mv, int n, int usP,
                                          int checkerSq, long checkers) {

    int epSq = (int)((bb[META] & EP_MASK) >>> EP_SHIFT);
    if (epSq == EP_NONE) return n; // no EP square
    if ( (checkers & (white ? bb[BP] : bb[WP])) == 0 )   // checker isn’t a pawn
      return n;

    int victim = white ? epSq - 8 : epSq + 8; // pawn behind EP
    if (victim != checkerSq) return n; // not the checker

    long epBit = 1L << epSq;
    long pawns =
            white
                    ? (((epBit & ~FILE_A) >>> 9) | ((epBit & ~FILE_H) >>> 7)) & bb[WP]
                    : (((epBit & ~FILE_H) <<  9) | ((epBit & ~FILE_A) <<  7)) & bb[BP];

    while (pawns != 0) {
      int from = Long.numberOfTrailingZeros(pawns);
      pawns &= pawns - 1;
      mv[n++] = mv(from, epSq, 2, usP);                // flag 2 = EP
    }
    return n;
  }

  /* thin public wrapper around the private attackersToSquare() */
  private boolean squareAttacked(long[] bb, boolean byWhite, int sq) {
    long occ =  bb[WP]|bb[WN]|bb[WB]|bb[WR]|bb[WQ]|bb[WK]
            | bb[BP]|bb[BN]|bb[BB]|bb[BR]|bb[BQ]|bb[BK];

    return attackersToSquare(bb, occ, sq, /*usIsWhite=*/!byWhite) != 0;
  }

  private static long between(int from, int to) {
    return BETWEEN[from * 64 + to];
  }

  private static int emitSliderMoves(int[] mv, int n, int from, long tgt, int piece) {
    while (tgt != 0) {
      int to = Long.numberOfTrailingZeros(tgt);
      tgt &= tgt - 1;
      mv[n++] = mv(from, to, 0, piece);
    }
    return n;
  }

  /* pawn pushes, promotions & double-pushes — never emits captures */
  private static int addPawnPushes(
          long pawns,
          boolean white,
          long occ,
          int[] mv,
          int n,
          int usP,
          boolean includeQueenPromo, // emit Q?
          boolean includeUnderPromo, // emit R/B/N?
          boolean includeQuietPush, // 1-square non-promo push
          boolean includeDoublePush) // 2-square push
  {
    final int dir = white ? 8 : -8;
    final long one = white ? ((pawns << 8) & ~occ) : ((pawns >>> 8) & ~occ);
    final long PROMO = white ? RANK_8 : RANK_1;

    /* ── promotions on push ─────────────────────────────────────── */
    long promo = one & PROMO;
    while (promo != 0L) {
      int to = Long.numberOfTrailingZeros(promo);
      promo &= promo - 1;
      if (includeQueenPromo && includeUnderPromo)
        n = emitPromotions(mv, n, to - dir, to, usP); // Q R B N
      else if (includeQueenPromo) n = emitQueenPromotion(mv, n, to - dir, to, usP); // Q
      else if (includeUnderPromo) n = emitUnderPromotions(mv, n, to - dir, to, usP); // R B N
    }

    /* ── quiet non-promo single pushes ──────────────────────────── */
    if (includeQuietPush) {
      long quiet = one & ~PROMO;
      while (quiet != 0L) {
        int to = Long.numberOfTrailingZeros(quiet);
        quiet &= quiet - 1;
        mv[n++] = mv(to - dir, to, 0, usP);
      }
    }

    /* ── double pushes ──────────────────────────────────────────── */
    if (includeDoublePush) {
      long rank3 = white ? RANK_3 : RANK_6;
      long two = white ? (((one & rank3) << 8) & ~occ) : (((one & rank3) >>> 8) & ~occ);
      while (two != 0L) {
        int to = Long.numberOfTrailingZeros(two);
        two &= two - 1;
        mv[n++] = mv(to - 2 * dir, to, 0, usP);
      }
    }
    return n;
  }

  private static int addPawnCaptures(
          long[] bb,
          boolean white,
          long occ, // current occupancy (unused but kept for signature parity)
          long enemy, // every enemy piece
          int[] mv,
          int n,
          int usP) {

    /* ------------------------------------------------------------------
     * Filter out any square that is occupied by one of **our** pieces.
     * This guarantees the generator never outputs a capture onto
     * a friendly man – even if ‘enemy’ is corrupted (e.g. by a bug
     * elsewhere) and happens to include friendly bits.
     * ------------------------------------------------------------------ */
    long own =
            white
                    ? (bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK])
                    : (bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK]);
    long legalTargets = enemy & ~own; // enemy squares *only*

    long pawns = bb[usP];
    long PROMO = white ? RANK_8 : RANK_1;

    long capL = white ? ((pawns & ~FILE_A) << 7) : ((pawns & ~FILE_H) >>> 7);
    long capR = white ? ((pawns & ~FILE_H) << 9) : ((pawns & ~FILE_A) >>> 9);

    long promoL = capL & legalTargets & PROMO;
    long promoR = capR & legalTargets & PROMO;
    capL &= legalTargets & ~PROMO;
    capR &= legalTargets & ~PROMO;

    final int dL = white ? -7 : 7;
    final int dR = white ? -9 : 9;

    while (capL != 0) {
      int to = Long.numberOfTrailingZeros(capL);
      capL &= capL - 1;
      mv[n++] = mv(to + dL, to, 0, usP);
    }
    while (capR != 0) {
      int to = Long.numberOfTrailingZeros(capR);
      capR &= capR - 1;
      mv[n++] = mv(to + dR, to, 0, usP);
    }
    while (promoL != 0) {
      int to = Long.numberOfTrailingZeros(promoL);
      promoL &= promoL - 1;
      n = emitPromotions(mv, n, to + dL, to, usP);
    }
    while (promoR != 0) {
      int to = Long.numberOfTrailingZeros(promoR);
      promoR &= promoR - 1;
      n = emitPromotions(mv, n, to + dR, to, usP);
    }

    /* ---- en-passant (unchanged) ------------------------------------ */
    long epSqRaw = (bb[META] & EP_MASK) >>> EP_SHIFT;
    if (epSqRaw != 63) {
      long epBit = 1L << epSqRaw; // empty EP square
      long behind =
              white
                      ? epBit >>> 8 // pawn to be taken
                      : epBit << 8;
      if ((enemy & behind) != 0) { // real enemy pawn?

        long epL = white ? ((pawns & ~FILE_A) << 7) & epBit : ((pawns & ~FILE_H) >>> 7) & epBit;
        long epR = white ? ((pawns & ~FILE_H) << 9) & epBit : ((pawns & ~FILE_A) >>> 9) & epBit;

        while (epL != 0) {
          int to = Long.numberOfTrailingZeros(epL);
          epL &= epL - 1;
          mv[n++] = mv(to + (white ? -7 : 7), to, 2, usP);
        }
        while (epR != 0) {
          int to = Long.numberOfTrailingZeros(epR);
          epR &= epR - 1;
          mv[n++] = mv(to + (white ? -9 : 9), to, 2, usP);
        }
      }
    }
    return n;
  }

  private static int addKnightMoves(long knights, long targetMask, int[] mv, int n, int usN) {
    while (knights != 0) {
      int from = Long.numberOfTrailingZeros(knights);
      knights &= knights - 1;
      long tgt = KNIGHT_ATK[from] & targetMask;
      while (tgt != 0) {
        int to = Long.numberOfTrailingZeros(tgt);
        tgt &= tgt - 1;
        mv[n++] = mv(from, to, 0, usN);
      }
    }
    return n;
  }

  private static int addKingMovesAndCastle(
          long[] bb,
          boolean white,
          long occ,
          long enemySeen,
          long captMask,
          long quietMask,
          int[] mv,
          int n,
          int usK) {

    int kSq = Long.numberOfTrailingZeros(bb[usK]);
    /* own pieces only – enemy squares stay available for capture */
    long own = occ & ~captMask;
    long moves = KING_ATK[kSq] & ~own; // legal destinations

    /* ---- quiet king moves ----------------------------------------- */
    long qs = moves & quietMask;
    while (qs != 0) {
      int to = Long.numberOfTrailingZeros(qs);
      qs &= qs - 1;
      mv[n++] = mv(kSq, to, 0, usK);
    }

    /* ---- king captures -------------------------------------------- */
    long cs = moves & captMask;
    while (cs != 0) {
      int to = Long.numberOfTrailingZeros(cs);
      cs &= cs - 1;
      mv[n++] = mv(kSq, to, 0, usK);
    }

    /* ---- castling (only if we were asked for quiet moves) ---------- */
    if (quietMask != 0) {
      int rights = (int) ((bb[META] & CR_MASK) >>> CR_SHIFT);
      if (white) {
        /* 0-0 */
        if ((rights & 1) != 0
                && ((bb[WR] & (1L << 7)) != 0)
                && ((occ & 0x60L) == 0)) mv[n++] = mv(4, 6, 3, WK);
        /* 0-0-0 */
        if ((rights & 2) != 0
                && ((bb[WR] & (1L << 0)) != 0)
                && ((occ & 0x0EL) == 0)) mv[n++] = mv(4, 2, 3, WK);
      } else {
        /* 0-0 */
        if ((rights & 4) != 0
                && ((bb[BR] & (1L << 63)) != 0)
                && ((occ & 0x6000_0000_0000_0000L) == 0)) mv[n++] = mv(60, 62, 3, BK);
        /* 0-0-0 */
        if ((rights & 8) != 0
                && ((bb[BR] & (1L << 56)) != 0)
                && ((occ & 0x0E00_0000_0000_0000L) == 0)) mv[n++] = mv(60, 58, 3, BK);
      }
    }
    return n;
  }

  /** all enemy pieces that attack ‘sq’ (used to locate checkers) */
  private static long attackersToSquare(long[] bb, long occ, int sq, boolean usIsWhite) {
    boolean enemyWhite = !usIsWhite;
    long atk = 0L, sqBit = 1L << sq;

    /* pawns */
    atk |= enemyWhite
            ? bb[WP] & (((sqBit & ~FILE_H) >>> 7) | ((sqBit & ~FILE_A) >>> 9))
            : bb[BP] & (((sqBit & ~FILE_H) << 9) | ((sqBit & ~FILE_A) << 7));
    /* knights */
    atk |= KNIGHT_ATK[sq] & (enemyWhite ? bb[WN] : bb[BN]);
    /* bishops/queens */
    atk |= bishopAtt(occ, sq) & (enemyWhite ? (bb[WB] | bb[WQ]) : (bb[BB] | bb[BQ]));
    /* rooks/queens */
    atk |= rookAtt(occ, sq) & (enemyWhite ? (bb[WR] | bb[WQ]) : (bb[BR] | bb[BQ]));
    /* king */
    atk |= KING_ATK[sq] & (enemyWhite ? bb[WK] : bb[BK]);

    return atk;
  }

  /* pawn captures to any square in ‘target’ (no EP) */
  private static int addPawnCapturesTarget(
          long[] bb, boolean white, long occ, long enemy, int[] mv, int n, int usP, long target) {

    long pawns = bb[usP];
    final long PROMO = white ? RANK_8 : RANK_1;

    /* ---------- left-diagonal captures (from the pawn’s point of view) */
    long capL =
            white
                    ? ((pawns & ~FILE_A) << 7) // ⭡⭠  for White
                    : ((pawns & ~FILE_H) >>> 7); // ⭣⭢  for Black
    int dL = white ? 7 : -7; // dest − from

    for (long m = capL & enemy & target; m != 0; m &= m - 1) {
      int to = Long.numberOfTrailingZeros(m);
      int from = to - dL; // pawn is dL behind ‘to’
      if ((PROMO & (1L << to)) != 0) n = emitPromotions(mv, n, from, to, usP); // Q R B N
      else mv[n++] = mv(from, to, 0, usP);
    }

    /* ---------- right-diagonal captures */
    long capR =
            white
                    ? ((pawns & ~FILE_H) << 9) // ⭡⭢  for White
                    : ((pawns & ~FILE_A) >>> 9); // ⭣⭠  for Black
    int dR = white ? 9 : -9;
    for (long m = capR & enemy & target; m != 0; m &= m - 1) {
      int to = Long.numberOfTrailingZeros(m);
      int from = to - dR;
      if ((PROMO & (1L << to)) != 0) n = emitPromotions(mv, n, from, to, usP);
      else mv[n++] = mv(from, to, 0, usP);
    }
    return n;
  }

  /** Bug Fix: Correctly filter double pushes by the target mask for check evasions. */
  private static int addPawnPushBlocks(
          long pawns, boolean white, long occ, int[] mv, int n, int usP, long target) {
    final int dir = white ? 8 : -8;
    final long one = white ? ((pawns << 8) & ~occ) : ((pawns >>> 8) & ~occ);
    long singleBlocks = one & target;

    final long PROMO = white ? RANK_8 : RANK_1;
    long promo = singleBlocks & PROMO;
    long quiet = singleBlocks & ~PROMO;

    while (promo != 0) {
      int to = Long.numberOfTrailingZeros(promo);
      promo &= promo - 1;
      n = emitPromotions(mv, n, to - dir, to, usP);
    }
    while (quiet != 0) {
      int to = Long.numberOfTrailingZeros(quiet);
      quiet &= quiet - 1;
      mv[n++] = mv(to - dir, to, 0, usP);
    }

    final long startRankForDoublePush = white ? RANK_3 : RANK_6;
    long doublePushDestinations =
            white
                    ? (((one & startRankForDoublePush) << 8) & ~occ)
                    : (((one & startRankForDoublePush) >>> 8) & ~occ);
    doublePushDestinations &= target; // BUG FIX: Filter double pushes by the target mask.

    while (doublePushDestinations != 0) {
      int to = Long.numberOfTrailingZeros(doublePushDestinations);
      doublePushDestinations &= doublePushDestinations - 1;
      mv[n++] = mv(to - 2 * dir, to, 0, usP);
    }

    return n;
  }


  /* knights that jump onto ‘target’ */
  private static int addKnightEvasions(long knights, long target, int[] mv, int n, int usN) {
    while (knights != 0) {
      int from = Long.numberOfTrailingZeros(knights);
      knights &= knights - 1;
      long tgt = KNIGHT_ATK[from] & target;
      while (tgt != 0) {
        int to = Long.numberOfTrailingZeros(tgt);
        tgt &= tgt - 1;
        mv[n++] = mv(from, to, 0, usN);
      }
    }
    return n;
  }

  @Override
  public boolean kingAttacked(long[] bb, boolean whiteSide) {
    // delegate to the colour-specific fast path
    return whiteSide ? kingAttackedWhite(bb)    // we just moved → our king is WHITE
            : kingAttackedBlack(bb);   // we just moved → our king is BLACK
  }

  /* our king = WHITE, attackers = BLACK */
  private static boolean kingAttackedWhite(long[] bb) {
    int kSq = Long.numberOfTrailingZeros(bb[WK]);
    /* 1) pawn & knight checks – cheap fast exits */
    if ( (bb[BP] & PAWN_ATK_W[kSq]) != 0 ) return true;
    if ( (bb[BN] & KNIGHT_ATK[kSq]) != 0 ) return true;
    /* 2) build occupancy once (12 ORs instead of 6+6+1) */
    long occ = bb[WP]|bb[WN]|bb[WB]|bb[WR]|bb[WQ]|bb[WK]
            | bb[BP]|bb[BN]|bb[BB]|bb[BR]|bb[BQ]|bb[BK];

    /* 3) sliders */
    if ( (bishopAtt(occ, kSq) & (bb[BB] | bb[BQ])) != 0 ) return true;
    if ( (rookAtt  (occ, kSq) & (bb[BR] | bb[BQ])) != 0 ) return true;
    /* 4) opposing king */
    return (bb[BK] & KING_ATK[kSq]) != 0;
  }

  /* our king = BLACK, attackers = WHITE */
  private static boolean kingAttackedBlack(long[] bb) {
    int kSq = Long.numberOfTrailingZeros(bb[BK]);
    if ( (bb[WP] & PAWN_ATK_B[kSq]) != 0 ) return true;
    if ( (bb[WN] & KNIGHT_ATK[kSq]) != 0 ) return true;
    long occ = bb[WP]|bb[WN]|bb[WB]|bb[WR]|bb[WQ]|bb[WK]
            | bb[BP]|bb[BN]|bb[BB]|bb[BR]|bb[BQ]|bb[BK];
    if ( (bishopAtt(occ, kSq) & (bb[WB] | bb[WQ])) != 0 ) return true;
    if ( (rookAtt  (occ, kSq) & (bb[WR] | bb[WQ])) != 0 ) return true;
    return (bb[WK] & KING_ATK[kSq]) != 0;
  }

  /* ───────────────── helper to emit the 4 promotion types ─────── */
  private static int emitPromotions(int[] moves, int n, int from, int to, int mover) {
    int base = mv(from, to, 1, mover); // flag 1 = promotion
    moves[n++] = base | (3 << 12); // Q
    moves[n++] = base | (2 << 12); // R
    moves[n++] = base | (1 << 12); // B
    moves[n++] = base; // N
    return n;
  }

  private static int emitQueenPromotion(int[] mv, int n, int from, int to, int mover) {
    int base = mv(from, to, 1, mover); // flag 1 = promotion
    mv[n++] = base | (3 << 12); // Q only
    return n;
  }

  private static int emitUnderPromotions(int[] mv, int n, int from, int to, int mover) {
    int base = mv(from, to, 1, mover); // R / B / N only
    mv[n++] = base | (2 << 12); // R
    mv[n++] = base | (1 << 12); // B
    mv[n++] = base; // N
    return n;
  }

  /* ── LOOKUP helpers (runtime) ─────────────────────────────────── */
  public static long rookAtt(long occ, int sq) {
    if (USE_PEXT) return rookAttPext(sq, occ);
    return rookAttMagic(occ, sq);
  }

  public static long bishopAtt(long occ, int sq) {
    if (USE_PEXT) return bishopAttPext(sq, occ);
    return bishopAttMagic(occ, sq);
  }

  public static long queenAtt(long occ, int sq) {
    if (USE_PEXT) return queenAttPext(sq, occ);
    return queenAttMagic(occ, sq);
  }

  private static long rookAttMagic(long occ, int sq) {
    int idx = (int) (((occ & R_MASK[sq]) * R_HASH[sq]) >>> 52);
    return LOOKUP_TABLE[R_BASE[sq] + idx];
  }

  private static long bishopAttMagic(long occ, int sq) {
    int idx = (int) (((occ & B_MASK[sq]) * B_HASH[sq]) >>> 55);
    return LOOKUP_TABLE[B_BASE[sq] + idx];
  }

  private static long queenAttMagic(long occ, int sq) {
    return rookAttMagic(occ, sq) | bishopAttMagic(occ, sq);
  }

  public static long rookAttPext(int sq, long occ) {
    int base = PreCompMoveGenTables.ROOKOFFSET_PEXT[sq];
    long mask = PreCompMoveGenTables.ROOKMASK_PEXT[sq];
    int idx = (int) Long.compress(occ, mask);
    return PreCompMoveGenTables.SLIDER_PEXT[base + idx];
  }

  public static long bishopAttPext(int sq, long occ) {
    int base = PreCompMoveGenTables.BISHOPOFFSET_PEXT[sq];
    long mask = PreCompMoveGenTables.BISHOPMASK_PEXT[sq];
    int idx = (int) Long.compress(occ, mask);
    return PreCompMoveGenTables.SLIDER_PEXT[base + idx];
  }

  public static long queenAttPext(int sq, long occ) {
    return rookAttPext(sq, occ) | bishopAttPext(sq, occ);
  }

  private static int mv(int from, int to, int flags, int mover) {
    return (from << 6) | to | (flags << 14) | (mover << MOVER_SHIFT);
  }
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\MoveOrdererImpl.java" 
package core.impl;

import core.contracts.MoveOrderer;
import core.contracts.PositionFactory;

import static core.contracts.PositionFactory.META;

/**
 * A basic, reusable move orderer that sorts a move list in-place.
 * It prioritizes moves based on a simple scoring system:
 * 1. Transposition Table Move
 * 2. Queen Promotions
 * 3. Captures (using MVV-LVA)
 * 4. Other Promotions
 * 5. Quiet Moves
 */
public final class MoveOrdererImpl implements MoveOrderer {

    // --- Score Constants ---
    private static final int SCORE_TT_MOVE = 100_000;
    private static final int SCORE_QUEEN_PROMO = 90_000;
    private static final int SCORE_CAPTURE_BASE = 80_000;
    private static final int SCORE_UNDER_PROMO = 70_000;
    private static final int SCORE_KILLER = 75_000;

    // --- Piece Values for MVV-LVA & SEE ---
    private static final int[] PIECE_VALUES = {100, 320, 330, 500, 900, 10000}; // P,N,B,R,Q,K
    private static final int[][] MVV_LVA_SCORES = new int[6][6];

    // --- Scratch Buffers ---
    private final int[] moveScores = new int[256]; // Assumes max 256 moves
    private final int[][] history;

    static {
        // Pre-compute MVV-LVA scores
        for (int victim = 0; victim < 6; victim++) {
            for (int attacker = 0; attacker < 6; attacker++) {
                MVV_LVA_SCORES[victim][attacker] = PIECE_VALUES[victim] - (PIECE_VALUES[attacker] / 100);
            }
        }
    }

    public MoveOrdererImpl(int[][] history) {  // Added: constructor takes history
        this.history = history;
    }

    @Override
    public void orderMoves(long[] bb, int[] moves, int count, int ttMove, int[] killers) {
        boolean whiteToMove = PositionFactory.whiteToMove(bb[META]);

        // 1. Score every move
        for (int i = 0; i < count; i++) {
            int move = moves[i];
            if (move == ttMove) {
                moveScores[i] = SCORE_TT_MOVE;
                continue;
            }

            int moveType = (move >>> 14) & 0x3;
            int moverType = ((move >>> 16) & 0xF) % 6;
            int toSquare = move & 0x3F;
            int fromSquare = (move >>> 6) & 0x3F;

            if (moveType == 1) { // Promotion
                int promoType = (move >>> 12) & 0x3;
                moveScores[i] = (promoType == 3) ? SCORE_QUEEN_PROMO : SCORE_UNDER_PROMO;
            } else {
                int capturedPieceType = getCapturedPieceType(bb, toSquare, whiteToMove);
                if (capturedPieceType != -1) { // Capture
                    moveScores[i] = SCORE_CAPTURE_BASE + MVV_LVA_SCORES[capturedPieceType][moverType];
                } else { // Quiet move
                    int score = 0;
                    if (killers != null) {
                        if (move == killers[0]) score = SCORE_KILLER;
                        else if (move == killers[1]) score = SCORE_KILLER - 1;
                    }
                    // Added: Incorporate history score (below killers but above 0)
                    score += (history[fromSquare][toSquare] / 32);  // Scale down to avoid dominating killers; tune as needed
                    moveScores[i] = score;
                }
            }
        }

        // 2. Sort the move list in-place using insertion sort
        for (int i = 1; i < count; i++) {
            int currentMove = moves[i];
            int currentScore = moveScores[i];
            int j = i - 1;

            // Shift elements to the right until the correct spot for the current move is found
            while (j >= 0 && moveScores[j] < currentScore) {
                moves[j + 1] = moves[j];
                moveScores[j + 1] = moveScores[j];
                j--;
            }
            moves[j + 1] = currentMove;
            moveScores[j + 1] = currentScore;
        }
    }

    @Override
    public int seePrune(long[] bb, int[] moves, int count) {
        int goodMovesCount = 0;
        for (int i = 0; i < count; i++) {
            if (see(bb, moves[i]) >= 0) {
                moves[goodMovesCount++] = moves[i];
            }
        }
        return goodMovesCount;
    }

    /**
     * Calculates the Static Exchange Evaluation for a move.
     * A non-negative score means the exchange is not losing material.
     */
    private int see(long[] bb, int move) {
        int from = (move >>> 6) & 0x3F;
        int to = move & 0x3F;
        int moverType = getMoverPieceType(move);
        boolean initialStm = PositionFactory.whiteToMove(bb[META]);

        int victimType = getCapturedPieceType(bb, to, initialStm);
        if (victimType == -1) {
            if (((move >>> 14) & 0x3) == 2) victimType = 0; // En passant captures a pawn
            else return 0; // Not a capture
        }

        int[] gain = new int[32];
        int d = 0;
        gain[d] = PIECE_VALUES[victimType];

        long occ = (bb[PositionFactory.WP] | bb[PositionFactory.WN] | bb[PositionFactory.WB] | bb[PositionFactory.WR] | bb[PositionFactory.WQ] | bb[PositionFactory.WK] |
                bb[PositionFactory.BP] | bb[PositionFactory.BN] | bb[PositionFactory.BB] | bb[PositionFactory.BR] | bb[PositionFactory.BQ] | bb[PositionFactory.BK]);

        occ ^= (1L << from); // Remove the first attacker
        boolean stm = !initialStm;

        while (true) {
            d++;
            gain[d] = PIECE_VALUES[moverType] - gain[d - 1];

            long[] outAttackerBit = new long[1];
            moverType = getLeastValuableAttacker(bb, to, stm, occ, outAttackerBit);

            if (moverType == -1) break;

            occ ^= outAttackerBit[0]; // Remove the next attacker
            stm = !stm;
        }

        // Negamax unrolling of the capture sequence
        while (--d > 0) {
            gain[d - 1] = -Math.max(-gain[d - 1], gain[d]);
        }
        return gain[0];
    }

    private int getMoverPieceType(int move) {
        return ((move >>> 16) & 0xF) % 6;
    }

    /**
     * Finds the piece type of the least valuable attacker to a square.
     *
     * @param bb             The board state.
     * @param to             The target square.
     * @param stm            The side to find an attacker for.
     * @param occ            The current board occupancy.
     * @param outAttackerBit A 1-element array to store the bitboard of the found attacker.
     * @return The piece type (0-5) of the least valuable attacker, or -1 if no attacker is found.
     */
    private int getLeastValuableAttacker(long[] bb, int to, boolean stm, long occ, long[] outAttackerBit) {
        long toBB = 1L << to;
        long attackers;

        // Pawns
        if (stm) { // White attackers
            attackers = ((toBB & ~0x8080808080808080L) >>> 7 | (toBB & ~0x0101010101010101L) >>> 9) & bb[PositionFactory.WP] & occ;
        } else { // Black attackers
            attackers = ((toBB & ~0x0101010101010101L) << 7 | (toBB & ~0x8080808080808080L) << 9) & bb[PositionFactory.BP] & occ;
        }
        if (attackers != 0) {
            outAttackerBit[0] = attackers & -attackers;
            return 0;
        }

        // Knights
        attackers = PreCompMoveGenTables.KNIGHT_ATK[to] & bb[stm ? PositionFactory.WN : PositionFactory.BN] & occ;
        if (attackers != 0) {
            outAttackerBit[0] = attackers & -attackers;
            return 1;
        }

        // Bishops
        attackers = MoveGeneratorImpl.bishopAtt(occ, to) & bb[stm ? PositionFactory.WB : PositionFactory.BB] & occ;
        if (attackers != 0) {
            outAttackerBit[0] = attackers & -attackers;
            return 2;
        }

        // Rooks
        attackers = MoveGeneratorImpl.rookAtt(occ, to) & bb[stm ? PositionFactory.WR : PositionFactory.BR] & occ;
        if (attackers != 0) {
            outAttackerBit[0] = attackers & -attackers;
            return 3;
        }

        // Queens
        attackers = MoveGeneratorImpl.queenAtt(occ, to) & bb[stm ? PositionFactory.WQ : PositionFactory.BQ] & occ;
        if (attackers != 0) {
            outAttackerBit[0] = attackers & -attackers;
            return 4;
        }

        // King
        attackers = PreCompMoveGenTables.KING_ATK[to] & bb[stm ? PositionFactory.WK : PositionFactory.BK] & occ;
        if (attackers != 0) {
            outAttackerBit[0] = attackers & -attackers;
            return 5;
        }

        outAttackerBit[0] = 0L;
        return -1;
    }

    /**
     * Determines the type of piece on a given square.
     * @return The piece type (0-5 for P,N,B,R,Q,K), or -1 if the square is empty.
     */
    private int getCapturedPieceType(long[] bb, int toSquare, boolean whiteToMove) {
        long toBit = 1L << toSquare;
        int start = whiteToMove ? PositionFactory.BP : PositionFactory.WP;
        int end = whiteToMove ? PositionFactory.BK : PositionFactory.WK;

        for (int pieceType = start; pieceType <= end; pieceType++) {
            if ((bb[pieceType] & toBit) != 0) {
                return pieceType % 6; // Return 0-5
            }
        }
        return -1; // Not a capture
    }
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\PositionFactoryImpl.java" 
package core.impl;

import static core.contracts.PositionFactory.*;
import static core.impl.MoveGeneratorImpl.FILE_A;
import static core.impl.MoveGeneratorImpl.FILE_H;

import core.contracts.*;
import java.util.Random;

public final class PositionFactoryImpl implements PositionFactory {
  /* piece indices (mirror interface) */
  private static final int WP = 0,
          WN = 1,
          WB = 2,
          WR = 3,
          WQ = 4,
          WK = 5,
          BP = 6,
          BN = 7,
          BB = 8,
          BR = 9,
          BQ = 10,
          BK = 11,
          META = 12;

  /* ───────── Zobrist tables ───────── */
  public static final long[][] PIECE_SQUARE = new long[12][64];
  public static final long[]   CASTLING     = new long[16];
  public static final long[]   EP_FILE      = new long[8]; // One for each file
  public static final long     SIDE_TO_MOVE;
  private static final long[] ZOBRIST_50MR = new long[120]; // 0‥119 half-moves

  /* META layout (duplicated locally for speed) */
  private static final long STM_MASK = 1L;
  private static final int CR_SHIFT = 1;
  private static final long CR_MASK = 0b1111L << CR_SHIFT;
  private static final int EP_SHIFT = 5;
  private static final long EP_MASK = 0x3FL << EP_SHIFT;
  private static final int HC_SHIFT = 11;
  private static final long HC_MASK = 0x7FL << HC_SHIFT;
  private static final int FM_SHIFT = 18;
  private static final long FM_MASK = 0x1FFL << FM_SHIFT;

  /* Precomputed masks for castling rights updates */
  private static final short[] CR_MASK_LOST_FROM = new short[64];
  private static final short[] CR_MASK_LOST_TO   = new short[64];
  private static final int CR_BITS = (int) CR_MASK;
  private static final int EP_BITS = (int) EP_MASK;
  private static final int HC_BITS = (int) HC_MASK;

  static {
    java.util.Arrays.fill(CR_MASK_LOST_FROM, (short) 0b1111);
    java.util.Arrays.fill(CR_MASK_LOST_TO,   (short) 0b1111);

    CR_MASK_LOST_FROM[ 4]  = 0b1100; // e1  white king
    CR_MASK_LOST_FROM[60]  = 0b0011; // e8  black king
    CR_MASK_LOST_FROM[ 7] &= ~0b0001; // h1  → clear white-K
    CR_MASK_LOST_FROM[ 0] &= ~0b0010; // a1  → clear white-Q
    CR_MASK_LOST_FROM[63] &= ~0b0100; // h8  → clear black-k
    CR_MASK_LOST_FROM[56] &= ~0b1000; // a8  → clear black-q
    CR_MASK_LOST_TO[ 7]  &= ~0b0001;
    CR_MASK_LOST_TO[ 0]  &= ~0b0010;
    CR_MASK_LOST_TO[63]  &= ~0b0100;
    CR_MASK_LOST_TO[56]  &= ~0b1000;

    Random rnd = new Random(0xCAFEBABE);
    for (int p = 0; p < 12; ++p)
      for (int sq = 0; sq < 64; ++sq)
        PIECE_SQUARE[p][sq] = rnd.nextLong();

    final int CR_W_K = 1, CR_W_Q = 2, CR_B_K = 4, CR_B_Q = 8;
    CASTLING[0] = 0L;
    CASTLING[CR_W_K] = rnd.nextLong();
    CASTLING[CR_W_Q] = rnd.nextLong();
    CASTLING[CR_B_K] = rnd.nextLong();
    CASTLING[CR_B_Q] = rnd.nextLong();

    for (int i = 1; i < 16; i++) {
      if (Integer.bitCount(i) < 2) continue;
      long combinedKey = 0L;
      if ((i & CR_W_K) != 0) combinedKey ^= CASTLING[CR_W_K];
      if ((i & CR_W_Q) != 0) combinedKey ^= CASTLING[CR_W_Q];
      if ((i & CR_B_K) != 0) combinedKey ^= CASTLING[CR_B_K];
      if ((i & CR_B_Q) != 0) combinedKey ^= CASTLING[CR_B_Q];
      CASTLING[i] = combinedKey;
    }

    for (int f = 0; f < 8; ++f) EP_FILE[f] = rnd.nextLong();
    SIDE_TO_MOVE = rnd.nextLong();
    for (int i = 0; i < ZOBRIST_50MR.length; ++i)
      ZOBRIST_50MR[i] = rnd.nextLong();
  }

  @Override
  public long zobrist50(long[] bb) {
    long key = bb[HASH];
    int hc   = (int) ((bb[META] & HC_MASK) >>> HC_SHIFT); // 0‥119, clamped by makeMove()
    return key ^ ZOBRIST_50MR[hc];
  }

  @Override
  public long[] fromFen(String fen) {
    long[] bb = fenToBitboards(fen);
    bb[COOKIE_SP] = 0;
    bb[DIFF_META] = bb[META];
    bb[DIFF_INFO] = 0;
    bb[HASH] = fullHash(bb);
    return bb;
  }

  @Override
  public String toFen(long[] bb)
  {
    StringBuilder sb = new StringBuilder(64);
    for (int rank = 7; rank >= 0; --rank) {
      int empty = 0;
      for (int file = 0; file < 8; ++file) {
        int sq = rank * 8 + file;
        char pc = pieceCharAt(bb, sq);
        if (pc == 0) {
          empty++;
          continue;
        }
        if (empty != 0) {
          sb.append(empty);
          empty = 0;
        }
        sb.append(pc);
      }
      if (empty != 0) sb.append(empty);
      if (rank != 0) sb.append('/');
    }
    sb.append(whiteToMove(bb) ? " w " : " b ");

    int cr = castlingRights(bb);
    sb.append(cr == 0 ? "-" : "")
            .append((cr & 1) != 0 ? "K" : "")
            .append((cr & 2) != 0 ? "Q" : "")
            .append((cr & 4) != 0 ? "k" : "")
            .append((cr & 8) != 0 ? "q" : "");
    sb.append(' ');

    int ep = enPassantSquare(bb);
    if (ep != -1) {
      sb.append((char) ('a' + (ep & 7))).append(1 + (ep >>> 3));
    } else {
      sb.append('-');
    }

    sb.append(' ');
    sb.append(halfmoveClock(bb)).append(' ').append(fullmoveNumber(bb));
    return sb.toString();
  }

  @Override
  public long zobrist(long[] bb)
  {
    return bb[HASH];
  }

  private char pieceCharAt(long bb[], int sq) {
    for (int i = 0; i < 12; ++i) if ((bb[i] & (1L << sq)) != 0) return "PNBRQKpnbrqk".charAt(i);
    return 0;
  }

  private boolean whiteToMove(long[] bb) {
    return (bb[META] & STM_MASK) == 0;
  }

  private int halfmoveClock(long[] bb) {
    return (int) ((bb[META] & HC_MASK) >>> HC_SHIFT);
  }

  private int fullmoveNumber(long[] bb) {
    return 1 + (int) ((bb[META] & FM_MASK) >>> FM_SHIFT);
  }

  private int castlingRights(long[] bb) {
    return (int) ((bb[META] & CR_MASK) >>> CR_SHIFT);
  }

  private int enPassantSquare(long[] bb) {
    int e = (int) ((bb[META] & EP_MASK) >>> EP_SHIFT);
    return e == EP_NONE ? -1 : e;
  }

  @Override
  public boolean makeMoveInPlace(long[] bb, int mv, MoveGenerator gen) {
    int from  = (mv >>>  6) & 0x3F;
    int to    =  mv         & 0x3F;
    int type  = (mv >>> 14) & 0x3;
    int promo = (mv >>> 12) & 0x3;
    int mover = (mv >>> 16) & 0xF;

    boolean white   = mover < 6;
    long    fromBit = 1L << from;
    long    toBit   = 1L << to;

    if (type == 3 && !gen.castleLegal(bb, from, to))
      return false;

    long h        = bb[HASH];
    long oldHash  = h;
    int  metaOld  = (int) bb[META];
    int  oldCR    = (metaOld & CR_BITS) >>> CR_SHIFT;
    int  oldEP    = (metaOld & EP_BITS) >>> EP_SHIFT;

    int sp = (int) bb[COOKIE_SP];
    bb[COOKIE_BASE + sp] =
            (bb[DIFF_META] & 0xFFFF_FFFFL) << 32 |
                    (bb[DIFF_INFO] & 0xFFFF_FFFFL);
    bb[COOKIE_SP] = sp + 1;

    int captured = 15;
    if (type <= 1) {
      long enemy = white
              ? (bb[BP]|bb[BN]|bb[BB]|bb[BR]|bb[BQ]|bb[BK])
              : (bb[WP]|bb[WN]|bb[WB]|bb[WR]|bb[WQ]|bb[WK]);
      if ((enemy & toBit) != 0) {
        captured = (bb[white?BP:WP] & toBit)!=0 ? (white?BP:WP) :
                (bb[white?BN:WN] & toBit)!=0 ? (white?BN:WN) :
                        (bb[white?BB:WB] & toBit)!=0 ? (white?BB:WB) :
                                (bb[white?BR:WR] & toBit)!=0 ? (white?BR:WR) :
                                        (bb[white?BQ:WQ] & toBit)!=0 ? (white?BQ:WQ) :
                                                (white?BK:WK);
        bb[captured] &= ~toBit;
        h ^= PIECE_SQUARE[captured][to];
      }
    } else if (type == 2) {
      int capSq   = white ? to - 8 : to + 8;
      captured    = white ? BP : WP;
      bb[captured] &= ~(1L << capSq);
      h ^= PIECE_SQUARE[captured][capSq];
    }

    bb[mover] ^= fromBit;
    h ^= PIECE_SQUARE[mover][from];

    if (type == 1) {
      int promIdx = (white ? WN : BN) + promo;
      bb[promIdx] |= toBit;
      h ^= PIECE_SQUARE[promIdx][to];
    } else {
      bb[mover]   |= toBit;
      h ^= PIECE_SQUARE[mover][to];
    }

    if (type == 3) switch (to) {
      case  6 -> { bb[WR] ^= (1L<<7)|(1L<<5); h ^= PIECE_SQUARE[WR][7] ^ PIECE_SQUARE[WR][5]; }
      case  2 -> { bb[WR] ^= (1L<<0)|(1L<<3); h ^= PIECE_SQUARE[WR][0] ^ PIECE_SQUARE[WR][3]; }
      case 62 -> { bb[BR] ^= (1L<<63)|(1L<<61);h ^= PIECE_SQUARE[BR][63] ^ PIECE_SQUARE[BR][61];}
      case 58 -> { bb[BR] ^= (1L<<56)|(1L<<59);h ^= PIECE_SQUARE[BR][56] ^ PIECE_SQUARE[BR][59];}
    }

    int meta = metaOld;
    int ep = (int) EP_NONE;
    if ((mover == WP || mover == BP) && ((from ^ to) == 16))
      ep = white ? from + 8 : from - 8;

    if (ep != oldEP) {
      meta = (meta & ~EP_BITS) | (ep << EP_SHIFT);
      if (oldEP != EP_NONE) h ^= EP_FILE[oldEP & 7];
      if (ep != EP_NONE)    h ^= EP_FILE[ep & 7];
    }

    int cr = oldCR & CR_MASK_LOST_FROM[from] & CR_MASK_LOST_TO[to];
    if (cr != oldCR) {
      meta = (meta & ~CR_BITS) | (cr << CR_SHIFT);
      h ^= CASTLING[oldCR] ^ CASTLING[cr];
    }

    int newHC = ((mover == WP || mover == BP) || captured != 15)
            ? 0
            : ((metaOld & HC_BITS) >>> HC_SHIFT) + 1;
    meta = (meta & ~HC_BITS) | (newHC << HC_SHIFT);

    int fm = (meta >>> FM_SHIFT) & 0x1FF;
    if (!white) fm++;
    meta ^= STM_MASK;
    meta = (meta & ~((int)FM_MASK)) | (fm << FM_SHIFT);
    h ^= SIDE_TO_MOVE;

    bb[DIFF_INFO] = (int) packDiff(from, to, captured, mover, type, promo);
    bb[DIFF_META] = (int) (bb[META] ^ meta);
    bb[META]      = meta;
    bb[HASH]      = h;

    if (gen.kingAttacked(bb, white)) {
      bb[HASH] = oldHash;
      fastUndo(bb);
      bb[COOKIE_SP] = sp;
      long prev = bb[COOKIE_BASE + sp];
      bb[DIFF_INFO] = (int)  prev;
      bb[DIFF_META] = (int) (prev >>> 32);
      return false;
    }
    return true;
  }

  @Override
  public void undoMoveInPlace(long[] bb) {
    long diff   = bb[DIFF_INFO];
    long metaΔ  = bb[DIFF_META];

    long h          = bb[HASH];
    int  metaAfter  = (int) bb[META];
    int  crAfter    = (metaAfter & CR_BITS) >>> CR_SHIFT;
    int  epAfter    = (metaAfter & EP_BITS) >>> EP_SHIFT;

    bb[META] ^= metaΔ;
    int metaBefore = (int) bb[META];
    int crBefore   = (metaBefore & CR_BITS) >>> CR_SHIFT;
    int epBefore   = (metaBefore & EP_BITS) >>> EP_SHIFT;

    h ^= SIDE_TO_MOVE;
    if (crAfter != crBefore) h ^= CASTLING[crAfter] ^ CASTLING[crBefore];

    int from   = dfFrom(diff);
    int to     = dfTo(diff);
    int capIdx = dfCap(diff);
    int mover  = dfMover(diff);
    int type   = dfType(diff);
    int promo  = dfPromo(diff);

    long fromBit = 1L << from;
    long toBit   = 1L << to;

    if (type == 1) {
      int promIdx = (mover < 6 ? WN : BN) + promo;
      bb[promIdx] ^= toBit;
      bb[mover]   |= fromBit;
      h ^= PIECE_SQUARE[promIdx][to] ^ PIECE_SQUARE[mover][from];
    } else {
      bb[mover] ^= fromBit | toBit;
      h ^= PIECE_SQUARE[mover][to] ^ PIECE_SQUARE[mover][from];
    }

    if (type == 3) switch (to) {
      case  6 -> { bb[WR] ^= (1L<<7)|(1L<<5); h ^= PIECE_SQUARE[WR][7] ^ PIECE_SQUARE[WR][5]; }
      case  2 -> { bb[WR] ^= (1L<<0)|(1L<<3); h ^= PIECE_SQUARE[WR][0] ^ PIECE_SQUARE[WR][3]; }
      case 62 -> { bb[BR] ^= (1L<<63)|(1L<<61);h ^= PIECE_SQUARE[BR][63] ^ PIECE_SQUARE[BR][61];}
      case 58 -> { bb[BR] ^= (1L<<56)|(1L<<59);h ^= PIECE_SQUARE[BR][56] ^ PIECE_SQUARE[BR][59];}
    }

    if (capIdx != 15) {
      int capSq = (type == 2) ? ((mover < 6) ? to - 8 : to + 8) : to;
      bb[capIdx] |= 1L << capSq;
      h ^= PIECE_SQUARE[capIdx][capSq];
    }

    int sp = (int) bb[COOKIE_SP] - 1;
    long ck = bb[COOKIE_BASE + sp];
    bb[COOKIE_SP] = sp;
    bb[DIFF_INFO] = (int)  ck;
    bb[DIFF_META] = (int) (ck >>> 32);

    if (epAfter != epBefore) {
      if (epAfter != EP_NONE)  h ^= EP_FILE[epAfter & 7];
      if (epBefore != EP_NONE) h ^= EP_FILE[epBefore & 7];
    }

    bb[HASH] = h;
  }

  public boolean hasNonPawnMaterial(long[] bb) {
    boolean whiteToMove = PositionFactory.whiteToMove(bb[META]);
    if (whiteToMove) {
      return (bb[PositionFactory.WN] | bb[PositionFactory.WB] | bb[PositionFactory.WR] | bb[PositionFactory.WQ]) != 0;
    } else {
      return (bb[PositionFactory.BN] | bb[PositionFactory.BB] | bb[PositionFactory.BR] | bb[PositionFactory.BQ]) != 0;
    }
  }

  private static void fastUndo(long[] bb) {
    long diff  = bb[DIFF_INFO];
    long metaΔ = bb[DIFF_META];
    bb[META]  ^= metaΔ;

    int from   = dfFrom(diff);
    int to     = dfTo(diff);
    int capIdx = dfCap(diff);
    int mover  = dfMover(diff);
    int type   = dfType(diff);
    int promo  = dfPromo(diff);

    long fromBit = 1L << from;
    long toBit   = 1L << to;

    if (type == 1) {
      bb[(mover < 6 ? WN : BN) + promo] ^= toBit;
      bb[(mover < 6) ? WP : BP]        |= fromBit;
    } else {
      bb[mover] ^= fromBit | toBit;
    }

    if (type == 3) switch (to) {
      case  6 -> bb[WR] ^= (1L<<7)  | (1L<<5);
      case  2 -> bb[WR] ^= (1L<<0)  | (1L<<3);
      case 62 -> bb[BR] ^= (1L<<63) | (1L<<61);
      case 58 -> bb[BR] ^= (1L<<56) | (1L<<59);
    }

    if (capIdx != 15) {
      long capMask = (type == 2) ? 1L << ((mover < 6) ? to - 8 : to + 8) : toBit;
      bb[capIdx] |= capMask;
    }
  }

  private static long[] fenToBitboards(String fen) {
    long[] bb = new long[BB_LEN];
    String[] parts = fen.trim().split("\\s+");
    String board = parts[0];
    int rank = 7, file = 0;
    for (char c : board.toCharArray()) {
      if (c == '/') {
        rank--;
        file = 0;
        continue;
      }
      if (Character.isDigit(c)) {
        file += c - '0';
        continue;
      }
      int sq = rank * 8 + file++;
      int idx =
              switch (c) {
                case 'P' -> WP; case 'N' -> WN; case 'B' -> WB; case 'R' -> WR; case 'Q' -> WQ; case 'K' -> WK;
                case 'p' -> BP; case 'n' -> BN; case 'b' -> BB; case 'r' -> BR; case 'q' -> BQ; case 'k' -> BK;
                default -> throw new IllegalArgumentException("bad fen piece: " + c);
              };
      bb[idx] |= 1L << sq;
    }
    long meta = parts[1].equals("b") ? 1L : 0L;
    int cr = 0;
    if (parts[2].indexOf('K') >= 0) cr |= 0b0001;
    if (parts[2].indexOf('Q') >= 0) cr |= 0b0010;
    if (parts[2].indexOf('k') >= 0) cr |= 0b0100;
    if (parts[2].indexOf('q') >= 0) cr |= 0b1000;
    meta |= (long) cr << CR_SHIFT;

    int epSq = (int) EP_NONE;
    if (!parts[3].equals("-")) {
      int f = parts[3].charAt(0) - 'a';
      int r = parts[3].charAt(1) - '1';
      epSq = r * 8 + f;
    }
    meta |= (long) epSq << EP_SHIFT;

    int hc = (parts.length > 4) ? Integer.parseInt(parts[4]) : 0;
    int fm = (parts.length > 5) ? Integer.parseInt(parts[5]) - 1 : 0;
    meta |= (long) hc << HC_SHIFT;
    meta |= (long) fm << FM_SHIFT;

    bb[META] = meta;
    return bb;
  }

  public long fullHash(long[] bb) {
    long k = 0;
    for (int pc = WP; pc <= BK; ++pc) {
      long bits = bb[pc];
      while (bits != 0) {
        int sq = Long.numberOfTrailingZeros(bits);
        k ^= PIECE_SQUARE[pc][sq];
        bits &= bits - 1;
      }
    }

    if ((bb[META] & STM_MASK) != 0)
      k ^= SIDE_TO_MOVE;

    int cr = (int) ((bb[META] & CR_MASK) >>> CR_SHIFT);
    k ^= CASTLING[cr];

    int ep = (int) ((bb[META] & EP_MASK) >>> EP_SHIFT);
    if (ep != EP_NONE)
      k ^= EP_FILE[ep & 7];

    return k;
  }

  private static long packDiff(int from, int to, int cap, int mover, int typ, int pro) {
    return (from) | ((long) to << 6) | ((long) cap << 12) | ((long) mover << 16) | ((long) typ << 20) | ((long) pro << 22);
  }

  private static int dfFrom(long d) { return (int) (d & 0x3F); }
  private static int dfTo(long d) { return (int) ((d >>> 6) & 0x3F); }
  private static int dfCap(long d) { return (int) ((d >>> 12) & 0x0F); }
  private static int dfMover(long d) { return (int) ((d >>> 16) & 0x0F); }
  private static int dfType(long d) { return (int) ((d >>> 20) & 0x03); }
  private static int dfPromo(long d) { return (int) ((d >>> 22) & 0x03); }
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\PreCompMoveGenTables.java" 
package core.impl;

import java.util.Locale;

public final class PreCompMoveGenTables {
  private PreCompMoveGenTables() {}

  public static final long[] ROOKMASK_PEXT = {
    0x000101010101017EL, 0x000202020202027CL, 0x000404040404047AL, 0x0008080808080876L,
    0x001010101010106EL, 0x002020202020205EL, 0x004040404040403EL, 0x008080808080807EL,
    0x0001010101017E00L, 0x0002020202027C00L, 0x0004040404047A00L, 0x0008080808087600L,
    0x0010101010106E00L, 0x0020202020205E00L, 0x0040404040403E00L, 0x0080808080807E00L,
    0x00010101017E0100L, 0x00020202027C0200L, 0x00040404047A0400L, 0x0008080808760800L,
    0x00101010106E1000L, 0x00202020205E2000L, 0x00404040403E4000L, 0x00808080807E8000L,
    0x000101017E010100L, 0x000202027C020200L, 0x000404047A040400L, 0x0008080876080800L,
    0x001010106E101000L, 0x002020205E202000L, 0x004040403E404000L, 0x008080807E808000L,
    0x0001017E01010100L, 0x0002027C02020200L, 0x0004047A04040400L, 0x0008087608080800L,
    0x0010106E10101000L, 0x0020205E20202000L, 0x0040403E40404000L, 0x0080807E80808000L,
    0x00017E0101010100L, 0x00027C0202020200L, 0x00047A0404040400L, 0x0008760808080800L,
    0x00106E1010101000L, 0x00205E2020202000L, 0x00403E4040404000L, 0x00807E8080808000L,
    0x007E010101010100L, 0x007C020202020200L, 0x007A040404040400L, 0x0076080808080800L,
    0x006E101010101000L, 0x005E202020202000L, 0x003E404040404000L, 0x007E808080808000L,
    0x7E01010101010100L, 0x7C02020202020200L, 0x7A04040404040400L, 0x7608080808080800L,
    0x6E10101010101000L, 0x5E20202020202000L, 0x3E40404040404000L, 0x7E80808080808000L,
  };

  public static final long[] BISHOPMASK_PEXT = {
    0x0040201008040200L, 0x0000402010080400L, 0x0000004020100A00L, 0x0000000040221400L,
    0x0000000002442800L, 0x0000000204085000L, 0x0000020408102000L, 0x0002040810204000L,
    0x0020100804020000L, 0x0040201008040000L, 0x00004020100A0000L, 0x0000004022140000L,
    0x0000000244280000L, 0x0000020408500000L, 0x0002040810200000L, 0x0004081020400000L,
    0x0010080402000200L, 0x0020100804000400L, 0x004020100A000A00L, 0x0000402214001400L,
    0x0000024428002800L, 0x0002040850005000L, 0x0004081020002000L, 0x0008102040004000L,
    0x0008040200020400L, 0x0010080400040800L, 0x0020100A000A1000L, 0x0040221400142200L,
    0x0002442800284400L, 0x0004085000500800L, 0x0008102000201000L, 0x0010204000402000L,
    0x0004020002040800L, 0x0008040004081000L, 0x00100A000A102000L, 0x0022140014224000L,
    0x0044280028440200L, 0x0008500050080400L, 0x0010200020100800L, 0x0020400040201000L,
    0x0002000204081000L, 0x0004000408102000L, 0x000A000A10204000L, 0x0014001422400000L,
    0x0028002844020000L, 0x0050005008040200L, 0x0020002010080400L, 0x0040004020100800L,
    0x0000020408102000L, 0x0000040810204000L, 0x00000A1020400000L, 0x0000142240000000L,
    0x0000284402000000L, 0x0000500804020000L, 0x0000201008040200L, 0x0000402010080400L,
    0x0002040810204000L, 0x0004081020400000L, 0x000A102040000000L, 0x0014224000000000L,
    0x0028440200000000L, 0x0050080402000000L, 0x0020100804020000L, 0x0040201008040200L,
  };

  public static final int[] ROOKOFFSET_PEXT = {
    0, 4160, 6240, 8320,
    10400, 12480, 14560, 16640,
    20800, 22880, 23936, 24992,
    26048, 27104, 28160, 29216,
    31296, 33376, 34432, 35584,
    36736, 37888, 39040, 40096,
    42176, 44256, 45312, 46464,
    48000, 49536, 50688, 51744,
    53824, 55904, 56960, 58112,
    59648, 61184, 62336, 63392,
    65472, 67552, 68608, 69760,
    70912, 72064, 73216, 74272,
    76352, 78432, 79488, 80544,
    81600, 82656, 83712, 84768,
    86848, 91008, 93088, 95168,
    97248, 99328, 101408, 103488,
  };

  public static final int[] BISHOPOFFSET_PEXT = {
    4096, 6208, 8288, 10368,
    12448, 14528, 16608, 20736,
    22848, 23904, 24960, 26016,
    27072, 28128, 29184, 31264,
    33344, 34400, 35456, 36608,
    37760, 38912, 40064, 42144,
    44224, 45280, 46336, 47488,
    49024, 50560, 51712, 53792,
    55872, 56928, 57984, 59136,
    60672, 62208, 63360, 65440,
    67520, 68576, 69632, 70784,
    71936, 73088, 74240, 76320,
    78400, 79456, 80512, 81568,
    82624, 83680, 84736, 86816,
    90944, 93056, 95136, 97216,
    99296, 101376, 103456, 107584,
  };

  /** flattened triples: offset, mask, hash */
  public static final long[] B_MAGICS = {
    66157L,
    0xFFBFDFEFF7FBFDFFL,
    1187473109101317119L,
    71730L,
    0xFFFFBFDFEFF7FBFFL,
    9223336714375004157L,
    37781L,
    0xFFFFFFBFDFEFF5FFL,
    288441550701068800L,
    21015L,
    0xFFFFFFFFBFDDEBFFL,
    1170795303134035968L,
    47590L,
    0xFFFFFFFFFDBBD7FFL,
    0xC03FE00100000000L,
    835L,
    0xFFFFFFFDFBF7AFFFL,
    2648129775020802048L,
    23592L,
    0xFFFFFDFBF7EFDFFFL,
    578730278520913668L,
    30599L,
    0xFFFDFBF7EFDFBFFFL,
    1155182238468407424L,
    68776L,
    0xFFDFEFF7FBFDFFFFL,
    0xFFA2FEFFBFEFB7FFL,
    19959L,
    0xFFBFDFEFF7FBFFFFL,
    593981333727348737L,
    21783L,
    0xFFFFBFDFEFF5FFFFL,
    288653413114708096L,
    64836L,
    0xFFFFFFBFDDEBFFFFL,
    306245323880337408L,
    23417L,
    0xFFFFFFFDBBD7FFFFL,
    2310347158529769472L,
    66724L,
    0xFFFFFDFBF7AFFFFFL,
    1187261314343337984L,
    74542L,
    0xFFFDFBF7EFDFFFFFL,
    9188469001234153344L,
    67266L,
    0xFFFBF7EFDFBFFFFFL,
    578171627018125376L,
    26575L,
    0xFFEFF7FBFDFFFDFFL,
    9222949822267379705L,
    67543L,
    0xFFDFEFF7FBFFFBFFL,
    9223020191524333565L,
    24409L,
    0xFFBFDFEFF5FFF5FFL,
    2306265224900983809L,
    30779L,
    0xFFFFBFDDEBFFEBFFL,
    4647151869788945290L,
    17384L,
    0xFFFFFDBBD7FFD7FFL,
    2314815028390789136L,
    18778L,
    0xFFFDFBF7AFFFAFFFL,
    0xFFDFEFFFDE39FFEFL,
    65109L,
    0xFFFBF7EFDFFFDFFFL,
    9223363241302802431L,
    20184L,
    0xFFF7EFDFBFFFBFFFL,
    9221115838862475263L,
    38240L,
    0xFFF7FBFDFFFDFBFFL,
    1090988818544L,
    16459L,
    0xFFEFF7FBFFFBF7FFL,
    9223230887045427193L,
    17432L,
    0xFFDFEFF5FFF5EFFFL,
    9223090009958119421L,
    81040L,
    0xFFBFDDEBFFEBDDFFL,
    4570867472252272639L,
    84946L,
    0xFFFDBBD7FFD7BBFFL,
    292734589976199165L,
    18276L,
    0xFFFBF7AFFFAFF7FFL,
    2305878434105819152L,
    8512L,
    0xFFF7EFDFFFDFEFFFL,
    612472197655543809L,
    78544L,
    0xFFEFDFBFFFBFDFFFL,
    2265045493362695L,
    19974L,
    0xFFFBFDFFFDFBF7FFL,
    553992241216L,
    23850L,
    0xFFF7FBFFFBF7EFFFL,
    276996120608L,
    11056L,
    0xFFEFF5FFF5EFDFFFL,
    27023813833162784L,
    68019L,
    0xFFDDEBFFEBDDBFFFL,
    0xD003FEFE04404080L,
    85965L,
    0xFFBBD7FFD7BBFDFFL,
    1152957239137415242L,
    80524L,
    0xFFF7AFFFAFF7FBFFL,
    9205355920559695872L,
    38221L,
    0xFFEFDFFFDFEFF7FFL,
    1188932777689485200L,
    64647L,
    0xFFDFBFFFBFDFEFFFL,
    9191846633066727416L,
    61320L,
    0xFFFDFFFDFBF7EFFFL,
    279189160064L,
    67281L,
    0xFFFBFFFBF7EFDFFFL,
    139594580032L,
    79076L,
    0xFFF5FFF5EFDFBFFFL,
    279198499008L,
    17115L,
    0xFFEBFFEBDDBFFFFFL,
    4503601791385728L,
    50718L,
    0xFFD7FFD7BBFDFFFFL,
    1152921764453941296L,
    24659L,
    0xFFAFFFAFF7FBFDFFL,
    2307531983360360472L,
    38291L,
    0xFFDFFFDFEFF7FBFFL,
    0xFFFFFFBFEFF80FDCL,
    30605L,
    0xFFBFFFBFDFEFF7FFL,
    68988172306L,
    37759L,
    0xFFFFFDFBF7EFDFFFL,
    576460886529573376L,
    4639L,
    0xFFFFFBF7EFDFBFFFL,
    594475220056658440L,
    21759L,
    0xFFFFF5EFDFBFFFFFL,
    576460752563503233L,
    67799L,
    0xFFFFEBDDBFFFFFFFL,
    1125900041076608L,
    22841L,
    0xFFFFD7BBFDFFFFFFL,
    576460756600479808L,
    66689L,
    0xFFFFAFF7FBFDFFFFL,
    603338863802321408L,
    62548L,
    0xFFFFDFEFF7FBFDFFL,
    0xFFFFFEFFBFEFF81DL,
    66597L,
    0xFFFFBFDFEFF7FBFFL,
    0xFFBFFFEFEFDFF70FL,
    86749L,
    0xFFFDFBF7EFDFBFFFL,
    1152921573842288770L,
    69558L,
    0xFFFBF7EFDFBFFFFFL,
    9203950263191257135L,
    61589L,
    0xFFF5EFDFBFFFFFFFL,
    9188469139741638527L,
    62533L,
    0xFFEBDDBFFFFFFFFFL,
    0xFFF1FFFFFFF7FFC1L,
    64387L,
    0xFFD7BBFDFFFFFFFFL,
    610242147571982367L,
    26581L,
    0xFFAFF7FBFDFFFFFFL,
    26177172852973578L,
    76355L,
    0xFFDFEFF7FBFDFFFFL,
    594615890450845658L,
    11140L,
    0xFFBFDFEFF7FBFDFFL,
    1152922330840178696L
  };

  /** flattened triples: offset, mask, hash */
  public static final long[] R_MAGICS = {
    10890L,
    0xFFFEFEFEFEFEFE81L,
    0x80280013FF84FFFFL,
    56054L,
    0xFFFDFDFDFDFDFD83L,
    6916402019615277055L,
    67495L,
    0xFFFBFBFBFBFBFB85L,
    0xFFEFFAFFEFFDFFFFL,
    72797L,
    0xFFF7F7F7F7F7F789L,
    13511417407733898L,
    17179L,
    0xFFEFEFEFEFEFEF91L,
    13512448205127728L,
    63978L,
    0xFFDFDFDFDFDFDFA1L,
    9008441047646240L,
    56650L,
    0xFFBFBFBFBFBFBFC1L,
    13511211211554864L,
    15929L,
    0xFF7F7F7F7F7F7F81L,
    0xFFA8008DFF09FFF8L,
    55905L,
    0xFFFEFEFEFEFE81FFL,
    9205348825003917308L,
    26301L,
    0xFFFDFDFDFDFD83FFL,
    21992397144066L,
    78100L,
    0xFFFBFBFBFBFB85FFL,
    26389411528776L,
    86245L,
    0xFFF7F7F7F7F789FFL,
    9223345648611360696L,
    75228L,
    0xFFEFEFEFEFEF91FFL,
    0xFFFFCFFE7FCFFFAFL,
    31661L,
    0xFFDFDFDFDFDFA1FFL,
    26391501865056L,
    38053L,
    0xFFBFBFBFBFBFC1FFL,
    0xFFFFE7FF8FBFFFE8L,
    37433L,
    0xFF7F7F7F7F7F81FFL,
    26389090795544L,
    74747L,
    0xFFFEFEFEFE81FEFFL,
    13510901978890243L,
    53847L,
    0xFFFDFDFDFD83FDFFL,
    844476478521343L,
    70952L,
    0xFFFBFBFBFB85FBFFL,
    0xFFFDFFF7FBFEFFF7L,
    49447L,
    0xFFF7F7F7F789F7FFL,
    9205920450792660991L,
    62629L,
    0xFFEFEFEFEF91EFFFL,
    0xFFFEFFDFFDFFDFFFL,
    58996L,
    0xFFDFDFDFDFA1DFFFL,
    8939786031088007199L,
    36009L,
    0xFFBFBFBFBFC1BFFFL,
    2323998178495432720L,
    21230L,
    0xFF7F7F7F7F817FFFL,
    288371136597606656L,
    51882L,
    0xFFFEFEFE81FEFEFFL,
    18049583150530568L,
    11841L,
    0xFFFDFDFD83FDFDFFL,
    4505798785105924L,
    25794L,
    0xFFFBFBFB85FBFBFFL,
    0xFFFDFEFFF7FBFFF7L,
    49689L,
    0xFFF7F7F789F7F7FFL,
    0xFEBF7DFFF8FEFFF9L,
    63400L,
    0xFFEFEFEF91EFEFFFL,
    0xC00000FFE001FFE0L,
    33958L,
    0xFFDFDFDFA1DFDFFFL,
    2308130543272738823L,
    21991L,
    0xFFBFBFBFC1BFBFFFL,
    0xBFFBFAFFFB683F7FL,
    45618L,
    0xFF7F7F7F817F7FFFL,
    578702106657038400L,
    70134L,
    0xFFFEFE81FEFEFEFFL,
    2305852801742274608L,
    75944L,
    0xFFFDFD83FDFDFDFFL,
    581969641496L,
    68392L,
    0xFFFBFB85FBFBFBFFL,
    1112398102552L,
    66472L,
    0xFFF7F789F7F7F7FFL,
    4611686574627225624L,
    23236L,
    0xFFEFEF91EFEFEFFFL,
    36169744961110010L,
    19067L,
    0xFFDFDFA1DFDFDFFFL,
    4611712960757628934L,
    0L,
    0xFFBFBFC1BFBFBFFFL,
    0xFFFFFF7FFFBFBFFFL,
    43566L,
    0xFF7F7F817F7F7FFFL,
    140874929406016L,
    29810L,
    0xFFFE81FEFEFEFEFFL,
    2305845220786317312L,
    65558L,
    0xFFFD83FDFDFDFDFFL,
    0xFFFFF9FF7CFFF3FFL,
    77684L,
    0xFFFB85FBFBFBFBFFL,
    276144592896L,
    73350L,
    0xFFF789F7F7F7F7FFL,
    2305843214839435264L,
    61765L,
    0xFFEF91EFEFEFEFFFL,
    0xFFFFFF6FFE7FCFFDL,
    49282L,
    0xFFDFA1DFDFDFDFFFL,
    0xBFF7EFFFBFC00FFFL,
    78840L,
    0xFFBFC1BFBFBFBFFFL,
    68853737476L,
    82904L,
    0xFF7F817F7F7F7FFFL,
    0xFFFBFFEFA7FFA7FEL,
    24594L,
    0xFF81FEFEFEFEFEFFL,
    5669358141480L,
    9513L,
    0xFF83FDFDFDFDFDFFL,
    571239694356L,
    29012L,
    0xFF85FBFBFBFBFBFFL,
    0x8000002B00408028L,
    27684L,
    0xFF89F7F7F7F7F7FFL,
    4611686156948013096L,
    27901L,
    0xFF91EFEFEFEFEFFFL,
    8646911422261395496L,
    61477L,
    0xFFA1DFDFDFDFDFFFL,
    103093927960L,
    25719L,
    0xFFC1BFBFBFBFBFFFL,
    1769914688190546000L,
    50020L,
    0xFF817F7F7F7F7FFFL,
    2306924928660668456L,
    41547L,
    0x81FEFEFEFEFEFEFFL,
    0xFFFFF37EEFEFDFBEL,
    4750L,
    0x83FDFDFDFDFDFDFFL,
    4611688767357457345L,
    6014L,
    0x85FBFBFBFBFBFBFFL,
    0xBF7FFEFFBFFAF71FL,
    41529L,
    0x89F7F7F7F7F7F7FFL,
    0xFFFDFFFF777B7D6EL,
    84192L,
    0x91EFEFEFEFEFEFFFL,
    0xEEFFFFEFF0080BFEL,
    33433L,
    0xA1DFDFDFDFDFDFFFL,
    0xAFE0000FFF780402L,
    8555L,
    0xC1BFBFBFBFBFBFFFL,
    0xEE73FFFBFFBB77FEL,
    1009L,
    0x817F7F7F7F7F7FFFL,
    562962977269890L
  };

  /** 88507 entries loaded from PrecomputedTables.bin */
  public static final long[] LOOKUP_TABLE = new long[88507];

  public static final long[] SLIDER_PEXT;

  public static final int[] B_BASE = new int[64];
  public static final long[] B_MASK = new long[64];
  public static final long[] B_HASH = new long[64];
  public static final int[] R_BASE = new int[64];
  public static final long[] R_MASK = new long[64];
  public static final long[] R_HASH = new long[64];

  public static final long[] PAWN_ATK_W = new long[64];
  public static final long[] PAWN_ATK_B = new long[64];

  public static final long[] KING_ATK = new long[64];
  public static final long[] KNIGHT_ATK = new long[64];
  public static final long[] BETWEEN = new long[64 * 64];

  /** True iff Long.compress (→ PEXT) is available *and* not disabled by property. */
  public static final boolean USE_PEXT = true;

  static {
    try (var in = PreCompMoveGenTables.class.getResourceAsStream("PrecomputedTables.Magic.bin")) {
      if (in == null) throw new IllegalStateException("PrecomputedTables.Magic.bin missing");
      var buf = java.nio.ByteBuffer.wrap(in.readAllBytes()).order(java.nio.ByteOrder.LITTLE_ENDIAN);
      buf.asLongBuffer().get(LOOKUP_TABLE);
    } catch (Exception e) {
      throw new ExceptionInInitializerError(e);
    }
    try (var in = PreCompMoveGenTables.class.getResourceAsStream("PrecomputedTables.Pext.bin")) {
      if (in == null) throw new IllegalStateException("PrecomputedTables.Pext.bin missing");

      byte[] raw = in.readAllBytes(); // full file
      int n = raw.length >>> 3; // 8-bytes → longs

      SLIDER_PEXT = new long[n]; // exact fit
      java.nio.ByteBuffer.wrap(raw)
          .order(java.nio.ByteOrder.LITTLE_ENDIAN)
          .asLongBuffer()
          .get(SLIDER_PEXT);
    } catch (Exception e) {
      throw new ExceptionInInitializerError(e);
    }
    for (int s = 0; s < 64; ++s) {
      B_BASE[s] = (int) B_MAGICS[s * 3];
      B_MASK[s] = B_MAGICS[s * 3 + 1];
      B_HASH[s] = B_MAGICS[s * 3 + 2];
      R_BASE[s] = (int) R_MAGICS[s * 3];
      R_MASK[s] = R_MAGICS[s * 3 + 1];
      R_HASH[s] = R_MAGICS[s * 3 + 2];
    }
    for (int sq = 0; sq < 64; ++sq) {
      int r = sq >>> 3, f = sq & 7;
      if (r < 7 && f > 0) PAWN_ATK_W[sq] |= 1L << (sq + 7);
      if (r < 7 && f < 7) PAWN_ATK_W[sq] |= 1L << (sq + 9);
      if (r > 0 && f > 0) PAWN_ATK_B[sq] |= 1L << (sq - 9);
      if (r > 0 && f < 7) PAWN_ATK_B[sq] |= 1L << (sq - 7);
    }
    for (int sq = 0; sq < 64; ++sq) {
      int r = sq >>> 3, f = sq & 7;

      /* king & knight tables */
      long k = 0;
      for (int dr = -1; dr <= 1; ++dr)
        for (int df = -1; df <= 1; ++df) if ((dr | df) != 0) k = addToMask(k, r + dr, f + df);
      KING_ATK[sq] = k;
      KNIGHT_ATK[sq] = knightMask(r, f);
    }
    for (int a = 0; a < 64; ++a)
      for (int b = 0; b < 64; ++b) BETWEEN[a * 64 + b] = between(a, b); // strict – no end-points
  }

  private static long addToMask(long m, int r, int f) {
    return (r >= 0 && r < 8 && f >= 0 && f < 8) ? m | (1L << ((r << 3) | f)) : m;
  }

  private static long knightMask(int r, int f) {
    long m = 0;
    int[] dr = {-2, -1, 1, 2, 2, 1, -1, -2};
    int[] df = {1, 2, 2, 1, -1, -2, -2, -1};
    for (int i = 0; i < 8; i++) m = addToMask(m, r + dr[i], f + df[i]);
    return m;
  }

  private static boolean initUsePext() {
    /* 1) platform screen ─ JDK 21+ on x86-64 only ──────────────────── */
    if (Runtime.version().feature() < 21) return false;

    String archRaw = System.getProperty("os.arch");
    String arch = (archRaw == null) ? "" : archRaw.toLowerCase(Locale.ROOT);

    // Accept all typical spellings: “x86_64”, “amd64”, “x64”, “x86-64”
    boolean isX86_64 =
        arch.equals("x86_64")
            || arch.equals("amd64")
            || arch.equals("x64")
            || arch.equals("x86-64");

    if (!isX86_64) return false;

    /* 2) was BMI2 explicitly disabled? ─────────────────────────────── */
    try {
      // 2a) command-line flags
      var rtArgs = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments();
      for (String a : rtArgs) if (a.equals("-XX:-UseBMI2Instructions")) return false;

      // 2b) live VM option (HotSpot only, optional module)
      Class<?> raw =
          Class.forName(
              "com.sun.management.HotSpotDiagnosticMXBean",
              false,
              ClassLoader.getSystemClassLoader());

      var bean =
          java.lang.management.ManagementFactory.getPlatformMXBean(
              raw.asSubclass(java.lang.management.PlatformManagedObject.class));

      if (bean != null) {
        Object opt = raw.getMethod("getVMOption", String.class).invoke(bean, "UseBMI2Instructions");
        String val = (String) opt.getClass().getMethod("getValue").invoke(opt);
        if (!Boolean.parseBoolean(val)) // BMI2 turned off
        return false;
      }
    } catch (Throwable ignored) {
      /* Non-HotSpot VM or jdk.management absent → fall through        */
    }

    /* All checks passed → enable PEXT path */
    return true;
  }

  /** squares strictly between two aligned squares (0 if not on same ray) */
  private static long between(int from, int to) {

    if (from == to) return 0L;

    int df = (to & 7) - (from & 7); // file  difference  (-7 … +7)
    int dr = (to >>> 3) - (from >>> 3); // rank difference  (-7 … +7)

    int step;

    /*  ── determine ray direction (rank, file, or diagonal) ─────────── */
    if (dr == 0) step = (df > 0 ? 1 : -1); // same rank
    else if (df == 0) step = (dr > 0 ? 8 : -8); // same file
    else if (Math.abs(df) == Math.abs(dr)) // true diagonal
    step =
          (dr > 0
              ? (df > 0 ? 9 : 7) // up-right  or up-left
              : (df > 0 ? -7 : -9)); // down-right or down-left
    else return 0L; // not aligned → nothing in-between

    /*  ── walk from+step to (exclusive) ─────────────────────────────── */
    long bb = 0L;
    for (int sq = from + step; sq != to; sq += step) bb |= 1L << sq;

    return bb;
  }
}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\SearchImpl.java" 
package core.impl;

import core.contracts.*;
import core.records.SearchResult;
import core.records.SearchSpec;

import java.util.concurrent.CompletableFuture;

/**
 * Thin façade that delegates all heavy lifting to the configured WorkerPool.
 * Nothing here is pool-specific – you can plug in LazySmpWorkerPoolImpl or any
 * other WorkerPool implementation.
 */
public final class SearchImpl implements Search {

    /* immutable engine parts */
    private final PositionFactory positionFactory;
    private final MoveGenerator   moveGenerator;

    /* configurable services */
    private Evaluator           evaluator;
    private TranspositionTable  transpositionTable;
    private WorkerPool          workerPool;
    private TimeManager         timeManager;

    /* thread option remembered for future pool swaps */
    private int requestedThreads = 1;

    public SearchImpl(PositionFactory pf,
                      MoveGenerator   mg,
                      Evaluator       eval,
                      WorkerPool      pool,
                      TimeManager     tm) {

        this.positionFactory = pf;
        this.moveGenerator   = mg;
        this.evaluator       = eval;
        this.workerPool      = pool;
        this.timeManager     = tm;
    }

    /* ── setters required by Search interface ───────────────────── */

    @Override public void setEvaluator(Evaluator e)              { this.evaluator = e; }
    @Override public void setTranspositionTable(TranspositionTable tt) { this.transpositionTable = tt; }

    @Override public void setThreads(int n) {
        this.requestedThreads = n;
        if (workerPool != null) workerPool.setParallelism(n);
    }

    @Override public void setWorkerPool(WorkerPool pool) {
        if (this.workerPool != null) {
            try { this.workerPool.close(); } catch (Exception ignored) {}
        }
        this.workerPool = pool;
        if (pool != null) pool.setParallelism(requestedThreads);
    }

    @Override public void setTimeManager(TimeManager tm) { this.timeManager = tm; }

    /* ── synchronous / asynchronous search ─────────────────────── */

    @Override
    public SearchResult search(long[] bb, SearchSpec spec, InfoHandler ih) {
        if (workerPool == null)
            throw new IllegalStateException("WorkerPool not set");
        return workerPool
                .startSearch(bb, spec,
                        positionFactory, moveGenerator,
                        evaluator, transpositionTable,
                        timeManager, ih)
                .join(); // block caller
    }

    @Override
    public CompletableFuture<SearchResult> searchAsync(long[] bb,
                                                       SearchSpec spec,
                                                       InfoHandler ih) {
        return CompletableFuture.supplyAsync(() -> search(bb, spec, ih));
    }

    /* ── UCI helpers ───────────────────────────────────────────── */

    @Override public void stop()       { if (workerPool != null) workerPool.stopSearch(); }
    @Override public void ponderHit()  { /* not implemented */  }

    @Override
    public void close() {
        if (workerPool != null) {
            try { workerPool.close(); } catch (Exception ignored) {}
        }
    }
}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\TimeManagerImpl.java" 
// C:\dev\Helios\src\main\java\core\impl\TimeManagerImpl.java
package core.impl;

import core.contracts.TimeManager;
import core.contracts.UciOptions;
import core.records.SearchSpec;
import core.records.TimeAllocation;

/**
 * Time management logic based on the Lizard chess engine.
 * It calculates a soft time limit for normal search termination and a hard
 * maximum time limit.
 */
public final class TimeManagerImpl implements TimeManager {

    private static final int DEFAULT_MOVES_TO_GO = 50;
    private static final int MOVE_TIME_BUFFER = 5;
    private final UciOptions options;

    public TimeManagerImpl(UciOptions options) {
        this.options = options;
    }

    @Override
    public TimeAllocation calculate(SearchSpec spec, boolean isWhiteToMove) {

        /* "go infinite / ponder" -> think forever */
        if (spec.infinite() || spec.ponder()) {
            return new TimeAllocation(Long.MAX_VALUE, Long.MAX_VALUE);
        }

        /* strict "movetime N" from the GUI */
        if (spec.moveTimeMs() > 0) {
            long time = Math.max(1, spec.moveTimeMs() - MOVE_TIME_BUFFER);
            return new TimeAllocation(time, time);
        }

        long playerTime = isWhiteToMove ? spec.wTimeMs() : spec.bTimeMs();
        long playerInc = isWhiteToMove ? spec.wIncMs() : spec.bIncMs();

        if (playerTime <= 0) {
            // Give a tiny amount of time to at least make one move if possible
            return new TimeAllocation(1, 2);
        }

        int movesToGo = spec.movesToGo() > 0 ? spec.movesToGo() : DEFAULT_MOVES_TO_GO;

        // Lizard's logic for MaxSearchTime (hard limit for the move)
        long hardTime = playerInc + Math.max(playerTime / 2, playerTime / movesToGo);
        hardTime = Math.min(hardTime, Math.max(1, playerTime - moveOverhead())); // Don't use more than available time

        // Lizard's logic for SoftTimeLimit
        double softTime = 0.65 * ((double) playerTime / movesToGo + (playerInc * 3.0 / 4.0));

        long softTimeMs = Math.max(1, (long)softTime);
        long hardTimeMs = Math.max(1, hardTime);

        // Soft limit can't exceed hard limit
        if (softTimeMs > hardTimeMs) {
            softTimeMs = hardTimeMs;
        }

        return new TimeAllocation(softTimeMs, hardTimeMs);
    }

    /**
     * Move Overhead is used as a safety buffer to prevent losing on time.
     */
    private int moveOverhead() {
        String v = options.getOptionValue("Move Overhead");
        return v != null ? Integer.parseInt(v) : 50;
    }
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\TranspositionTableImpl.java" 
package core.impl;

import core.contracts.TranspositionTable;
import java.util.Arrays;
import static core.constants.CoreConstants.*;

public final class TranspositionTableImpl implements TranspositionTable {

    /* Each entry occupies 2 consecutive longs (16 bytes) in the table array.
     *
     * long 1 (data):
     * - 32 bits: zobrist check (upper 32 bits of the key)
     * - 32 bits: move
     *
     * long 2 (meta):
     * - 16 bits: static eval
     * - 16 bits: score
     * - 8 bits:  depth
     * - 5 bits:  age
     * - 2 bits:  bound type
     * - 1 bit:   isPV
     */
    private static final int LONGS_PER_ENTRY = 2;

    private static final int TT_MAX_AGE = 32;   // 5 bits for age (0-31)
    private static final int TT_AGE_WEIGHT = 8;
    private static final int TT_BUCKET_SIZE = 3; // 3-way set associative

    private long[] table;
    private int entryCount;
    private int bucketMask; // (entryCount / BUCKET_SIZE) - 1

    private volatile byte generation; // Current table age, kept volatile for visibility

    public TranspositionTableImpl(int megaBytes) {
        resize(megaBytes);
    }

    /* ── Bit-packing/Unpacking ──────────────────────── */
    private static int checkFromKey(long z)      { return (int) (z >>> 32); }
    private static int checkFromData(long data)  { return (int) (data >>> 32); }
    private static int moveFromData(long data)   { return (int) data; }

    private static short evalFromMeta(long meta) { return (short) meta; }
    private static short scoreFromMeta(long meta){ return (short) (meta >>> 16); }
    private static int depthFromMeta(long meta)  { return (int) ((meta >>> 32) & 0xFF); }
    private static int ageFromMeta(long meta)    { return (int) ((meta >>> 40) & 0x1F); }
    private static int boundFromMeta(long meta)  { return (int) ((meta >>> 45) & 0x3); }
    private static boolean pvFromMeta(long meta) { return ((meta >>> 47) & 1) == 1; }

    private int getAgeDistance(long meta) {
        return (generation - ageFromMeta(meta) + TT_MAX_AGE) & (TT_MAX_AGE - 1);
    }

    private int worth(int entryIndex) {
        long meta = table[entryIndex + 1];
        if (meta == 0) return Integer.MIN_VALUE; // Empty slots are the best victims
        return depthFromMeta(meta) - TT_AGE_WEIGHT * getAgeDistance(meta);
    }

    private boolean isEmpty(int entryIndex) {
        return table[entryIndex] == 0 && table[entryIndex + 1] == 0;
    }

    /* ── Addressing ──────────────────────────────── */
    private static long splitmix64(long z) {
        z += 0x9E3779B97F4A7C15L;
        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;
        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;
        return z ^ (z >>> 31);
    }

    private int bucketBase(long z) {
        int bucketIndex = (int) splitmix64(z) & bucketMask;
        return bucketIndex * TT_BUCKET_SIZE * LONGS_PER_ENTRY;
    }

    /* ── Life-cycle ──────────────────────────────── */
    @Override
    public synchronized void resize(int mb) {
        long bytes = (long) mb * 1_048_576L;
        long numEntries = bytes / (LONGS_PER_ENTRY * 8); // 16 bytes per entry
        if (numEntries < TT_BUCKET_SIZE) throw new IllegalArgumentException("TT size too small");

        long numBuckets = numEntries / TT_BUCKET_SIZE;
        int pow2Buckets = Integer.highestOneBit((int) Math.min(numBuckets, 1 << 30));

        this.entryCount = pow2Buckets * TT_BUCKET_SIZE;
        this.bucketMask = pow2Buckets - 1;
        this.table = new long[this.entryCount * LONGS_PER_ENTRY];
        this.generation = 0;
    }

    @Override public void clear() { Arrays.fill(table, 0L); }
    @Override public void incrementAge() { generation = (byte) ((generation + 1) & (TT_MAX_AGE - 1)); }
    @Override public byte getCurrentAge() { return generation; }

    /* ── Core API ──────────────────────────────── */
    @Override
    public int probe(long zKey) {
        int keyCheck = checkFromKey(zKey);
        int baseIndex = bucketBase(zKey);

        // 1. Look for an exact match
        for (int i = 0; i < TT_BUCKET_SIZE; ++i) {
            int entryIndex = baseIndex + i * LONGS_PER_ENTRY;
            if (checkFromData(table[entryIndex]) == keyCheck) {
                return entryIndex;
            }
        }

        // 2. No hit, find the best victim for replacement
        int victimIndex = baseIndex;
        int worstWorth = worth(victimIndex);

        for (int i = 1; i < TT_BUCKET_SIZE; ++i) {
            int entryIndex = baseIndex + i * LONGS_PER_ENTRY;
            int w = worth(entryIndex);
            if (w < worstWorth) {
                worstWorth = w;
                victimIndex = entryIndex;
            }
        }
        return victimIndex;
    }

    @Override
    public boolean wasHit(int entryIndex, long zobrist) {
        return checkFromData(table[entryIndex]) == checkFromKey(zobrist) && !isEmpty(entryIndex);
    }

    @Override
    public void store(int entryIndex, long zobrist, int bound, int depth, int move, int score, int staticEval, boolean isPv, int ply) {
        boolean isHit = wasHit(entryIndex, zobrist);
        long oldMeta = isHit ? table[entryIndex + 1] : 0;

        // Overwrite policy
        boolean replace;
        if (!isHit) {
            replace = true;
        } else {
            int ageDist = getAgeDistance(oldMeta);
            int currentDepth = depthFromMeta(oldMeta);
            replace = (bound == FLAG_EXACT)
                    || ageDist != 0
                    || depth + (isPv ? 6 : 4) > currentDepth;
        }

        if (!replace) return;

        // Keep the existing move if the new move is null
        if (move == 0 && isHit) {
            move = moveFromData(table[entryIndex]);
        }

        // Encode mate scores
        if (score != SCORE_NONE) {
            if (score >= SCORE_TB_WIN_IN_MAX_PLY) score += ply;
            else if (score <= SCORE_TB_LOSS_IN_MAX_PLY) score -= ply;
        }

        // Pack data into two longs
        long newData = ((long) checkFromKey(zobrist) << 32) | (move & 0xFFFFFFFFL);
        long newMeta = (staticEval & 0xFFFFL)
                | ((long) (score & 0xFFFFL) << 16)
                | ((long) depth << 32)
                | ((long) generation << 40)
                | ((long) bound << 45)
                | ((isPv ? 1L : 0L) << 47);

        // Standard array write
        table[entryIndex + 1] = newMeta;
        table[entryIndex] = newData;
    }

    /* ── Accessors ──────────────────────────────── */
    @Override public int getDepth(int entryIndex) { return depthFromMeta(table[entryIndex + 1]); }
    @Override public int getBound(int entryIndex) { return boundFromMeta(table[entryIndex + 1]); }
    @Override public int getMove(int entryIndex) { return moveFromData(table[entryIndex]); }
    @Override public int getStaticEval(int entryIndex) { return evalFromMeta(table[entryIndex + 1]); }
    @Override public int getRawScore(int entryIndex) { return scoreFromMeta(table[entryIndex + 1]); }
    @Override public boolean wasPv(int entryIndex) { return pvFromMeta(table[entryIndex + 1]); }

    @Override
    public int hashfull() {
        int filled = 0;
        int sampleSize = Math.min(1000, entryCount);
        if (sampleSize == 0) return 0;

        for (int i = 0; i < sampleSize; ++i) {
            int entryIndex = i * LONGS_PER_ENTRY;
            if (!isEmpty(entryIndex) && ageFromMeta(table[entryIndex + 1]) == generation) {
                filled++;
            }
        }
        return (filled * 1000) / sampleSize;
    }
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\UciHandlerImpl.java" 
package core.impl;

import core.contracts.*;
import core.records.SearchInfo;
import core.records.SearchResult;
import core.records.SearchSpec;
import main.Main;

import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Universal-Chess-Interface front-end.
 *
 * <p>All interaction with {@link Search} happens behind a single
 * monitor ({@code searchLock}) so that:</p>
 * <ul>
 *   <li>only <em>one</em> search can run at a time</li>
 *   <li>“info …” and “bestmove …” from an <em>old</em> search are
 *       never printed after a new position / search has started</li>
 * </ul>
 */
public final class UciHandlerImpl implements UciHandler {
    public static final List<String> BENCH_FENS = List.of(
            "r3k2r/2pb1ppp/2pp1q2/p7/1nP1B3/1P2P3/P2N1PPP/R2QK2R w KQkq a6 0 14",
            "4rrk1/2p1b1p1/p1p3q1/4p3/2P2n1p/1P1NR2P/PB3PP1/3R1QK1 b - - 2 24",
            "r3qbrk/6p1/2b2pPp/p3pP1Q/PpPpP2P/3P1B2/2PB3K/R5R1 w - - 16 42",
            "6k1/1R3p2/6p1/2Bp3p/3P2q1/P7/1P2rQ1K/5R2 b - - 4 44",
            "8/8/1p2k1p1/3p3p/1p1P1P1P/1P2PK2/8/8 w - - 3 54",
            "7r/2p3k1/1p1p1qp1/1P1Bp3/p1P2r1P/P7/4R3/Q4RK1 w - - 0 36",
            "r1bq1rk1/pp2b1pp/n1pp1n2/3P1p2/2P1p3/2N1P2N/PP2BPPP/R1BQ1RK1 b - - 2 10",
            "3r3k/2r4p/1p1b3q/p4P2/P2Pp3/1B2P3/3BQ1RP/6K1 w - - 3 87",
            "2r4r/1p4k1/1Pnp4/3Qb1pq/8/4BpPp/5P2/2RR1BK1 w - - 0 42",
            "4q1bk/6b1/7p/p1p4p/PNPpP2P/KN4P1/3Q4/4R3 b - - 0 37",
            "2q3r1/1r2pk2/pp3pp1/2pP3p/P1Pb1BbP/1P4Q1/R3NPP1/4R1K1 w - - 2 34",
            "1r2r2k/1b4q1/pp5p/2pPp1p1/P3Pn2/1P1B1Q1P/2R3P1/4BR1K b - - 1 37",
            "r3kbbr/pp1n1p1P/3ppnp1/q5N1/1P1pP3/P1N1B3/2P1QP2/R3KB1R b KQkq b3 0 17",
            "8/6pk/2b1Rp2/3r4/1R1B2PP/P5K1/8/2r5 b - - 16 42",
            "1r4k1/4ppb1/2n1b1qp/pB4p1/1n1BP1P1/7P/2PNQPK1/3RN3 w - - 8 29",
            "8/p2B4/PkP5/4p1pK/4Pb1p/5P2/8/8 w - - 29 68",
            "3r4/ppq1ppkp/4bnp1/2pN4/2P1P3/1P4P1/PQ3PBP/R4K2 b - - 2 20",
            "5rr1/4n2k/4q2P/P1P2n2/3B1p2/4pP2/2N1P3/1RR1K2Q w - - 1 49",
            "1r5k/2pq2p1/3p3p/p1pP4/4QP2/PP1R3P/6PK/8 w - - 1 51",
            "q5k1/5ppp/1r3bn1/1B6/P1N2P2/BQ2P1P1/5K1P/8 b - - 2 34",
            "r1b2k1r/5n2/p4q2/1ppn1Pp1/3pp1p1/NP2P3/P1PPBK2/1RQN2R1 w - - 0 22",
            "r1bqk2r/pppp1ppp/5n2/4b3/4P3/P1N5/1PP2PPP/R1BQKB1R w KQkq - 0 5",
            "r1bqr1k1/pp1p1ppp/2p5/8/3N1Q2/P2BB3/1PP2PPP/R3K2n b Q - 1 12",
            "r1bq2k1/p4r1p/1pp2pp1/3p4/1P1B3Q/P2B1N2/2P3PP/4R1K1 b - - 2 19",
            "r4qk1/6r1/1p4p1/2ppBbN1/1p5Q/P7/2P3PP/5RK1 w - - 2 25",
            "r7/6k1/1p6/2pp1p2/7Q/8/p1P2K1P/8 w - - 0 32",
            "r3k2r/ppp1pp1p/2nqb1pn/3p4/4P3/2PP4/PP1NBPPP/R2QK1NR w KQkq - 1 5",
            "3r1rk1/1pp1pn1p/p1n1q1p1/3p4/Q3P3/2P5/PP1NBPPP/4RRK1 w - - 0 12",
            "5rk1/1pp1pn1p/p3Brp1/8/1n6/5N2/PP3PPP/2R2RK1 w - - 2 20",
            "8/1p2pk1p/p1p1r1p1/3n4/8/5R2/PP3PPP/4R1K1 b - - 3 27",
            "8/4pk2/1p1r2p1/p1p4p/Pn5P/3R4/1P3PP1/4RK2 w - - 1 33",
            "8/5k2/1pnrp1p1/p1p4p/P6P/4R1PK/1P3P2/4R3 b - - 1 38",
            "8/8/1p1kp1p1/p1pr1n1p/P6P/1R4P1/1P3PK1/1R6 b - - 15 45",
            "8/8/1p1k2p1/p1prp2p/P2n3P/6P1/1P1R1PK1/4R3 b - - 5 49",
            "8/8/1p4p1/p1p2k1p/P2npP1P/4K1P1/1P6/3R4 w - - 6 54"
    );
    /* ── engine singletons ─────────────────────────────────────── */
    private final Search          search;
    private final PositionFactory pf;
    private final UciOptions      opts;
    private final MoveGenerator mg;

    /* ── mutable engine state (guarded by searchLock) ──────────── */
    private final Object searchLock = new Object();

    /** side effect-free copy of the current position */
    private long[] currentPos;
    /** all previous Zobrist keys (for 3-fold repetition) */
    private final List<Long> history = new ArrayList<>();

    /** handle of the search currently in flight (nullable) */
    private CompletableFuture<SearchResult> searchFuture;
    /** incremented for every new “go”, used to ignore stale callbacks */
    private int searchId = 0;

    /* ── construction ──────────────────────────────────────────── */
    public UciHandlerImpl(Search search,
                          PositionFactory pf,
                          UciOptions opts,
                          MoveGenerator mg) {
        this.search = search;
        this.pf     = pf;
        this.opts   = opts;
        this.mg    = mg;

        // start-pos
        this.currentPos = pf.fromFen(
                "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
    }

    /* ── main loop ─────────────────────────────────────────────── */
    @Override public void runLoop() {
        try (Scanner in = new Scanner(System.in)) {
            while (in.hasNextLine()) {
                String line = in.nextLine().trim();
                if (!line.isEmpty() && handle(line)) break;   // “quit” → exit
            }
        }
    }

    /* ── router ───────────────────────────────────────────────── */
    private boolean handle(String cmd) {
        String[] t = cmd.split("\\s+");

        return switch (t[0]) {
            case "uci"          -> { cmdUci();        yield false; }
            case "isready"      -> { System.out.println("readyok"); yield false; }
            case "ucinewgame"   -> { cmdNewGame();    yield false; }
            case "setoption"    -> { opts.setOption(cmd); yield false; }
            case "position"     -> { cmdPosition(t);  yield false; }
            case "go"           -> { cmdGo(t);        yield false; }
            case "stop"         -> { cmdStop();       yield false; }
            case "ponderhit"    -> { search.ponderHit(); yield false; }
            case "quit"         -> { cmdStop();       yield true;  }
            default             -> { // unknown
                System.out.println("info string Unknown command: " + cmd);
                yield false;
            }
        };
    }

    /* ── UCI commands ─────────────────────────────────────────── */

    private void cmdUci() {
        System.out.println("id name Helios");
        System.out.println("id author Your Name");
        opts.printOptions();
        System.out.println("uciok");
    }

    private void cmdNewGame() {
        synchronized (searchLock) {
            cancelRunningSearch();
            opts.getTranspositionTable().clear();
            history.clear();
        }
    }

    private void cmdStop() {
        synchronized (searchLock) { cancelRunningSearch(); }
    }

    private void cmdPosition(String[] t) {
        synchronized (searchLock) {
            cancelRunningSearch();

            int i = 1;
            if ("startpos".equals(t[i])) {                       // startpos
                currentPos = pf.fromFen(
                        "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
                i++;
            } else if ("fen".equals(t[i])) {                     // FEN …
                StringBuilder fen = new StringBuilder();
                while (++i < t.length && !"moves".equals(t[i]))
                    fen.append(t[i]).append(' ');
                currentPos = pf.fromFen(fen.toString().trim());
            } else {
                return;                                          // malformed
            }

            history.clear();
            history.add(currentPos[PositionFactory.HASH]);

            /* optional move list */
            if (i < t.length && "moves".equals(t[i])) {
                MoveGenerator mg = new MoveGeneratorImpl();
                for (int k = i + 1; k < t.length; k++) {
                    int mv = UciMove.stringToMove(currentPos, t[k], mg);
                    if (mv != 0 && pf.makeMoveInPlace(currentPos, mv, mg))
                        history.add(currentPos[PositionFactory.HASH]);
                }
                history.remove(history.size() - 1);              // last == current
            }
        }
    }

    private void cmdGo(String[] t) {
        /* 1) build SearchSpec ---------------------------------- */
        SearchSpec.Builder b = new SearchSpec.Builder();
        for (int i = 1; i < t.length; i++)
            switch (t[i]) {
                case "wtime"     -> b.wTimeMs(Long.parseLong(t[++i]));
                case "btime"     -> b.bTimeMs(Long.parseLong(t[++i]));
                case "winc"      -> b.wIncMs(Long.parseLong(t[++i]));
                case "binc"      -> b.bIncMs(Long.parseLong(t[++i]));
                case "movestogo" -> b.movesToGo(Integer.parseInt(t[++i]));
                case "depth"     -> b.depth(Integer.parseInt(t[++i]));
                case "nodes"     -> b.nodes(Long.parseLong(t[++i]));
                case "movetime"  -> b.moveTimeMs(Long.parseLong(t[++i]));
                case "infinite"  -> b.infinite(true);
                case "ponder"    -> b.ponder(true);
            }

        final int myId;
        synchronized (searchLock) {
            cancelRunningSearch();

            myId = ++searchId;
            b.history(new ArrayList<>(history));

            opts.getTranspositionTable().incrementAge();

            searchFuture = search.searchAsync(
                    currentPos.clone(),
                    b.build(),
                    info -> { if (myId == searchId) printInfo(info); });
        }

        /* handle completion asynchronously */
        searchFuture.thenAccept(r -> {
            synchronized (searchLock) {
                if (myId == searchId) printResult(r);
            }
        }).exceptionally(ex -> {
            System.out.println("info string search error: " + ex);
            return null;
        });
    }

    /* ── local helpers ────────────────────────────────────────── */
    private static List<String> readAllLinesSilently(String file) {
        try { return Files.readAllLines(Paths.get(file)); }
        catch (IOException ex) {
            System.out.printf("info string bench: cannot read %s (%s)%n", file, ex);
            return List.of();
        }
    }

    private static List<String> loadResourceLines(String r) {     // <-- unused now
        try (var in = UciHandlerImpl.class.getResourceAsStream(r);
             var br = new java.io.BufferedReader(new InputStreamReader(in))) {
            return br.lines().filter(l -> !l.isBlank())
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static int  toInt (String s, int  d) { try { return Integer.parseInt(s);} catch(Exception e){return d;}}
    private static long toLong(String s, long d) { try { return Long.parseLong(s);} catch(Exception e){return d;}}



    /* ── helpers ─────────────────────────────────────────────── */

    /** stop & wait for any running search */
    private void cancelRunningSearch() {
        if (searchFuture != null && !searchFuture.isDone()) {
            search.stop();
            searchFuture.join();     // wait until fully stopped
        }
        searchFuture = null;
    }

    private void printInfo(SearchInfo si) {
        StringBuilder sb = new StringBuilder("info");
        sb.append(" depth ").append(si.depth());
        if (si.selDepth() > 0) sb.append(" seldepth ").append(si.selDepth());
        sb.append(" score ").append(UciScore.format(si.scoreCp(), si.isMate()));
        sb.append(" nodes ").append(si.nodes());
        sb.append(" nps ").append(si.nps());
        sb.append(" time ").append(si.timeMs());
        if (si.hashFullPermil() >= 0) sb.append(" hashfull ").append(si.hashFullPermil());
        if (!si.pv().isEmpty()) {
            sb.append(" pv");
            si.pv().forEach(mv -> sb.append(' ').append(UciMove.moveToUci(mv)));
        }
        System.out.println(sb);
    }

    private void printResult(SearchResult r) {
        String best   = UciMove.moveToUci(r.bestMove());
        String ponder = r.ponderMove() == 0 ? "" :
                " ponder " + UciMove.moveToUci(r.ponderMove());
        System.out.println("bestmove " + best + ponder);
    }

    /* ── tiny utility helpers ────────────────────────────────── */

    private static final class UciMove {

        static String moveToUci(int m) {
            if (m == 0) return "0000";
            int from = (m >>> 6) & 63, to = m & 63;
            String res = sq(from) + sq(to);
            if (((m >>> 14) & 3) == 1)                       // promotion
                res += "nbrq".charAt((m >>> 12) & 3);
            return res;
        }

        static int stringToMove(long[] pos, String s, MoveGenerator mg) {
            int[] list = new int[256];
            boolean inCheck = PositionFactory.whiteToMove(
                    pos[PositionFactory.META])
                    ? mg.kingAttacked(pos, true)
                    : mg.kingAttacked(pos, false);

            int n = inCheck ? mg.generateEvasions(pos, list, 0)
                    : mg.generateQuiets(pos, list,
                    mg.generateCaptures(pos, list, 0));

            for (int i = 0; i < n; i++)
                if (moveToUci(list[i]).equals(s)) return list[i];
            return 0;
        }

        private static String sq(int s) {
            return "" + (char) ('a' + (s & 7)) + (1 + (s >>> 3));
        }
    }

    private static final class UciScore {
        static String format(int cp, boolean mate) {
            return mate
                    ? "mate " + (cp > 0 ? (32000 - cp + 1) / 2
                    : -(32000 + cp) / 2)
                    : "cp " + cp;
        }
    }
}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\impl\UciOptionsImpl.java" 
package core.impl;

import core.contracts.Search;
import core.contracts.TranspositionTable;
import core.contracts.UciOptions;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.function.Consumer;

/**
 * Implements the UciOptions contract to manage engine settings.
 */
public class UciOptionsImpl implements UciOptions {

    private Search search;
    private final TranspositionTable transpositionTable;

    private record UciOption(String type, String defaultValue, String min, String max, Consumer<String> onSet) {
        void print(String name) {
            System.out.print("option name " + name + " type " + type);
            if (defaultValue != null) System.out.print(" default " + defaultValue);
            if (min != null) System.out.print(" min " + min);
            if (max != null) System.out.print(" max " + max);
            System.out.println();
        }
    }

    private final Map<String, UciOption> options = new LinkedHashMap<>();

    public UciOptionsImpl(Search search, TranspositionTable transpositionTable) {
        this.search = search;
        this.transpositionTable = transpositionTable;
        initializeOptions();
    }

    @Override
    public TranspositionTable getTranspositionTable() {
        return this.transpositionTable;
    }

    private void initializeOptions() {
        options.put("Hash", new UciOption("spin", "64", "1", "1024",
                value -> this.transpositionTable.resize(Integer.parseInt(value))));
        options.put("Threads", new UciOption("spin", "1", "1", "128",
                value -> this.search.setThreads(Integer.parseInt(value))));
        options.put("Clear Hash", new UciOption("button", null, null, null,
                value -> this.transpositionTable.clear()));
        // inside initializeOptions()
        options.put("Move Overhead",             // identical name
                new UciOption("spin", "50",      // default 50 ms
                        "0", "5000",
                        v -> { /* value read by TimeManagerImpl */ }));
        options.put("MultiPV",
                new UciOption("spin", "1",       // default 1 line
                        "1", "8",
                        v -> {}));
        options.put("Minimal",
                new UciOption("check", "false", null, null,
                        v -> {}));
    }

    public String getOptionValue(String name) {
        UciOption o = options.get(name);
        return o != null ? o.defaultValue /* or cached current value */ : null;
    }

    public void attachSearch(Search s) { this.search = s; }

    @Override
    public void setOption(String line) {
        try {
            String[] parts = line.split(" value ");
            String namePart = parts[0].replace("setoption name ", "").trim();
            String valuePart = parts.length > 1 ? parts[1].trim() : "";

            UciOption option = options.get(namePart);
            if (option != null) {
                if (option.onSet != null) {
                    option.onSet.accept(valuePart);
                }
            } else {
                System.out.println("info string Unknown option: " + namePart);
            }
        } catch (Exception e) {
            System.out.println("info string Error setting option: " + line);
        }
    }

    @Override
    public void printOptions() {
        for (Map.Entry<String, UciOption> entry : options.entrySet()) {
            entry.getValue().print(entry.getKey());
        }
    }
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\records\SearchInfo.java" 
package core.records;

import java.util.List;

/**
 * Immutable snapshot of a *single* “info” line that the searcher feeds to
 * a {@link core.contracts.InfoHandler}.
 *
 * @param depth           Principal depth (in plies) reached so far.
 * @param selDepth        Maximum selective depth (extensions, checks, etc.).
 * @param multiPvIdx      1-based index when {@code multiPV > 1}.
 * @param scoreCp         Evaluation in centipawns from the root mover’s
 * perspective, or <i>(MateValue ± ply)</i>.
 * @param isMate          True if the score represents a forced mate.
 * @param nodes           Total nodes searched so far.
 * @param nps             Average speed in nodes per second.
 * @param timeMs          Wall-clock time elapsed (milliseconds).
 * @param pv              Principal variation as a list of encoded moves.
 * @param hashFullPermil  Transposition-table saturation in ‰.
 * @param tbHits          Number of Syzygy WDL/DTZ probes done so far.
 */
public record SearchInfo(
        int           depth,
        int           selDepth,
        int           multiPvIdx,
        int           scoreCp,
        boolean       isMate,
        long          nodes,
        long          nps,
        long          timeMs,
        List<Integer> pv,
        int           hashFullPermil,
        long          tbHits
) {}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\records\SearchResult.java" 
package core.records;

import java.util.List;

/**
 * Final result produced when a search completes normally or is stopped.
 *
 * <p>All fields are immutable so callers can freely cache or forward
 * the object across threads.</p>
 *
 * @param bestMove   Engine-chosen move to play (0 ⇒ none legal).
 * @param ponderMove Expected reply by the opponent (0 ⇒ unknown).
 * @param pv         Full principal variation starting with {@code bestMove}.
 * @param scoreCp    Centipawn score, or <i>(MateValue ± ply)</i>
 *                   if {@code mateFound} is {@code true}.
 * @param mateFound  Indicates the score encodes a forced mate.
 * @param depth      Principal depth actually completed.
 * @param nodes      Total nodes searched.
 * @param timeMs     Wall-clock time consumed by the search.
 */
public record SearchResult(
        int              bestMove,
        int              ponderMove,
        List<Integer>    pv,
        int              scoreCp,
        boolean          mateFound,
        int              depth,
        long             nodes,
        long             timeMs
) {}

C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\records\SearchSpec.java" 
package core.records;

import java.util.Collections;
import java.util.List;

/**
 * Immutable set of <em>search limits / directives</em>.
 *
 * Use the nested {@link Builder} to construct an instance of this record.
 *
 * @param depth            Fixed search depth in plies.
 * @param nodes            Hard node budget (0 = unlimited).
 * @param moveTimeMs       Exact move-time (0 = unused).
 * @param wTimeMs          White’s remaining clock time.
 * @param wIncMs           White’s increment per move.
 * @param bTimeMs          Black’s remaining clock time.
 * @param bIncMs           Black’s increment per move.
 * @param movesToGo        Moves until the next time control (0 = unknown).
 * @param infinite         Run until {@code stop()} – <i>ignores</i> other limits.
 * @param ponder           {@code true} ⇢ GUI clock still ticking.
 * @param history          List of Zobrist keys from previous positions in the game.
 */
public record SearchSpec(
        int   depth,
        long  nodes,
        long  moveTimeMs,
        long  wTimeMs, long wIncMs,
        long  bTimeMs, long bIncMs,
        int   movesToGo,
        boolean infinite,
        boolean ponder,
        List<Long> history
) {
    /**
     * A builder for creating {@link SearchSpec} instances. This provides a fluent API
     * for setting search parameters and is more readable than a large constructor.
     */
    public static class Builder {
        private int depth = 0;
        private long nodes = 0;
        private long moveTimeMs = 0;
        private long wTimeMs = 0;
        private long wIncMs = 0;
        private long bTimeMs = 0;
        private long bIncMs = 0;
        private int movesToGo = 0;
        private boolean infinite = false;
        private boolean ponder = false;
        private List<Long> history = Collections.emptyList();

        public Builder depth(int depth) { this.depth = depth; return this; }
        public Builder nodes(long nodes) { this.nodes = nodes; return this; }
        public Builder moveTimeMs(long moveTimeMs) { this.moveTimeMs = moveTimeMs; return this; }
        public Builder wTimeMs(long wTimeMs) { this.wTimeMs = wTimeMs; return this; }
        public Builder wIncMs(long wIncMs) { this.wIncMs = wIncMs; return this; }
        public Builder bTimeMs(long bTimeMs) { this.bTimeMs = bTimeMs; return this; }
        public Builder bIncMs(long bIncMs) { this.bIncMs = bIncMs; return this; }
        public Builder movesToGo(int movesToGo) { this.movesToGo = movesToGo; return this; }
        public Builder infinite(boolean infinite) { this.infinite = infinite; return this; }
        public Builder ponder(boolean ponder) { this.ponder = ponder; return this; }
        public Builder history(List<Long> history) { this.history = history; return this; }

        public SearchSpec build() {
            return new SearchSpec(depth, nodes, moveTimeMs, wTimeMs, wIncMs, bTimeMs, bIncMs,
                    movesToGo, infinite, ponder, history);
        }
    }
}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\core\records\TimeAllocation.java" 
package core.records;

/**
 * A record to hold the calculated soft and maximum thinking time for a move.
 *
 * @param soft The target time in milliseconds the engine should aim for (soft limit).
 * @param maximum The hard limit in milliseconds the engine must not exceed.
 */
public record TimeAllocation(long soft, long maximum) {}
C:\dev\Helios\src\main>type "C:\dev\Helios\src\main\java\main\Main.java" 
// File: Main.java
package main;

import core.contracts.*;
import core.impl.*;

import java.util.List;

/**
 * Wire everything together and run the UCI loop.
 * The threading model now uses persistent worker threads coordinated via
 * condition variables, matching the design of the Lizard reference engine.
 */
public final class Main {

    public static void main(String[] args) {
        if (args.length > 0 && "bench".equalsIgnoreCase(args[0])) {
            int depth = (args.length > 3) ? Integer.parseInt(args[3]) : 4;
            runPerftBench(depth);
            return;
        }

        System.out.println("Helios Chess Engine");

        PositionFactory pf = new PositionFactoryImpl();
        MoveGenerator mg = new MoveGeneratorImpl();
        Evaluator ev = new EvaluatorImpl();
        TranspositionTable tt = new TranspositionTableImpl(64);

        // This factory now creates our new persistent worker threads
        SearchWorkerFactory swf = (isMain, pool) ->
                new LazySmpSearchWorkerImpl(isMain, (LazySmpWorkerPoolImpl) pool);

        // The new pool manages persistent threads
        WorkerPool pool = new LazySmpWorkerPoolImpl(1, swf);

        UciOptionsImpl opts = new UciOptionsImpl(null, tt);
        TimeManager tm = new TimeManagerImpl(opts);

        Search search = new SearchImpl(pf, mg, ev, pool, tm);
        search.setTranspositionTable(tt);
        opts.attachSearch(search);

        UciHandler uci = new UciHandlerImpl(search, pf, opts, mg);

        try {
            uci.runLoop();
        } finally {
            search.close();
        }
    }

    // The perft bench logic remains unchanged as it's single-threaded.
    private static void runPerftBench(int depth) {
        PositionFactory pf = new PositionFactoryImpl();
        MoveGenerator mg = new MoveGeneratorImpl();
        List<String> FENS = core.impl.UciHandlerImpl.BENCH_FENS;

        long totalNodes = 0, totalTimeMs = 0;

        for (String fen : FENS) {
            long[] root = pf.fromFen(fen);
            long t0 = System.nanoTime();
            long nodes = perft(root, depth, 0, pf, mg);
            long ms = (System.nanoTime() - t0) / 1_000_000;

            totalNodes += nodes;
            totalTimeMs += ms;
        }

        long totalNps = totalTimeMs > 0 ? (1000L * totalNodes) / totalTimeMs : 0;
        System.out.printf("Nodes searched: %d%n", totalNodes);
        System.out.printf("nps: %d%n", totalNps);
        System.out.println("benchok");
    }

    private static final int MAX_PLY = 64;
    private static final int LIST_CAP = 256;
    private static final int[][] MOVES = new int[MAX_PLY][LIST_CAP];

    private static long perft(long[] bb, int depth, int ply, PositionFactory pf, MoveGenerator mg) {
        if (depth == 0) return 1;

        int[] list = MOVES[ply];
        boolean white = PositionFactory.whiteToMove(bb[PositionFactory.META]);
        int nMoves = mg.kingAttacked(bb, white)
                ? mg.generateEvasions(bb, list, 0)
                : mg.generateQuiets(bb, list, mg.generateCaptures(bb, list, 0));

        long nodes = 0;
        for (int i = 0; i < nMoves; i++) {
            if (!pf.makeMoveInPlace(bb, list[i], mg)) continue;
            nodes += perft(bb, depth - 1, ply + 1, pf, mg);
            pf.undoMoveInPlace(bb);
        }
        return nodes;
    }
}