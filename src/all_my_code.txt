
C:\dev\Helios\src>(echo.   & echo // File: MoveGeneratorBenchmark.java   & type "C:\dev\Helios\src\jmh\java\core\MoveGeneratorBenchmark.java" ) 
 
// File: MoveGeneratorBenchmark.java 
package core;

import core.contracts.MoveGenerator;
import core.contracts.PositionFactory;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;
import java.util.concurrent.TimeUnit;

import core.impl.MoveGeneratorImpl;
import core.impl.PositionFactoryImpl;
import org.openjdk.jmh.annotations.*;

/**
 * Throughput benchmark that performs exactly the same perft
 * as {@link MoveGeneratorPerftTest}, but under the JMH harness.
 */
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
@State(Scope.Thread)
public class MoveGeneratorBenchmark {

  /* ── engine wiring ─────────────────────────────────────────── */
  private static final PositionFactory FACT = new PositionFactoryImpl();
  private static final MoveGenerator  GEN  = new MoveGeneratorImpl();

  /* scratch buffers (no GC) ------------------------------------ */
  private static final int MAX_PLY  = 64;
  private static final int LIST_CAP = 256;
  private static final int[][] MOVES = new int[MAX_PLY][LIST_CAP];

  /* per-ft cases loaded once per fork -------------------------- */
  private record Case(long[] root, boolean moverIsWhite, int depth) {}
  private List<Case> cases;

  /* simple node counter so JMH can report throughput ----------- */
  @AuxCounters(AuxCounters.Type.EVENTS)
  @State(Scope.Thread)
  public static class Metrics { public long nodes; }

  /* ── load /perft/qbb.txt at trial start ─────────────────────- */
  @Setup(Level.Trial)
  public void init() throws Exception {
    cases = new ArrayList<>();

    try (var is = getClass().getResourceAsStream("/perft/qbb.txt");
         var br = new BufferedReader(new InputStreamReader(Objects.requireNonNull(is)))) {

      br.lines()
              .map(String::trim)
              .filter(l -> !(l.isEmpty() || l.startsWith("#")))
              .limit(10)
              .forEach(l -> {
                String[] p = l.split(";");
                String fen   = p[0].trim();
                int    depth = Integer.parseInt(p[1].replaceAll("[^0-9]", ""));
                long[] root  = FACT.fromFen(fen);
                boolean white = fen.split("\\s+")[1].charAt(0) == 'w';
                cases.add(new Case(root, white, depth));
              });
    }
    if (cases.isEmpty())
      throw new IllegalStateException("no perft vectors found");
  }

  /* ── benchmark body ------------------------------------------ */
  @Benchmark
  public void perftNodes(Metrics m) {
    long total = 0;
    for (Case c : cases)
      total += perft(c.root.clone(), c.moverIsWhite, c.depth, 0);
    m.nodes += total;
  }

  /* =============================================================
   *  Recursive perft identical to MoveGeneratorPerftTest
   * ============================================================= */
  private static long perft(long[] bb, boolean moverIsWhite, int depth, int ply) {
    if (depth == 0) return 1;

    int[] moves = MOVES[ply];
    int cnt;

    /* 1) choose which move list to generate */
    if (GEN.kingAttacked(bb, moverIsWhite)) {
      cnt = GEN.generateEvasions(bb, moves, 0);
    } else {
      cnt = GEN.generateCaptures(bb, moves, 0);   // noisy first
      cnt = GEN.generateQuiets  (bb, moves, cnt); // quiets appended
    }

    long nodes = 0;

    /* 2) depth-first search over that list */
    for (int i = 0; i < cnt; ++i) {
      if (!FACT.makeMoveInPlace(bb, moves[i], GEN)) continue; // illegal
      nodes += perft(bb, !moverIsWhite, depth - 1, ply + 1);
      FACT.undoMoveInPlace(bb);                                // restore
    }
    return nodes;
  }
}

C:\dev\Helios\src>(echo.   & echo // File: module-info.java   & type "C:\dev\Helios\src\main\java\module-info.java" ) 
 
// File: module-info.java 
/** JPMS descriptor for Helios chess engine. */
open module Helios {          // use `open` if reflection is needed elsewhere
    requires java.management;
}
C:\dev\Helios\src>(echo.   & echo // File: CoreConstants.java   & type "C:\dev\Helios\src\main\java\core\constants\CoreConstants.java" ) 
 
// File: CoreConstants.java 
package core.constants;

public class CoreConstants {
    /* Score constants */
    public static final int MAX_PLY = 127;
    public static final int SCORE_MATE = 32000;
    public static final int SCORE_MATE_IN_MAX_PLY = SCORE_MATE - MAX_PLY;
    public static final int SCORE_TB_WIN_IN_MAX_PLY  = SCORE_MATE_IN_MAX_PLY - 1;
    public static final int SCORE_TB_LOSS_IN_MAX_PLY = -SCORE_TB_WIN_IN_MAX_PLY;
    public static final int SCORE_NONE = 32002;
    public static final int SCORE_DRAW = 0;

    /* Search constants */
    public static final int ASP_WINDOW_START_DEPTH = 5;
    public static final int ASP_WINDOW_INITIAL_DELTA = 15;

    public static final int QSEARCH_MAX_PLY = 8;
}

C:\dev\Helios\src>(echo.   & echo // File: Evaluator.java   & type "C:\dev\Helios\src\main\java\core\contracts\Evaluator.java" ) 
 
// File: Evaluator.java 
package core.contracts;

public interface Evaluator {
    int evaluate(long[] bb);  // centipawns from side to move
    default void reset() {}   // clear caches between games
}
C:\dev\Helios\src>(echo.   & echo // File: InfoHandler.java   & type "C:\dev\Helios\src\main\java\core\contracts\InfoHandler.java" ) 
 
// File: InfoHandler.java 
package core.contracts;

import core.records.SearchInfo;

/**
 * Callback for incremental search updates (“info” lines in UCI terms).
 *
 * <p>The engine should call {@link #onInfo} every time it has new data to
 * report: a deeper ply reached, a better PV found, etc.  GUI front-ends or
 * test harnesses can then render or record the progress without parsing
 * textual UCI output.</p>
 */
@FunctionalInterface
public interface InfoHandler {

    /**
     * Invoked by the search whenever it generates a new {@link SearchInfo}
     * snapshot.
     *
     * @param info immutable data object describing the current search state
     */
    void onInfo(SearchInfo info);
}

C:\dev\Helios\src>(echo.   & echo // File: MoveGenerator.java   & type "C:\dev\Helios\src\main\java\core\contracts\MoveGenerator.java" ) 
 
// File: MoveGenerator.java 
package core.contracts;

public interface MoveGenerator {
  int generateCaptures(long[] packedPosition, int[] mv, int n);

  int generateQuiets(long[] packedPosition, int[] mv, int n);

  int generateEvasions(long[] packedPosition, int[] mv, int n);

  boolean kingAttacked(long[] bb, boolean moverWasWhite);

  boolean castleLegal(long[] packedPosition, int from, int to);
}

C:\dev\Helios\src>(echo.   & echo // File: PositionFactory.java   & type "C:\dev\Helios\src\main\java\core\contracts\PositionFactory.java" ) 
 
// File: PositionFactory.java 
package core.contracts;

public interface PositionFactory {

  /* ───────── Piece indices ──────── */
  int WP = 0, WN = 1, WB = 2, WR = 3, WQ = 4, WK = 5;
  int BP = 6, BN = 7, BB = 8, BR = 9, BQ = 10, BK = 11;
  int META = 12;
  int DIFF_META = 13;
  int DIFF_INFO = 14;

  /* ───────── Board array layout (indices) ───────── */
  int HASH      = 15; // 64-bit Zobrist key
  int COOKIE_SP = 16; // stack pointer
  int COOKIE_BASE = 17;
  int COOKIE_CAP  = 1000;
  int BB_LEN      = COOKIE_BASE + COOKIE_CAP; // New total length

  long EP_NONE = 63;
  long STM_MASK = 1L;
  int CR_SHIFT = 1;
  long CR_MASK = 0b1111L << CR_SHIFT;
  int EP_SHIFT = 5;
  long EP_MASK = 0x3FL << EP_SHIFT;
  int HC_SHIFT = 11;
  long HC_MASK = 0x7FL << HC_SHIFT;
  int FM_SHIFT = 18;
  long FM_MASK = 0x1FFL << FM_SHIFT;

  /* fast helpers – **signatures only** */
  boolean makeMoveInPlace(long[] bb, int move, MoveGenerator gen);
  void undoMoveInPlace(long[] bb);

  long[] fromFen(String fen);

  String toFen(long[] bb);

  long zobrist(long[] bb);

  long zobrist50(long[] bb);

  static boolean whiteToMove(long meta) {
    return (meta & STM_MASK) == 0;
  }

  static long castling(long meta) {
    return (meta & CR_MASK) >>> CR_SHIFT;
  }

  static long epSquare(long meta) {
    return (meta & EP_MASK) >>> EP_SHIFT;
  }

  static long halfClock(long meta) {
    return (meta & HC_MASK) >>> HC_SHIFT;
  }

  static long fullMove(long meta) {
    return 1 + ((meta & FM_MASK) >>> FM_SHIFT);
  }
}
C:\dev\Helios\src>(echo.   & echo // File: Search.java   & type "C:\dev\Helios\src\main\java\core\contracts\Search.java" ) 
 
// File: Search.java 
package core.contracts;

import core.records.SearchResult;
import core.records.SearchSpec;

import java.util.concurrent.CompletableFuture;

public interface Search extends AutoCloseable {

    void setEvaluator(Evaluator evaluator);
    void setTranspositionTable(TranspositionTable tt);
    void setThreads(int workerCount);
    void setWorkerPool(WorkerPool pool);
    void setTimeManager(TimeManager timeManager); // Added this line

    SearchResult search(long[] bb, SearchSpec spec, InfoHandler ih);
    CompletableFuture<SearchResult> searchAsync(long[] bb, SearchSpec spec, InfoHandler ih);

    void stop();
    void ponderHit();
    @Override
    void close();
}
C:\dev\Helios\src>(echo.   & echo // File: SearchWorker.java   & type "C:\dev\Helios\src\main\java\core\contracts\SearchWorker.java" ) 
 
// File: SearchWorker.java 
package core.contracts;

import core.records.SearchResult;
import core.records.SearchSpec;

public interface SearchWorker {
    void prepareForSearch(long[] bb, SearchSpec spec, PositionFactory pf, MoveGenerator mg, Evaluator eval, TranspositionTable tt, TimeManager tm);
    void terminate();
    SearchResult getSearchResult();
    void setInfoHandler(InfoHandler handler);
    void join() throws InterruptedException; // Added for thread management
}
C:\dev\Helios\src>(echo.   & echo // File: SearchWorkerFactory.java   & type "C:\dev\Helios\src\main\java\core\contracts\SearchWorkerFactory.java" ) 
 
// File: SearchWorkerFactory.java 
package core.contracts;

/**
 * A factory for creating instances of {@link SearchWorker}.
 *
 * <p>This abstraction allows the {@link WorkerPool} to create search workers
 * without being coupled to a specific implementation.</p>
 */
public interface SearchWorkerFactory {

    /**
     * Creates a new search worker.
     *
     * @param isMainThread Whether this worker will be the main one,
     * responsible for driving iterative deepening.
     * @param pool         The worker pool this worker will belong to.
     * @return A new instance of a {@link SearchWorker}.
     */
    SearchWorker create(boolean isMainThread, WorkerPool pool);
}
C:\dev\Helios\src>(echo.   & echo // File: TimeManager.java   & type "C:\dev\Helios\src\main\java\core\contracts\TimeManager.java" ) 
 
// File: TimeManager.java 
package core.contracts;

import core.records.SearchSpec;
import core.records.TimeAllocation;

/**
 * Calculates the optimal and maximum thinking time for a single move.
 * This is a stateless service.
 */
public interface TimeManager {

    /**
     * Calculates the time allocation for the upcoming search.
     * @param spec The search specification from the GUI (containing wtime, btime, etc.).
     * @param isWhiteToMove True if it is white's turn to move, false otherwise.
     * @return A {@link TimeAllocation} record containing the optimal and maximum move times.
     */
    TimeAllocation calculate(SearchSpec spec, boolean isWhiteToMove);
}
C:\dev\Helios\src>(echo.   & echo // File: TranspositionTable.java   & type "C:\dev\Helios\src\main\java\core\contracts\TranspositionTable.java" ) 
 
// File: TranspositionTable.java 
package core.contracts;

import static core.constants.CoreConstants.*;

/**
 * Transposition-table abstraction – **zero allocations** on the hot path.
 *
 *  • {@link #probe(long)} returns the matching slot *or* the replacement victim.
 *  • Use {@link #wasHit(Entry,long)} to see whether it contained a live entry.
 */
public interface TranspositionTable {

    /* ---------- public constants ---------- */

    int ENTRIES_PER_BUCKET = 3;     // 3-way set-associative
    int MAX_AGE            = 32;    // must be power of two (5 bits)

    int FLAG_NONE  = 0;
    int FLAG_LOWER = 1;
    int FLAG_UPPER = 2;
    int FLAG_EXACT = FLAG_LOWER | FLAG_UPPER;   // == 3

    /* ---------- entry view ---------- */

    interface Entry {

        /* meta --------------------------------------------------- */
        boolean matches(long zobrist);         // 16-bit tag hit
        boolean isEmpty();                     // completely unused
        int     getAge();                      // 0-31
        int     getAgeDistance(byte tableAge);// helper for quality()

        /* packed payload ----------------------------------------- */
        int  getDepth();                       // search depth in plies
        int  getBound();                       // FLAG_LOWER / UPPER / EXACT
        int  getMove();                        // best move (0 => none)
        int  getStaticEval();                  // static evaluation
        int  getScore(int ply);                // score adjusted for mate dist
        boolean wasPv();                       // PV-node flag

        /* write-back --------------------------------------------- */
        void store(long zobrist, int flag, int depth, int move,
                   int score, int staticEval, boolean isPv,
                   int ply, byte tableAge);
    }

    /* ---------- primary ops ---------- */

    /** Returns either a live hit or the replacement victim. */
    Entry probe(long zobrist);

    /** True *iff* {@code e} is a live hit for that key. */
    default boolean wasHit(Entry e, long zobrist) {
        return e != null && e.matches(zobrist) && !e.isEmpty();
    }

    /* ---------- life-cycle ---------- */

    void resize(int megaBytes);   // discards everything
    void clear();                 // zero all buckets
    void incrementAge();          // call once per new root search
    int  hashfull();              // 0-1000 ‰
}

C:\dev\Helios\src>(echo.   & echo // File: UciHandler.java   & type "C:\dev\Helios\src\main\java\core\contracts\UciHandler.java" ) 
 
// File: UciHandler.java 
package core.contracts;

/**
 * Defines the contract for a class that handles the Universal Chess Interface (UCI)
 * command loop. An implementation of this interface is responsible for parsing
 * commands from a standard input stream (e.g., from a chess GUI) and
 * orchestrating the engine's response.
 */
public interface UciHandler {

    /**
     * Starts the main loop that continuously reads and processes UCI commands
     * until a "quit" command is received or the input stream is closed.
     */
    void runLoop();
}

C:\dev\Helios\src>(echo.   & echo // File: UciOptions.java   & type "C:\dev\Helios\src\main\java\core\contracts\UciOptions.java" ) 
 
// File: UciOptions.java 
package core.contracts;

/**
 * Defines the contract for a class that manages UCI (Universal Chess Interface)
 * options for the engine. An implementation of this interface is responsible for
 * parsing and applying option settings received from a UCI-compatible GUI.
 */
public interface UciOptions {

    /**
     * Parses a "setoption" command line and applies the given value
     * to the corresponding engine parameter.
     *
     * @param line The full "setoption ..." command line from the GUI.
     */
    void setOption(String line);

    /**
     * Prints all available UCI options to standard output in the format
     * required by the UCI protocol. This is typically sent in response
     * to the "uci" command.
     */
    void printOptions();

    /**
     * Provides access to the transposition table, allowing options
     * (like changing its size) to be applied directly.
     *
     * @return The TranspositionTable instance managed by the options handler.
     */
    TranspositionTable getTranspositionTable();

    String getOptionValue(String name);

    void attachSearch(Search s);
}
C:\dev\Helios\src>(echo.   & echo // File: WorkerPool.java   & type "C:\dev\Helios\src\main\java\core\contracts\WorkerPool.java" ) 
 
// File: WorkerPool.java 
package core.contracts;

import core.records.SearchResult;
import core.records.SearchSpec;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Thread-pool façade identical to Obsidian’s design:
 * – fixed-size pool created once
 * – work handed out via a blocking queue
 * – helpers are completely fire-and-forget
 * – stop() flips one shared AtomicBoolean
 */
public interface WorkerPool extends AutoCloseable {

    /* one-off configuration */
    void setParallelism(int threads);

    /* search life-cycle */
    CompletableFuture<SearchResult> startSearch(long[] root,
                                                SearchSpec spec,
                                                PositionFactory pf,
                                                MoveGenerator mg,
                                                Evaluator      eval,
                                                TranspositionTable tt,
                                                TimeManager    tm,
                                                InfoHandler    ih);

    void stopSearch();
    AtomicBoolean getStopFlag();
    long totalNodes();

    /* infra */
    @Override void close();

    long getOptimumMs();
    long getMaximumMs();
}

C:\dev\Helios\src>(echo.   & echo // File: EvaluatorImpl.java   & type "C:\dev\Helios\src\main\java\core\impl\EvaluatorImpl.java" ) 
 
// File: EvaluatorImpl.java 
package core.impl;

import core.contracts.Evaluator;
import core.contracts.PositionFactory;

/**
 * Very small but noticeably stronger evaluation function.
 * Completely stateless, allocation-free and thread-safe.
 */
public final class EvaluatorImpl implements Evaluator {

    /* ----------------------------------------------------------------------
     *                         Static pre-computed data
     * ------------------------------------------------------------------- */

    /** Material values in centipawns, aligned with {@link PositionFactory} indices. */
    private static final int[] VALUE = {
            100, 320, 330, 500, 900, 0,   // White P, N, B, R, Q, K
            100, 320, 330, 500, 900, 0    // Black p, n, b, r, q, k
    };

    /** Bishop-pair bonus (per side). */
    private static final int BISHOP_PAIR_BONUS = 30;

    /** Pawn-structure penalties. */
    private static final int DOUBLED_PAWN_PENALTY   = 15;
    private static final int ISOLATED_PAWN_PENALTY  = 10;

    /** Central-square bonus. */
    private static final int KNIGHT_CENTER_BONUS = 10;
    private static final int ROOK_CENTER_BONUS   = 10;
    private static final int OTHER_CENTER_BONUS  = 5;

    /** Masks for the eight files (a-file = 0). */
    private static final long[] FILE_MASKS = {
            0x0101010101010101L, 0x0202020202020202L,
            0x0404040404040404L, 0x0808080808080808L,
            0x1010101010101010L, 0x2020202020202020L,
            0x4040404040404040L, 0x8080808080808080L
    };

    /** 16 central squares: c-d-e-f files on ranks 3-6 (0-based). */
    private static final long CENTER_16 =
            0x00003C3C3C3C0000L; //   0b0000000000000000001111001111001111000000000000000000000000000000

    /* ────────────────────────────────────────────────────────────────────
     *                Very small Piece-Square Tables (PST)
     *
     *  Tables are given from White’s point of view, starting at a1 = 0.
     *  For Black we mirror the square index with (sq ^ 56).
     *  Source: Slightly smoothed version of the classical “Simplified
     *          Evaluation Function” PSTs by Tomasz Michniewski.
     * ─────────────────────────────────────────────────────────────────── */

    private static final int[] PST_PAWN = {
            0,  0,  0,  0,  0,  0,  0,  0,
            5, 10, 10,-20,-20, 10, 10,  5,
            5, -5,-10,  0,  0,-10, -5,  5,
            0,  0,  0, 20, 20,  0,  0,  0,
            5,  5, 10, 25, 25, 10,  5,  5,
            10, 10, 20, 30, 30, 20, 10, 10,
            50, 50, 50, 50, 50, 50, 50, 50,
            0,  0,  0,  0,  0,  0,  0,  0
    };

    private static final int[] PST_KNIGHT = {
            -50,-40,-30,-30,-30,-30,-40,-50,
            -40,-20,  0,  5,  5,  0,-20,-40,
            -30,  5, 10, 15, 15, 10,  5,-30,
            -30,  0, 15, 20, 20, 15,  0,-30,
            -30,  5, 15, 20, 20, 15,  5,-30,
            -30,  0, 10, 15, 15, 10,  0,-30,
            -40,-20,  0,  0,  0,  0,-20,-40,
            -50,-40,-30,-30,-30,-30,-40,-50
    };

    private static final int[] PST_BISHOP = {
            -20,-10,-10,-10,-10,-10,-10,-20,
            -10,  5,  0,  0,  0,  0,  5,-10,
            -10, 10, 10, 10, 10, 10, 10,-10,
            -10,  0, 10, 10, 10, 10,  0,-10,
            -10,  5,  5, 10, 10,  5,  5,-10,
            -10,  0,  5, 10, 10,  5,  0,-10,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -20,-10,-10,-10,-10,-10,-10,-20
    };

    private static final int[] PST_ROOK = {
            0,  0,  5, 10, 10,  5,  0,  0,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            5, 10, 10, 10, 10, 10, 10,  5,
            0,  0,  0,  0,  0,  0,  0,  0
    };

    private static final int[] PST_QUEEN = {
            -20,-10,-10, -5, -5,-10,-10,-20,
            -10,  0,  5,  0,  0,  0,  0,-10,
            -10,  5,  5,  5,  5,  5,  0,-10,
            0,  0,  5,  5,  5,  5,  0, -5,
            -5,  0,  5,  5,  5,  5,  0, -5,
            -10,  0,  5,  5,  5,  5,  0,-10,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -20,-10,-10, -5, -5,-10,-10,-20
    };

    private static final int[] PST_KING = {
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -20,-30,-30,-40,-40,-30,-30,-20,
            -10,-20,-20,-20,-20,-20,-20,-10,
            20, 20,  0,  0,  0,  0, 20, 20,
            20, 30, 10,  0,  0, 10, 30, 20
    };

    /* For easy PST lookup. */
    private static final int[][] PST = {
            PST_PAWN,      // P
            PST_KNIGHT,    // N
            PST_BISHOP,    // B
            PST_ROOK,      // R
            PST_QUEEN,     // Q
            PST_KING       // K
    };

    /* ----------------------------------------------------------------------
     *                               Evaluation
     * ------------------------------------------------------------------- */

    @Override
    public int evaluate(long[] bb) {

        int white = 0;
        int black = 0;

        /* ========= 1. Material + Piece-Square tables ========= */
        for (int p = PositionFactory.WP; p <= PositionFactory.WK; ++p) {
            long pieces = bb[p];
            int type = p - PositionFactory.WP;           // 0-5
            while (pieces != 0) {
                long sqBit = pieces & -pieces;           // extract LS1B
                int sq = Long.numberOfTrailingZeros(sqBit);
                pieces -= sqBit;

                white += VALUE[p] + PST[type][sq];
                /* Central bonus */
                if ((CENTER_16 & sqBit) != 0) {
                    white += (type == 1 || type == 3) ? KNIGHT_CENTER_BONUS : OTHER_CENTER_BONUS; // N,R = 10, else 5
                }
            }
        }

        for (int p = PositionFactory.BP; p <= PositionFactory.BK; ++p) {
            long pieces = bb[p];
            int type = p - PositionFactory.BP;           // 0-5
            while (pieces != 0) {
                long sqBit = pieces & -pieces;
                int sq = Long.numberOfTrailingZeros(sqBit);
                pieces -= sqBit;

                /* Mirror square for PST lookup */
                int mirrorSq = sq ^ 56;
                black += VALUE[p] + PST[type][mirrorSq];

                if ((CENTER_16 & sqBit) != 0) {
                    black += (type == 1 || type == 3) ? KNIGHT_CENTER_BONUS : OTHER_CENTER_BONUS;
                }
            }
        }

        /* ========= 2. Bishop pair ========= */
        if (Long.bitCount(bb[PositionFactory.WB]) >= 2) white += BISHOP_PAIR_BONUS;
        if (Long.bitCount(bb[PositionFactory.BB]) >= 2) black += BISHOP_PAIR_BONUS;

        /* ========= 3. Pawn structure (doubled / isolated) ========= */
        white -= pawnStructurePenalty(bb[PositionFactory.WP]);
        black -= pawnStructurePenalty(bb[PositionFactory.BP]);

        /* ========= 4. Side to move ========= */
        int diff = white - black;            // >0: White is better
        long meta = bb[PositionFactory.META];
        return PositionFactory.whiteToMove(meta) ? diff : -diff;
    }

    /**
     * Very small pawn-structure assessment.
     * Counts doubled and isolated pawns only – cheap yet effective.
     */
    private static int pawnStructurePenalty(long pawns) {
        int penalty = 0;

        for (int file = 0; file < 8; ++file) {
            long pawnsOnFile = pawns & FILE_MASKS[file];
            int cnt = Long.bitCount(pawnsOnFile);

            if (cnt > 1) {
                penalty += DOUBLED_PAWN_PENALTY * (cnt - 1);
            }
            if (cnt == 1) {
                boolean left  = file > 0 && (pawns & FILE_MASKS[file - 1]) != 0;
                boolean right = file < 7 && (pawns & FILE_MASKS[file + 1]) != 0;
                if (!left && !right) {
                    penalty += ISOLATED_PAWN_PENALTY;
                }
            }
        }
        return penalty;
    }

    @Override
    public void reset() {
        /* Stateless – nothing to clear. */
    }
}

C:\dev\Helios\src>(echo.   & echo // File: LazySmpSearchWorkerImpl.java   & type "C:\dev\Helios\src\main\java\core\impl\LazySmpSearchWorkerImpl.java" ) 
 
// File: LazySmpSearchWorkerImpl.java 
package core.impl;

import core.constants.CoreConstants;
import core.contracts.TranspositionTable;
import core.contracts.TranspositionTable.Entry;
import core.records.SearchInfo;
import core.records.SearchResult;
import core.records.SearchSpec;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import static core.constants.CoreConstants.*;

/**
 * Lazy / SMP worker **with a fully-featured Transposition Table**.
 *
 * The TT layer matches Stockfish’ overwrite rules but uses the
 * zero-allocation API:
 *
 *   • {@link TranspositionTable#probe(long)} returns a *live view*
 *     of the chosen slot (hit or victim).
 *   • No new objects are created while searching.
 */
public final class LazySmpSearchWorkerImpl implements Runnable,
        SearchWorker {

    /* immutable ctor params */
    private final LazySmpWorkerPoolImpl pool;
    private final boolean               isMain;

    /* per-search state -------------------------------------------------- */
    private long[]           rootBoard;
    private SearchSpec       spec;
    private PositionFactory  pf;
    private MoveGenerator    mg;
    private Evaluator        eval;
    private TimeManager      tm;
    private InfoHandler      ih;
    private TranspositionTable tt;

    private int   lastScore;
    private long  elapsedMs;
    private boolean mate;
    private long  searchStartMs;
    private long  optimumMs;
    private long  maximumMs;
    private int   hashFull;               // sampled each “info” print

    /* scratch ----------------------------------------------------------- */
    private final SearchFrame[] frames = new SearchFrame[MAX_PLY + 2];
    long                nodes;
    int                 completedDepth;
    private int         bestMove;
    private int         ponderMove;
    private List<Integer> pv = new ArrayList<>();

    /* small PV helper --------------------------------------------------- */
    private static final class SearchFrame {
        int[] pv = new int[MAX_PLY];
        int   len;
        void set(int[] child, int clen, int move) {
            pv[0] = move;
            System.arraycopy(child, 0, pv, 1, clen);
            len = clen + 1;
        }
    }

    /* move-list scratch ------------------------------------------------- */
    private static final int LIST_CAP = 256;
    private final int[][] moves = new int[MAX_PLY + 2][LIST_CAP];

    /* ─────────────────────────────────────────────────────────────────── */
    public LazySmpSearchWorkerImpl(boolean isMain,
                                   LazySmpWorkerPoolImpl pool) {
        this.isMain = isMain;
        this.pool   = pool;
        for (int i = 0; i < frames.length; ++i)
            frames[i] = new SearchFrame();
    }

    /* ═════════════════ SearchWorker API ═══════════════════════════════ */

    @Override
    public void prepareForSearch(long[] bb, SearchSpec spec,
                                 PositionFactory pf, MoveGenerator mg,
                                 Evaluator ev, TranspositionTable tt,
                                 TimeManager tm) {

        this.rootBoard = bb.clone();
        this.spec      = spec;
        this.pf        = pf;
        this.mg        = mg;
        this.eval      = ev;
        this.tm        = tm;
        this.tt        = tt;
        this.optimumMs = ((LazySmpWorkerPoolImpl) pool).getOptimumMs();
        this.maximumMs = ((LazySmpWorkerPoolImpl) pool).getMaximumMs();

        /* → start a new TT age for this search */
        tt.incrementAge();

        /* fresh state --------------------------------------------------- */
        bestMove = ponderMove = 0;
        lastScore = 0;  mate = false;
        completedDepth = 0;  nodes = 0;
        pv.clear();
    }

    @Override public void setInfoHandler(InfoHandler ih){ this.ih = ih; }

    @Override
    public SearchResult getSearchResult() {
        return new SearchResult(
                bestMove, ponderMove, pv,
                lastScore, mate,
                completedDepth, nodes, elapsedMs);
    }

    /* ═════════════════ Runnable – main worker loop ════════════════════ */

    @Override
    public void run() {

        searchStartMs = System.currentTimeMillis();
        AtomicBoolean stop  = pool.getStopFlag();
        final long    t0    = searchStartMs;
        final int     limit = spec.depth() > 0 ? spec.depth() : 64;

        final long[] board = rootBoard;                // local alias

        for (int depth = 1; depth <= limit; ++depth) {

            nodes = 0;

            if (stop.get()) break;

            int score = alphaBeta(board, depth, -SCORE_INF, SCORE_INF, 0, stop);

            /* bail-out protection */
            if (stop.get() || frames[0].len == 0) break;

            /* finished iteration – publish result ---------------------- */
            lastScore      = score;
            mate           = Math.abs(score) >= SCORE_MATE_IN_MAX_PLY - 100;
            elapsedMs      = System.currentTimeMillis() - t0;
            completedDepth = depth;

            pv = new ArrayList<>(frames[0].len);
            for (int i = 0; i < frames[0].len; ++i)
                pv.add(frames[0].pv[i]);

            bestMove   = pv.isEmpty() ? 0 : pv.get(0);
            ponderMove = pv.size()  > 1 ? pv.get(1) : 0;

            pool.report(this);

            /* optional “info …” on the main thread --------------------- */
            if (isMain && ih != null) {
                long nodesSoFar = pool.nodes.get();
                long msSoFar    = System.currentTimeMillis() - t0;
                long nps        = msSoFar > 0 ? nodesSoFar * 1000 / msSoFar : 0;
                hashFull        = tt.hashfull();

                ih.onInfo(new SearchInfo(
                        depth, 0, 1,
                        score, mate,
                        nodesSoFar, nps, msSoFar,
                        pv,
                        hashFull,
                        0));
            }

            /* stop conditions ------------------------------------------ */
            if (mate) break;
            long elapsed = System.currentTimeMillis() - t0;

            if (elapsed >= maximumMs)       stop.set(true);
            else if (elapsed >= optimumMs)  stop.set(true);
        }
    }

    /* ════════════════ α-β + quiescence (TT aware) ═════════════════════ */

    private int alphaBeta(long[] bb, int depth,
                          int alpha, int beta,
                          int ply,
                          AtomicBoolean stop) {

        frames[ply].len = 0;

        final int alphaOrig = alpha;
        final long key      = pf.zobrist(bb);

        /* ---- TT probe ------------------------------------------------ */
        Entry te = tt.probe(key);
        boolean hit = tt.wasHit(te, key);
        int     ttMove = 0;

        if (hit) {
            int eDepth = te.getDepth();
            int eFlag  = te.getBound();
            int eScore = te.getScore(ply);
            ttMove     = te.getMove();

            if (eDepth >= depth) {
                switch (eFlag) {
                    case TranspositionTable.FLAG_EXACT -> {
                        if (ply == 0 && ttMove != 0) {
                            frames[0].pv[0] = ttMove;
                            frames[0].len   = 1;
                        }
                        return eScore;
                    }
                    case TranspositionTable.FLAG_LOWER -> alpha = Math.max(alpha, eScore);
                    case TranspositionTable.FLAG_UPPER -> beta  = Math.min(beta,  eScore);
                }
                if (alpha >= beta) return eScore;
            }
        }

        /* ---- leaf → quiescence -------------------------------------- */
        if (depth == 0)
            return quiescence(bb, alpha, beta, ply, stop);

        nodes++;
        if ((nodes & 127) == 0 && timeUp(stop, ply, 0))
            return ply == 0 ? 0 : alpha;

        /* ---- move generation ---------------------------------------- */
        int[] list   = moves[ply];
        boolean inCheck = PositionFactory.whiteToMove(bb[PositionFactory.META])
                ? mg.kingAttacked(bb, true)
                : mg.kingAttacked(bb, false);

        int nMoves = inCheck
                ? mg.generateEvasions(bb, list, 0)
                : mg.generateQuiets(bb, list,
                mg.generateCaptures(bb, list, 0));

        /* push TT move to front */
        if (ttMove != 0) {
            for (int i = 0; i < nMoves; i++)
                if (list[i] == ttMove) { list[i] = list[0]; list[0] = ttMove; break; }
        }

        int bestScore = -SCORE_INF;
        int bestMove  = 0;

        for (int i = 0; i < nMoves; i++) {
            int mv = list[i];
            if (!pf.makeMoveInPlace(bb, mv, mg)) continue;

            int score = -alphaBeta(bb, depth - 1, -beta, -alpha, ply + 1, stop);
            pf.undoMoveInPlace(bb);
            if (stop.get()) return 0;

            if (score > bestScore) {
                bestScore = score;
                bestMove  = mv;
                frames[ply].set(frames[ply + 1].pv, frames[ply + 1].len, mv);
            }

            if (score > alpha) {
                alpha = score;
                if (alpha >= beta) break;
            }

            if ((nodes & 127) == 0 && timeUp(stop, ply, i+1)) break;
        }

        if (nMoves == 0)
            return inCheck ? -(SCORE_MATE_IN_MAX_PLY - ply) : SCORE_STALEMATE;

        /* ---- store result in TT ------------------------------------- */
        int flag = (bestScore >= beta)        ? TranspositionTable.FLAG_LOWER
                : (bestScore <= alphaOrig)   ? TranspositionTable.FLAG_UPPER
                : TranspositionTable.FLAG_EXACT;

        te.store(key, flag, depth, bestMove, bestScore,
                SCORE_NONE, /*isPv*/ false, ply, tableAge());

        return bestScore;
    }

    /* ----------------------------------------------------------------- */

    private int quiescence(long[] bb,
                           int alpha,
                           int beta,
                           int ply,
                           AtomicBoolean stop) {

        if (ply >= CoreConstants.QSEARCH_MAX_PLY)
            return eval.evaluate(bb);

        nodes++;
        if ((nodes & 127) == 0 && timeUp(stop, ply, 0))
            return alpha;

        /* ---- TT probe (depth == 0) ---------------------------------- */
        final long key = pf.zobrist(bb);
        Entry te = tt.probe(key);
        boolean hit = tt.wasHit(te, key);

        if (hit && te.getDepth() == 0) {
            int s   = te.getScore(ply);
            switch (te.getBound()) {
                case TranspositionTable.FLAG_EXACT  -> { return s; }
                case TranspositionTable.FLAG_LOWER  -> alpha = Math.max(alpha, s);
                case TranspositionTable.FLAG_UPPER  -> beta  = Math.min(beta,  s);
            }
            if (alpha >= beta) return s;
        }

        int standPat = eval.evaluate(bb);
        if (standPat >= beta) {
            te.store(key, TranspositionTable.FLAG_LOWER, 0, 0,
                    standPat, SCORE_NONE, false, ply, tableAge());
            return standPat;
        }
        if (standPat > alpha) alpha = standPat;

        int[] list = moves[ply];
        boolean inCheck = PositionFactory.whiteToMove(bb[PositionFactory.META])
                ? mg.kingAttacked(bb, true)
                : mg.kingAttacked(bb, false);

        int nMoves = inCheck
                ? mg.generateEvasions(bb, list, 0)
                : mg.generateCaptures(bb, list, 0);

        int bestScore = standPat;
        int bestMove  = 0;

        for (int i = 0; i < nMoves; i++) {
            int mv = list[i];
            if (!pf.makeMoveInPlace(bb, mv, mg)) continue;

            int score = -quiescence(bb, -beta, -alpha, ply + 1, stop);
            pf.undoMoveInPlace(bb);
            if (stop.get()) return alpha;

            if (score > bestScore) {
                bestScore = score;
                bestMove  = mv;
            }
            if (score >= beta) {
                te.store(key, TranspositionTable.FLAG_LOWER, 0, bestMove,
                        score, SCORE_NONE, false, ply, tableAge());
                return score;
            }
            if (score > alpha) alpha = score;
        }

        int flag = (bestScore > standPat)
                ? TranspositionTable.FLAG_EXACT
                : TranspositionTable.FLAG_UPPER;

        te.store(key, flag, 0, bestMove, bestScore,
                SCORE_NONE, false, ply, tableAge());

        return bestScore;
    }

    /* ----------------------------------------------------------------- */

    private byte tableAge() {
        return ((core.impl.TranspositionTableImpl) tt).getCurrentAge();
    }

    /* unchanged helper ------------------------------------------------- */
    private boolean timeUp(AtomicBoolean stop, int ply, int seenMoves) {
        if (stop.get()) return true;
        long elapsed = System.currentTimeMillis() - searchStartMs;
        if (elapsed >= maximumMs) { stop.set(true); return true; }
        return ply == 0 && seenMoves > 0 && elapsed >= optimumMs;
    }

    /* unused interface stubs */
    @Override public void terminate(){}
    @Override public void join() throws InterruptedException{}
}

C:\dev\Helios\src>(echo.   & echo // File: LazySmpWorkerPoolImpl.java   & type "C:\dev\Helios\src\main\java\core\impl\LazySmpWorkerPoolImpl.java" ) 
 
// File: LazySmpWorkerPoolImpl.java 
package core.impl;

import core.constants.CoreConstants;
import core.contracts.*;
import core.records.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

/** Fixed-size pool for Lazy-SMP searchers – now with persistent threads */
public final class LazySmpWorkerPoolImpl implements WorkerPool {

    private final SearchWorkerFactory factory;
    private int parallelism;

    /** immutable workers reused search-after-search */
    private final List<LazySmpSearchWorkerImpl> workers = new ArrayList<>();

    /** threads live forever inside this executor */
    private ExecutorService executor;

    /* shared state */
    final AtomicBoolean stopFlag = new AtomicBoolean();
    final AtomicLong    nodes    = new AtomicLong();

    /* timing */
    private volatile long optimumTimeMs = Long.MAX_VALUE;
    private volatile long maximumTimeMs = Long.MAX_VALUE;

    public LazySmpWorkerPoolImpl(int threads, SearchWorkerFactory f) {
        this.factory      = f;
        this.parallelism  = threads;
        resizePool();                         // builds workers & executor
    }
    public LazySmpWorkerPoolImpl(SearchWorkerFactory f) { this(1, f); }

    /* ── API ─────────────────────────────────────────────────── */

    @Override public synchronized void setParallelism(int threads) {
        if (threads == parallelism) return;
        close();                              // drop executor & workers
        parallelism = threads;
        resizePool();
    }

    /** builds fresh workers and a new fixed-thread pool */
    private void resizePool() {
        // dispose previous executor if any
        if (executor != null) executor.shutdownNow();

        workers.clear();
        for (int i = 0; i < parallelism; i++)
            workers.add((LazySmpSearchWorkerImpl) factory.create(i == 0, this));

        executor = Executors.newFixedThreadPool(
                parallelism,
                r -> new Thread(r, "LSMP-" + UUID.randomUUID()));
    }

    @Override
    public CompletableFuture<SearchResult> startSearch(
            long[] root, SearchSpec spec,
            PositionFactory pf, MoveGenerator mg, Evaluator ev,
            TranspositionTable tt, TimeManager tm, InfoHandler ih)
    {
        deriveTimeLimits(spec, tm,
                PositionFactory.whiteToMove(root[PositionFactory.META]));

        stopFlag.set(false);
        nodes.set(0);

        CountDownLatch finished = new CountDownLatch(workers.size());

        for (int i = 0; i < workers.size(); i++) {
            LazySmpSearchWorkerImpl w = workers.get(i);

            w.prepareForSearch(root, spec, pf, mg, ev, tt, tm);
            w.setInfoHandler((i == 0) ? ih : null);

            executor.submit(() -> {            // threads are persistent
                w.run();                       // but search object is fresh
                finished.countDown();
            });
        }

        /* future completes once all workers finished and vote() chose best line */
        return CompletableFuture.supplyAsync(() -> {
            try { finished.await(); } catch (InterruptedException ignored) {}
            return vote();
        });
    }

    /* called by workers each iteration */
    void report(LazySmpSearchWorkerImpl w) { nodes.addAndGet(w.nodes); }

    /* enhanced tie-break identical to the C++ reference */
    /** choose best PV, but return the aggregate node count of *all* workers */
    private SearchResult vote() {

        // ── 1. collect only the workers that actually finished a depth ─────────
        List<LazySmpSearchWorkerImpl> finished = workers.stream()
                .filter(w -> w.getSearchResult().depth() > 0)
                .toList();

        if (finished.isEmpty())
            return new SearchResult(0, 0, List.of(), 0, false, 0, 0, 0);

        // ── 2. Stockfish-style tie-break to pick the PV we’ll return ───────────
        LazySmpSearchWorkerImpl best = finished.get(0);
        long bestVote = Long.MIN_VALUE;

        int minScore = finished.stream()
                .mapToInt(w -> w.getSearchResult().scoreCp())
                .min().orElse(0);

        for (LazySmpSearchWorkerImpl w : finished) {
            SearchResult sr = w.getSearchResult();
            long v = (long) (sr.scoreCp() - minScore + 9) * sr.depth();

            if (v > bestVote) {
                best = w;
                bestVote = v;
            }
        }

        SearchResult br = best.getSearchResult();

        // ── 3. NEW: use the *aggregate* node counter collected via report() ────
        long allNodes = nodes.get();   // includes every helper thread

        return new SearchResult(
                br.bestMove(),
                br.ponderMove(),
                br.pv(),
                br.scoreCp(),
                br.mateFound(),
                br.depth(),
                allNodes,        // ← pool-wide total, not just the winner’s
                br.timeMs()
        );
    }

    /* ── life-cycle helpers ─────────────────────────────────── */

    @Override public void stopSearch() { stopFlag.set(true); }

    @Override public AtomicBoolean getStopFlag() { return stopFlag; }

    @Override public long totalNodes() { return nodes.get(); }

    @Override public synchronized void close() {
        stopFlag.set(true);
        if (executor != null) executor.shutdownNow();
        workers.clear();
    }

    public long getOptimumMs() { return optimumTimeMs; }
    public long getMaximumMs() { return maximumTimeMs; }

    private void deriveTimeLimits(SearchSpec spec, TimeManager tm, boolean white) {
        TimeAllocation ta = tm.calculate(spec, white);
        optimumTimeMs = Math.min(ta.optimal(), ta.maximum());
        maximumTimeMs = ta.maximum();
    }
}

C:\dev\Helios\src>(echo.   & echo // File: MoveGeneratorImpl.java   & type "C:\dev\Helios\src\main\java\core\impl\MoveGeneratorImpl.java" ) 
 
// File: MoveGeneratorImpl.java 
package core.impl;

import static core.impl.PreCompMoveGenTables.*;
import static core.contracts.PositionFactory.*;

import core.contracts.*;

public final class MoveGeneratorImpl implements MoveGenerator {
  /* ── bit-board constants ─────────────────────────────────────── */
  static final long FILE_A = 0x0101_0101_0101_0101L;
  static final long FILE_H = FILE_A << 7;

  private static final long RANK_1 = 0xFFL;
  private static final long RANK_2 = RANK_1 << 8;
  private static final long RANK_3 = RANK_1 << 16;
  private static final long RANK_6 = RANK_1 << 40;
  private static final long RANK_7 = RANK_1 << 48;
  private static final long RANK_8 = RANK_1 << 56;

  private static final int MOVER_SHIFT = 16;

  @Override
  public int generateCaptures(long[] bb, int[] mv, int n) {
    return whiteToMove(bb[META])
            ? genCapturesWhite(bb, mv, n)
            : genCapturesBlack(bb, mv, n);
  }

  /* -------- WHITE to move -------------------------------------- */
  private static int genCapturesWhite(long[] bb, int[] mv, int n) {

    /* inlined piece IDs – now compile-time constants */
    final int usP = WP, usN = WN, usB = WB, usR = WR, usQ = WQ, usK = WK;
    /* aggregate bitboards (all constant folds, no “?:” branches) */
    final long own   = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long enemy = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long occ   = own | enemy;
    final long captMask = enemy;
    final long allCapt  = captMask;          // alias (keeps old code unchanged)

    /* === copy the body of your old generateCaptures() verbatim ==
       ↓↓↓  keep every helper call, but pass “true” for ‘white’  ↓↓↓ */
    n  = addPawnCaptures(bb, /*white=*/true,  occ, enemy, mv, n, usP);
    n  = addPawnPushes   (bb[usP], true, occ, mv, n, usP,
            /*Q?*/true, /*RBN?*/false,
            /*quiet?*/false, /*double?*/false);
    n  = addKnightMoves(bb[usN], allCapt, mv, n, usN);

    long bishops = bb[usB];
    while (bishops != 0) {
      int from = Long.numberOfTrailingZeros(bishops);
      bishops &= bishops - 1;
      long tgt = bishopAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usB);
    }

    long rooks = bb[usR];
    while (rooks != 0) {
      int from = Long.numberOfTrailingZeros(rooks);
      rooks &= rooks - 1;
      long tgt = rookAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usR);
    }

    long queens = bb[usQ];
    while (queens != 0) {
      int from = Long.numberOfTrailingZeros(queens);
      queens &= queens - 1;
      long tgt = queenAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usQ);
    }

    n  = addKingMovesAndCastle(bb, /*white=*/true,  occ,
            /*enemySeen=*/0L, captMask, 0L,
            mv, n, usK);
    return n;
  }

  /* -------- BLACK to move -------------------------------------- */
  private static int genCapturesBlack(long[] bb, int[] mv, int n) {

    final int usP = BP, usN = BN, usB = BB, usR = BR, usQ = BQ, usK = BK;
    final long own   = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long enemy = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long occ   = own | enemy;
    final long captMask = enemy;
    final long allCapt  = captMask;

    n  = addPawnCaptures(bb, /*white=*/false, occ, enemy, mv, n, usP);
    n  = addPawnPushes   (bb[usP], false, occ, mv, n, usP,
            /*Q?*/true, /*RBN?*/false,
            /*quiet?*/false, /*double?*/false);
    n  = addKnightMoves(bb[usN], allCapt, mv, n, usN);

    long bishops = bb[usB];
    while (bishops != 0) {
      int from = Long.numberOfTrailingZeros(bishops);
      bishops &= bishops - 1;
      long tgt = bishopAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usB);
    }

    long rooks = bb[usR];
    while (rooks != 0) {
      int from = Long.numberOfTrailingZeros(rooks);
      rooks &= rooks - 1;
      long tgt = rookAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usR);
    }

    long queens = bb[usQ];
    while (queens != 0) {
      int from = Long.numberOfTrailingZeros(queens);
      queens &= queens - 1;
      long tgt = queenAtt(occ, from) & allCapt;
      n = emitSliderMoves(mv, n, from, tgt, usQ);
    }

    n  = addKingMovesAndCastle(bb, /*white=*/false, occ,
            /*enemySeen=*/0L, captMask, 0L,
            mv, n, usK);
    return n;
  }

  @Override
  public int generateQuiets(long[] bb, int[] mv, int n) {
    return whiteToMove(bb[META])
            ? genQuietsWhite(bb, mv, n)
            : genQuietsBlack(bb, mv, n);
  }

  private static int genQuietsWhite(long[] bb, int[] mv, int n) {

    final int usP = WP, usN = WN, usB = WB, usR = WR, usQ = WQ, usK = WK;
    final long own   = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long enemy = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long occ   = own | enemy;

    long quietMask = ~occ;
    long allQuiet  = quietMask;

    n = addPawnPushes(bb[usP], /*white=*/true,  occ, mv, n, usP,
            /*Q?*/false, /*RBN?*/true,
            /*quiet?*/true,  /*double?*/true);
    n = addKnightMoves(bb[usN], allQuiet, mv, n, usN);

    for (long bishops = bb[usB]; bishops != 0; ) {
      int from = Long.numberOfTrailingZeros(bishops);
      bishops &= bishops - 1;
      long tgt = bishopAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usB);
    }
    for (long rooks = bb[usR]; rooks != 0; ) {
      int from = Long.numberOfTrailingZeros(rooks);
      rooks &= rooks - 1;
      long tgt = rookAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usR);
    }
    for (long queens = bb[usQ]; queens != 0; ) {
      int from = Long.numberOfTrailingZeros(queens);
      queens &= queens - 1;
      long tgt = queenAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usQ);
    }

    n = addKingMovesAndCastle(bb, /*white=*/true,  occ,
            /*enemySeen*/0L, /*captMask*/0L,
            quietMask, mv, n, usK);
    return n;
  }

  private static int genQuietsBlack(long[] bb, int[] mv, int n) {

    final int usP = BP, usN = BN, usB = BB, usR = BR, usQ = BQ, usK = BK;
    final long own   = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long enemy = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long occ   = own | enemy;

    long quietMask = ~occ;
    long allQuiet  = quietMask;

    n = addPawnPushes(bb[usP], /*white=*/false, occ, mv, n, usP,
            /*Q?*/false, /*RBN?*/true,
            /*quiet?*/true,  /*double?*/true);
    n = addKnightMoves(bb[usN], allQuiet, mv, n, usN);

    for (long bishops = bb[usB]; bishops != 0; ) {
      int from = Long.numberOfTrailingZeros(bishops);
      bishops &= bishops - 1;
      long tgt = bishopAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usB);
    }
    for (long rooks = bb[usR]; rooks != 0; ) {
      int from = Long.numberOfTrailingZeros(rooks);
      rooks &= rooks - 1;
      long tgt = rookAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usR);
    }
    for (long queens = bb[usQ]; queens != 0; ) {
      int from = Long.numberOfTrailingZeros(queens);
      queens &= queens - 1;
      long tgt = queenAtt(occ, from) & allQuiet;
      n = emitSliderMoves(mv, n, from, tgt, usQ);
    }

    n = addKingMovesAndCastle(bb, /*white=*/false, occ,
            /*enemySeen*/0L, /*captMask*/0L,
            quietMask, mv, n, usK);
    return n;
  }

  @Override
  public int generateEvasions(long[] bb, int[] mv, int n) {
    return whiteToMove(bb[META])
            ? genEvasionsWhite(bb, mv, n)
            : genEvasionsBlack(bb, mv, n);
  }

  private static int genEvasionsWhite(long[] bb, int[] mv, int n) {

    final int usP = WP, usN = WN, usB = WB, usR = WR, usQ = WQ, usK = WK;
    final long own   = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long enemy = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long occ   = own | enemy;

    int  kSq      = Long.numberOfTrailingZeros(bb[usK]);
    long checkers = attackersToSquare(bb, occ, kSq, /*usIsWhite=*/true);
    long dblCheck = checkers & (checkers - 1);

    if (dblCheck != 0) {                           // king must move
      long kingMoves = KING_ATK[kSq] & ~own;
      while (kingMoves != 0) {
        int to = Long.numberOfTrailingZeros(kingMoves);
        kingMoves &= kingMoves - 1;
        mv[n++] = mv(kSq, to, 0, usK);
      }
      return n;
    }

    int  checkerSq = Long.numberOfTrailingZeros(checkers);
    long target    = checkers | between(kSq, checkerSq);

    long kingTgt = KING_ATK[kSq] & ~own;
    while (kingTgt != 0) {
      int to = Long.numberOfTrailingZeros(kingTgt);
      kingTgt &= kingTgt - 1;
      mv[n++] = mv(kSq, to, 0, usK);
    }

    n = addPawnCapturesTarget(bb, /*white=*/true,  occ, enemy, mv, n, usP, target);
    n = addPawnPushBlocks  (bb[usP], /*white=*/true,  occ, mv, n, usP, target);

    n = addKnightEvasions(bb[usN], target, mv, n, usN);

    for (long sliders = bb[usB] | bb[usR] | bb[usQ]; sliders != 0; ) {
      int from = Long.numberOfTrailingZeros(sliders);
      sliders &= sliders - 1;

      long ray, piece;
      if ((bb[usB] & (1L << from)) != 0) {         // bishop
        ray   = bishopAtt(occ, from);
        piece = usB;
      } else if ((bb[usR] & (1L << from)) != 0) {  // rook
        ray   = rookAtt(occ, from);
        piece = usR;
      } else {                                     // queen
        ray   = queenAtt(occ, from);
        piece = usQ;
      }
      long tgt = ray & target;
      n = emitSliderMoves(mv, n, from, tgt, (int) piece);
    }

    n = addEnPassantEvasions(bb, /*white=*/true,  mv, n, usP, checkerSq, checkers);
    return n;
  }

  private static int genEvasionsBlack(long[] bb, int[] mv, int n) {

    final int usP = BP, usN = BN, usB = BB, usR = BR, usQ = BQ, usK = BK;
    final long own   = bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK];
    final long enemy = bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK];
    final long occ   = own | enemy;

    int  kSq      = Long.numberOfTrailingZeros(bb[usK]);
    long checkers = attackersToSquare(bb, occ, kSq, /*usIsWhite=*/false);
    long dblCheck = checkers & (checkers - 1);

    if (dblCheck != 0) {
      long kingMoves = KING_ATK[kSq] & ~own;
      while (kingMoves != 0) {
        int to = Long.numberOfTrailingZeros(kingMoves);
        kingMoves &= kingMoves - 1;
        mv[n++] = mv(kSq, to, 0, usK);
      }
      return n;
    }

    int  checkerSq = Long.numberOfTrailingZeros(checkers);
    long target    = checkers | between(kSq, checkerSq);

    long kingTgt = KING_ATK[kSq] & ~own;
    while (kingTgt != 0) {
      int to = Long.numberOfTrailingZeros(kingTgt);
      kingTgt &= kingTgt - 1;
      mv[n++] = mv(kSq, to, 0, usK);
    }

    n = addPawnCapturesTarget(bb, /*white=*/false, occ, enemy, mv, n, usP, target);
    n = addPawnPushBlocks  (bb[usP], /*white=*/false, occ, mv, n, usP, target);

    n = addKnightEvasions(bb[usN], target, mv, n, usN);

    for (long sliders = bb[usB] | bb[usR] | bb[usQ]; sliders != 0; ) {
      int from = Long.numberOfTrailingZeros(sliders);
      sliders &= sliders - 1;

      long ray, piece;
      if ((bb[usB] & (1L << from)) != 0) {
        ray   = bishopAtt(occ, from);
        piece = usB;
      } else if ((bb[usR] & (1L << from)) != 0) {
        ray   = rookAtt(occ, from);
        piece = usR;
      } else {
        ray   = queenAtt(occ, from);
        piece = usQ;
      }
      long tgt = ray & target;
      n = emitSliderMoves(mv, n, from, tgt, (int) piece);
    }

    n = addEnPassantEvasions(bb, /*white=*/false, mv, n, usP, checkerSq, checkers);
    return n;
  }

  @Override
  public boolean castleLegal(long[] bb, int from, int to) {

    // 1) side & pre-computed constants ------------------------------
    boolean white = from == 4; // 4→e1 / 60→e8
    int rookFrom  = white
            ? (to == 6 ? 7  : 0)          // h1  : a1
            : (to == 62 ? 63 : 56);       // h8  : a8
    long pathMask = to == 6 || to == 62
            ? /* king-side  */ (1L << (from+1)) | (1L << (from+2))
            : /* queen-side */ (1L << (from-1)) | (1L << (from-2)) | (1L << (from-3));

    // 2) required castling right still set? -------------------------
    int rights = (int)((bb[META] & CR_MASK) >>> CR_SHIFT);
    int need   = white
            ? (to == 6 ? 1 : 2)             // K / Q
            : (to == 62 ? 4 : 8);           // k / q
    if ( (rights & need) == 0 )
      return false; // right already lost

    // 3) path empty? -------------------------------------------------
    long occ =  bb[WP]|bb[WN]|bb[WB]|bb[WR]|bb[WQ]|bb[WK]
            | bb[BP]|bb[BN]|bb[BB]|bb[BR]|bb[BQ]|bb[BK];

    if ( (occ & pathMask) != 0 || (occ & (1L<<rookFrom)) == 0 )
      return false; // something blocks

    // 4) none of origin / transit / target squares may be attacked --
    int  transit = (to == 6 || to == 62) ? from+1 : from-1;

    if (squareAttacked(bb, !white, from) ||
            squareAttacked(bb, !white, transit) ||
            squareAttacked(bb, !white, to))
      return false;

    return true;
  }

  /** EP capture that removes the checking pawn. */
  private static int addEnPassantEvasions(long[] bb, boolean white,
                                          int[] mv, int n, int usP,
                                          int checkerSq, long checkers) {

    int epSq = (int)((bb[META] & EP_MASK) >>> EP_SHIFT);
    if (epSq == EP_NONE) return n; // no EP square
    if ( (checkers & (white ? bb[BP] : bb[WP])) == 0 )   // checker isn’t a pawn
      return n;

    int victim = white ? epSq - 8 : epSq + 8; // pawn behind EP
    if (victim != checkerSq) return n; // not the checker

    long epBit = 1L << epSq;
    long pawns =
            white
                    ? (((epBit & ~FILE_A) >>> 9) | ((epBit & ~FILE_H) >>> 7)) & bb[WP]
                    : (((epBit & ~FILE_H) <<  9) | ((epBit & ~FILE_A) <<  7)) & bb[BP];

    while (pawns != 0) {
      int from = Long.numberOfTrailingZeros(pawns);
      pawns &= pawns - 1;
      mv[n++] = mv(from, epSq, 2, usP);                // flag 2 = EP
    }
    return n;
  }

  /* thin public wrapper around the private attackersToSquare() */
  private boolean squareAttacked(long[] bb, boolean byWhite, int sq) {
    long occ =  bb[WP]|bb[WN]|bb[WB]|bb[WR]|bb[WQ]|bb[WK]
            | bb[BP]|bb[BN]|bb[BB]|bb[BR]|bb[BQ]|bb[BK];

    return attackersToSquare(bb, occ, sq, /*usIsWhite=*/!byWhite) != 0;
  }

  private static long between(int from, int to) {
    return BETWEEN[from * 64 + to];
  }

  private static int emitSliderMoves(int[] mv, int n, int from, long tgt, int piece) {
    while (tgt != 0) {
      int to = Long.numberOfTrailingZeros(tgt);
      tgt &= tgt - 1;
      mv[n++] = mv(from, to, 0, piece);
    }
    return n;
  }

  /* pawn pushes, promotions & double-pushes — never emits captures */
  private static int addPawnPushes(
          long pawns,
          boolean white,
          long occ,
          int[] mv,
          int n,
          int usP,
          boolean includeQueenPromo, // emit Q?
          boolean includeUnderPromo, // emit R/B/N?
          boolean includeQuietPush, // 1-square non-promo push
          boolean includeDoublePush) // 2-square push
  {
    final int dir = white ? 8 : -8;
    final long one = white ? ((pawns << 8) & ~occ) : ((pawns >>> 8) & ~occ);
    final long PROMO = white ? RANK_8 : RANK_1;

    /* ── promotions on push ─────────────────────────────────────── */
    long promo = one & PROMO;
    while (promo != 0L) {
      int to = Long.numberOfTrailingZeros(promo);
      promo &= promo - 1;
      if (includeQueenPromo && includeUnderPromo)
        n = emitPromotions(mv, n, to - dir, to, usP); // Q R B N
      else if (includeQueenPromo) n = emitQueenPromotion(mv, n, to - dir, to, usP); // Q
      else if (includeUnderPromo) n = emitUnderPromotions(mv, n, to - dir, to, usP); // R B N
    }

    /* ── quiet non-promo single pushes ──────────────────────────── */
    if (includeQuietPush) {
      long quiet = one & ~PROMO;
      while (quiet != 0L) {
        int to = Long.numberOfTrailingZeros(quiet);
        quiet &= quiet - 1;
        mv[n++] = mv(to - dir, to, 0, usP);
      }
    }

    /* ── double pushes ──────────────────────────────────────────── */
    if (includeDoublePush) {
      long rank3 = white ? RANK_3 : RANK_6;
      long two = white ? (((one & rank3) << 8) & ~occ) : (((one & rank3) >>> 8) & ~occ);
      while (two != 0L) {
        int to = Long.numberOfTrailingZeros(two);
        two &= two - 1;
        mv[n++] = mv(to - 2 * dir, to, 0, usP);
      }
    }
    return n;
  }

  private static int addPawnCaptures(
          long[] bb,
          boolean white,
          long occ, // current occupancy (unused but kept for signature parity)
          long enemy, // every enemy piece
          int[] mv,
          int n,
          int usP) {

    /* ------------------------------------------------------------------
     * Filter out any square that is occupied by one of **our** pieces.
     * This guarantees the generator never outputs a capture onto
     * a friendly man – even if ‘enemy’ is corrupted (e.g. by a bug
     * elsewhere) and happens to include friendly bits.
     * ------------------------------------------------------------------ */
    long own =
            white
                    ? (bb[WP] | bb[WN] | bb[WB] | bb[WR] | bb[WQ] | bb[WK])
                    : (bb[BP] | bb[BN] | bb[BB] | bb[BR] | bb[BQ] | bb[BK]);
    long legalTargets = enemy & ~own; // enemy squares *only*

    long pawns = bb[usP];
    long PROMO = white ? RANK_8 : RANK_1;

    long capL = white ? ((pawns & ~FILE_A) << 7) : ((pawns & ~FILE_H) >>> 7);
    long capR = white ? ((pawns & ~FILE_H) << 9) : ((pawns & ~FILE_A) >>> 9);

    long promoL = capL & legalTargets & PROMO;
    long promoR = capR & legalTargets & PROMO;
    capL &= legalTargets & ~PROMO;
    capR &= legalTargets & ~PROMO;

    final int dL = white ? -7 : 7;
    final int dR = white ? -9 : 9;

    while (capL != 0) {
      int to = Long.numberOfTrailingZeros(capL);
      capL &= capL - 1;
      mv[n++] = mv(to + dL, to, 0, usP);
    }
    while (capR != 0) {
      int to = Long.numberOfTrailingZeros(capR);
      capR &= capR - 1;
      mv[n++] = mv(to + dR, to, 0, usP);
    }
    while (promoL != 0) {
      int to = Long.numberOfTrailingZeros(promoL);
      promoL &= promoL - 1;
      n = emitPromotions(mv, n, to + dL, to, usP);
    }
    while (promoR != 0) {
      int to = Long.numberOfTrailingZeros(promoR);
      promoR &= promoR - 1;
      n = emitPromotions(mv, n, to + dR, to, usP);
    }

    /* ---- en-passant (unchanged) ------------------------------------ */
    long epSqRaw = (bb[META] & EP_MASK) >>> EP_SHIFT;
    if (epSqRaw != 63) {
      long epBit = 1L << epSqRaw; // empty EP square
      long behind =
              white
                      ? epBit >>> 8 // pawn to be taken
                      : epBit << 8;
      if ((enemy & behind) != 0) { // real enemy pawn?

        long epL = white ? ((pawns & ~FILE_A) << 7) & epBit : ((pawns & ~FILE_H) >>> 7) & epBit;
        long epR = white ? ((pawns & ~FILE_H) << 9) & epBit : ((pawns & ~FILE_A) >>> 9) & epBit;

        while (epL != 0) {
          int to = Long.numberOfTrailingZeros(epL);
          epL &= epL - 1;
          mv[n++] = mv(to + (white ? -7 : 7), to, 2, usP);
        }
        while (epR != 0) {
          int to = Long.numberOfTrailingZeros(epR);
          epR &= epR - 1;
          mv[n++] = mv(to + (white ? -9 : 9), to, 2, usP);
        }
      }
    }
    return n;
  }

  private static int addKnightMoves(long knights, long targetMask, int[] mv, int n, int usN) {
    while (knights != 0) {
      int from = Long.numberOfTrailingZeros(knights);
      knights &= knights - 1;
      long tgt = KNIGHT_ATK[from] & targetMask;
      while (tgt != 0) {
        int to = Long.numberOfTrailingZeros(tgt);
        tgt &= tgt - 1;
        mv[n++] = mv(from, to, 0, usN);
      }
    }
    return n;
  }

  private static int addKingMovesAndCastle(
          long[] bb,
          boolean white,
          long occ,
          long enemySeen,
          long captMask,
          long quietMask,
          int[] mv,
          int n,
          int usK) {

    int kSq = Long.numberOfTrailingZeros(bb[usK]);
    /* own pieces only – enemy squares stay available for capture */
    long own = occ & ~captMask;
    long moves = KING_ATK[kSq] & ~own; // legal destinations

    /* ---- quiet king moves ----------------------------------------- */
    long qs = moves & quietMask;
    while (qs != 0) {
      int to = Long.numberOfTrailingZeros(qs);
      qs &= qs - 1;
      mv[n++] = mv(kSq, to, 0, usK);
    }

    /* ---- king captures -------------------------------------------- */
    long cs = moves & captMask;
    while (cs != 0) {
      int to = Long.numberOfTrailingZeros(cs);
      cs &= cs - 1;
      mv[n++] = mv(kSq, to, 0, usK);
    }

    /* ---- castling (only if we were asked for quiet moves) ---------- */
    if (quietMask != 0) {
      int rights = (int) ((bb[META] & CR_MASK) >>> CR_SHIFT);
      if (white) {
        /* 0-0 */
        if ((rights & 1) != 0
                && ((bb[WR] & (1L << 7)) != 0)
                && ((occ & 0x60L) == 0)) mv[n++] = mv(4, 6, 3, WK);
        /* 0-0-0 */
        if ((rights & 2) != 0
                && ((bb[WR] & (1L << 0)) != 0)
                && ((occ & 0x0EL) == 0)) mv[n++] = mv(4, 2, 3, WK);
      } else {
        /* 0-0 */
        if ((rights & 4) != 0
                && ((bb[BR] & (1L << 63)) != 0)
                && ((occ & 0x6000_0000_0000_0000L) == 0)) mv[n++] = mv(60, 62, 3, BK);
        /* 0-0-0 */
        if ((rights & 8) != 0
                && ((bb[BR] & (1L << 56)) != 0)
                && ((occ & 0x0E00_0000_0000_0000L) == 0)) mv[n++] = mv(60, 58, 3, BK);
      }
    }
    return n;
  }

  /** all enemy pieces that attack ‘sq’ (used to locate checkers) */
  private static long attackersToSquare(long[] bb, long occ, int sq, boolean usIsWhite) {
    boolean enemyWhite = !usIsWhite;
    long atk = 0L, sqBit = 1L << sq;

    /* pawns */
    atk |= enemyWhite
            ? bb[WP] & (((sqBit & ~FILE_H) >>> 7) | ((sqBit & ~FILE_A) >>> 9))
            : bb[BP] & (((sqBit & ~FILE_H) << 9) | ((sqBit & ~FILE_A) << 7));
    /* knights */
    atk |= KNIGHT_ATK[sq] & (enemyWhite ? bb[WN] : bb[BN]);
    /* bishops/queens */
    atk |= bishopAtt(occ, sq) & (enemyWhite ? (bb[WB] | bb[WQ]) : (bb[BB] | bb[BQ]));
    /* rooks/queens */
    atk |= rookAtt(occ, sq) & (enemyWhite ? (bb[WR] | bb[WQ]) : (bb[BR] | bb[BQ]));
    /* king */
    atk |= KING_ATK[sq] & (enemyWhite ? bb[WK] : bb[BK]);

    return atk;
  }

  /* pawn captures to any square in ‘target’ (no EP) */
  private static int addPawnCapturesTarget(
          long[] bb, boolean white, long occ, long enemy, int[] mv, int n, int usP, long target) {

    long pawns = bb[usP];
    final long PROMO = white ? RANK_8 : RANK_1;

    /* ---------- left-diagonal captures (from the pawn’s point of view) */
    long capL =
            white
                    ? ((pawns & ~FILE_A) << 7) // ⭡⭠  for White
                    : ((pawns & ~FILE_H) >>> 7); // ⭣⭢  for Black
    int dL = white ? 7 : -7; // dest − from

    for (long m = capL & enemy & target; m != 0; m &= m - 1) {
      int to = Long.numberOfTrailingZeros(m);
      int from = to - dL; // pawn is dL behind ‘to’
      if ((PROMO & (1L << to)) != 0) n = emitPromotions(mv, n, from, to, usP); // Q R B N
      else mv[n++] = mv(from, to, 0, usP);
    }

    /* ---------- right-diagonal captures */
    long capR =
            white
                    ? ((pawns & ~FILE_H) << 9) // ⭡⭢  for White
                    : ((pawns & ~FILE_A) >>> 9); // ⭣⭠  for Black
    int dR = white ? 9 : -9;
    for (long m = capR & enemy & target; m != 0; m &= m - 1) {
      int to = Long.numberOfTrailingZeros(m);
      int from = to - dR;
      if ((PROMO & (1L << to)) != 0) n = emitPromotions(mv, n, from, to, usP);
      else mv[n++] = mv(from, to, 0, usP);
    }
    return n;
  }

  /** Bug Fix: Correctly filter double pushes by the target mask for check evasions. */
  private static int addPawnPushBlocks(
          long pawns, boolean white, long occ, int[] mv, int n, int usP, long target) {
    final int dir = white ? 8 : -8;
    final long one = white ? ((pawns << 8) & ~occ) : ((pawns >>> 8) & ~occ);
    long singleBlocks = one & target;

    final long PROMO = white ? RANK_8 : RANK_1;
    long promo = singleBlocks & PROMO;
    long quiet = singleBlocks & ~PROMO;

    while (promo != 0) {
      int to = Long.numberOfTrailingZeros(promo);
      promo &= promo - 1;
      n = emitPromotions(mv, n, to - dir, to, usP);
    }
    while (quiet != 0) {
      int to = Long.numberOfTrailingZeros(quiet);
      quiet &= quiet - 1;
      mv[n++] = mv(to - dir, to, 0, usP);
    }

    final long startRankForDoublePush = white ? RANK_3 : RANK_6;
    long doublePushDestinations =
            white
                    ? (((one & startRankForDoublePush) << 8) & ~occ)
                    : (((one & startRankForDoublePush) >>> 8) & ~occ);
    doublePushDestinations &= target; // BUG FIX: Filter double pushes by the target mask.

    while (doublePushDestinations != 0) {
      int to = Long.numberOfTrailingZeros(doublePushDestinations);
      doublePushDestinations &= doublePushDestinations - 1;
      mv[n++] = mv(to - 2 * dir, to, 0, usP);
    }

    return n;
  }


  /* knights that jump onto ‘target’ */
  private static int addKnightEvasions(long knights, long target, int[] mv, int n, int usN) {
    while (knights != 0) {
      int from = Long.numberOfTrailingZeros(knights);
      knights &= knights - 1;
      long tgt = KNIGHT_ATK[from] & target;
      while (tgt != 0) {
        int to = Long.numberOfTrailingZeros(tgt);
        tgt &= tgt - 1;
        mv[n++] = mv(from, to, 0, usN);
      }
    }
    return n;
  }

  @Override
  public boolean kingAttacked(long[] bb, boolean whiteSide) {
    // delegate to the colour-specific fast path
    return whiteSide ? kingAttackedWhite(bb)    // we just moved → our king is WHITE
            : kingAttackedBlack(bb);   // we just moved → our king is BLACK
  }

  /* our king = WHITE, attackers = BLACK */
  private static boolean kingAttackedWhite(long[] bb) {
    int kSq = Long.numberOfTrailingZeros(bb[WK]);
    /* 1) pawn & knight checks – cheap fast exits */
    if ( (bb[BP] & PAWN_ATK_W[kSq]) != 0 ) return true;
    if ( (bb[BN] & KNIGHT_ATK[kSq]) != 0 ) return true;
    /* 2) build occupancy once (12 ORs instead of 6+6+1) */
    long occ = bb[WP]|bb[WN]|bb[WB]|bb[WR]|bb[WQ]|bb[WK]
            | bb[BP]|bb[BN]|bb[BB]|bb[BR]|bb[BQ]|bb[BK];

    /* 3) sliders */
    if ( (bishopAtt(occ, kSq) & (bb[BB] | bb[BQ])) != 0 ) return true;
    if ( (rookAtt  (occ, kSq) & (bb[BR] | bb[BQ])) != 0 ) return true;
    /* 4) opposing king */
    return (bb[BK] & KING_ATK[kSq]) != 0;
  }

  /* our king = BLACK, attackers = WHITE */
  private static boolean kingAttackedBlack(long[] bb) {
    int kSq = Long.numberOfTrailingZeros(bb[BK]);
    if ( (bb[WP] & PAWN_ATK_B[kSq]) != 0 ) return true;
    if ( (bb[WN] & KNIGHT_ATK[kSq]) != 0 ) return true;
    long occ = bb[WP]|bb[WN]|bb[WB]|bb[WR]|bb[WQ]|bb[WK]
            | bb[BP]|bb[BN]|bb[BB]|bb[BR]|bb[BQ]|bb[BK];
    if ( (bishopAtt(occ, kSq) & (bb[WB] | bb[WQ])) != 0 ) return true;
    if ( (rookAtt  (occ, kSq) & (bb[WR] | bb[WQ])) != 0 ) return true;
    return (bb[WK] & KING_ATK[kSq]) != 0;
  }

  /* ───────────────── helper to emit the 4 promotion types ─────── */
  private static int emitPromotions(int[] moves, int n, int from, int to, int mover) {
    int base = mv(from, to, 1, mover); // flag 1 = promotion
    moves[n++] = base | (3 << 12); // Q
    moves[n++] = base | (2 << 12); // R
    moves[n++] = base | (1 << 12); // B
    moves[n++] = base; // N
    return n;
  }

  private static int emitQueenPromotion(int[] mv, int n, int from, int to, int mover) {
    int base = mv(from, to, 1, mover); // flag 1 = promotion
    mv[n++] = base | (3 << 12); // Q only
    return n;
  }

  private static int emitUnderPromotions(int[] mv, int n, int from, int to, int mover) {
    int base = mv(from, to, 1, mover); // R / B / N only
    mv[n++] = base | (2 << 12); // R
    mv[n++] = base | (1 << 12); // B
    mv[n++] = base; // N
    return n;
  }

  /* ── LOOKUP helpers (runtime) ─────────────────────────────────── */
  public static long rookAtt(long occ, int sq) {
    if (USE_PEXT) return rookAttPext(sq, occ);
    return rookAttMagic(occ, sq);
  }

  public static long bishopAtt(long occ, int sq) {
    if (USE_PEXT) return bishopAttPext(sq, occ);
    return bishopAttMagic(occ, sq);
  }

  public static long queenAtt(long occ, int sq) {
    if (USE_PEXT) return queenAttPext(sq, occ);
    return queenAttMagic(occ, sq);
  }

  private static long rookAttMagic(long occ, int sq) {
    int idx = (int) (((occ & R_MASK[sq]) * R_HASH[sq]) >>> 52);
    return LOOKUP_TABLE[R_BASE[sq] + idx];
  }

  private static long bishopAttMagic(long occ, int sq) {
    int idx = (int) (((occ & B_MASK[sq]) * B_HASH[sq]) >>> 55);
    return LOOKUP_TABLE[B_BASE[sq] + idx];
  }

  private static long queenAttMagic(long occ, int sq) {
    return rookAttMagic(occ, sq) | bishopAttMagic(occ, sq);
  }

  public static long rookAttPext(int sq, long occ) {
    int base = PreCompMoveGenTables.ROOKOFFSET_PEXT[sq];
    long mask = PreCompMoveGenTables.ROOKMASK_PEXT[sq];
    int idx = (int) Long.compress(occ, mask);
    return PreCompMoveGenTables.SLIDER_PEXT[base + idx];
  }

  public static long bishopAttPext(int sq, long occ) {
    int base = PreCompMoveGenTables.BISHOPOFFSET_PEXT[sq];
    long mask = PreCompMoveGenTables.BISHOPMASK_PEXT[sq];
    int idx = (int) Long.compress(occ, mask);
    return PreCompMoveGenTables.SLIDER_PEXT[base + idx];
  }

  public static long queenAttPext(int sq, long occ) {
    return rookAttPext(sq, occ) | bishopAttPext(sq, occ);
  }

  private static int mv(int from, int to, int flags, int mover) {
    return (from << 6) | to | (flags << 14) | (mover << MOVER_SHIFT);
  }
}
C:\dev\Helios\src>(echo.   & echo // File: PositionFactoryImpl.java   & type "C:\dev\Helios\src\main\java\core\impl\PositionFactoryImpl.java" ) 
 
// File: PositionFactoryImpl.java 
package core.impl;

import static core.contracts.PositionFactory.*;
import static core.impl.MoveGeneratorImpl.FILE_A;
import static core.impl.MoveGeneratorImpl.FILE_H;

import core.contracts.*;
import java.util.Random;

public final class PositionFactoryImpl implements PositionFactory {
  /* piece indices (mirror interface) */
  private static final int WP = 0,
          WN = 1,
          WB = 2,
          WR = 3,
          WQ = 4,
          WK = 5,
          BP = 6,
          BN = 7,
          BB = 8,
          BR = 9,
          BQ = 10,
          BK = 11,
          META = 12;

  /* ───────── Zobrist tables ───────── */
  public static final long[][] PIECE_SQUARE = new long[12][64];
  public static final long[]   CASTLING     = new long[16];
  public static final long[]   EP_FILE      = new long[8]; // One for each file
  public static final long     SIDE_TO_MOVE;
  private static final long[] ZOBRIST_50MR = new long[120]; // 0‥119 half-moves

  /* META layout (duplicated locally for speed) */
  private static final long STM_MASK = 1L;
  private static final int CR_SHIFT = 1;
  private static final long CR_MASK = 0b1111L << CR_SHIFT;
  private static final int EP_SHIFT = 5;
  private static final long EP_MASK = 0x3FL << EP_SHIFT;
  private static final int HC_SHIFT = 11;
  private static final long HC_MASK = 0x7FL << HC_SHIFT;
  private static final int FM_SHIFT = 18;
  private static final long FM_MASK = 0x1FFL << FM_SHIFT;

  /* Precomputed masks for castling rights updates */
  private static final short[] CR_MASK_LOST_FROM = new short[64];
  private static final short[] CR_MASK_LOST_TO   = new short[64];
  private static final int CR_BITS = (int) CR_MASK;
  private static final int EP_BITS = (int) EP_MASK;
  private static final int HC_BITS = (int) HC_MASK;

  static {
    java.util.Arrays.fill(CR_MASK_LOST_FROM, (short) 0b1111);
    java.util.Arrays.fill(CR_MASK_LOST_TO,   (short) 0b1111);

    CR_MASK_LOST_FROM[ 4]  = 0b1100; // e1  white king
    CR_MASK_LOST_FROM[60]  = 0b0011; // e8  black king
    CR_MASK_LOST_FROM[ 7] &= ~0b0001; // h1  → clear white-K
    CR_MASK_LOST_FROM[ 0] &= ~0b0010; // a1  → clear white-Q
    CR_MASK_LOST_FROM[63] &= ~0b0100; // h8  → clear black-k
    CR_MASK_LOST_FROM[56] &= ~0b1000; // a8  → clear black-q
    CR_MASK_LOST_TO[ 7]  &= ~0b0001;
    CR_MASK_LOST_TO[ 0]  &= ~0b0010;
    CR_MASK_LOST_TO[63]  &= ~0b0100;
    CR_MASK_LOST_TO[56]  &= ~0b1000;

    Random rnd = new Random(0xCAFEBABE);
    for (int p = 0; p < 12; ++p)
      for (int sq = 0; sq < 64; ++sq)
        PIECE_SQUARE[p][sq] = rnd.nextLong();

    final int CR_W_K = 1, CR_W_Q = 2, CR_B_K = 4, CR_B_Q = 8;
    CASTLING[0] = 0L;
    CASTLING[CR_W_K] = rnd.nextLong();
    CASTLING[CR_W_Q] = rnd.nextLong();
    CASTLING[CR_B_K] = rnd.nextLong();
    CASTLING[CR_B_Q] = rnd.nextLong();

    for (int i = 1; i < 16; i++) {
      if (Integer.bitCount(i) < 2) continue;
      long combinedKey = 0L;
      if ((i & CR_W_K) != 0) combinedKey ^= CASTLING[CR_W_K];
      if ((i & CR_W_Q) != 0) combinedKey ^= CASTLING[CR_W_Q];
      if ((i & CR_B_K) != 0) combinedKey ^= CASTLING[CR_B_K];
      if ((i & CR_B_Q) != 0) combinedKey ^= CASTLING[CR_B_Q];
      CASTLING[i] = combinedKey;
    }

    for (int f = 0; f < 8; ++f) EP_FILE[f] = rnd.nextLong();
    SIDE_TO_MOVE = rnd.nextLong();
    for (int i = 0; i < ZOBRIST_50MR.length; ++i)
      ZOBRIST_50MR[i] = rnd.nextLong();
  }

  @Override
  public long zobrist50(long[] bb) {
    long key = bb[HASH];
    int hc   = (int) ((bb[META] & HC_MASK) >>> HC_SHIFT); // 0‥119, clamped by makeMove()
    return key ^ ZOBRIST_50MR[hc];
  }

  @Override
  public long[] fromFen(String fen) {
    long[] bb = fenToBitboards(fen);
    bb[COOKIE_SP] = 0;
    bb[DIFF_META] = bb[META];
    bb[DIFF_INFO] = 0;
    bb[HASH] = fullHash(bb);
    return bb;
  }

  @Override
  public String toFen(long[] bb)
  {
    StringBuilder sb = new StringBuilder(64);
    for (int rank = 7; rank >= 0; --rank) {
      int empty = 0;
      for (int file = 0; file < 8; ++file) {
        int sq = rank * 8 + file;
        char pc = pieceCharAt(bb, sq);
        if (pc == 0) {
          empty++;
          continue;
        }
        if (empty != 0) {
          sb.append(empty);
          empty = 0;
        }
        sb.append(pc);
      }
      if (empty != 0) sb.append(empty);
      if (rank != 0) sb.append('/');
    }
    sb.append(whiteToMove(bb) ? " w " : " b ");

    int cr = castlingRights(bb);
    sb.append(cr == 0 ? "-" : "")
            .append((cr & 1) != 0 ? "K" : "")
            .append((cr & 2) != 0 ? "Q" : "")
            .append((cr & 4) != 0 ? "k" : "")
            .append((cr & 8) != 0 ? "q" : "");
    sb.append(' ');

    int ep = enPassantSquare(bb);
    if (ep != -1) {
      sb.append((char) ('a' + (ep & 7))).append(1 + (ep >>> 3));
    } else {
      sb.append('-');
    }

    sb.append(' ');
    sb.append(halfmoveClock(bb)).append(' ').append(fullmoveNumber(bb));
    return sb.toString();
  }

  @Override
  public long zobrist(long[] bb)
  {
    return bb[HASH];
  }

  private char pieceCharAt(long bb[], int sq) {
    for (int i = 0; i < 12; ++i) if ((bb[i] & (1L << sq)) != 0) return "PNBRQKpnbrqk".charAt(i);
    return 0;
  }

  private boolean whiteToMove(long[] bb) {
    return (bb[META] & STM_MASK) == 0;
  }

  private int halfmoveClock(long[] bb) {
    return (int) ((bb[META] & HC_MASK) >>> HC_SHIFT);
  }

  private int fullmoveNumber(long[] bb) {
    return 1 + (int) ((bb[META] & FM_MASK) >>> FM_SHIFT);
  }

  private int castlingRights(long[] bb) {
    return (int) ((bb[META] & CR_MASK) >>> CR_SHIFT);
  }

  private int enPassantSquare(long[] bb) {
    int e = (int) ((bb[META] & EP_MASK) >>> EP_SHIFT);
    return e == EP_NONE ? -1 : e;
  }

  @Override
  public boolean makeMoveInPlace(long[] bb, int mv, MoveGenerator gen) {
    int from  = (mv >>>  6) & 0x3F;
    int to    =  mv         & 0x3F;
    int type  = (mv >>> 14) & 0x3;
    int promo = (mv >>> 12) & 0x3;
    int mover = (mv >>> 16) & 0xF;

    boolean white   = mover < 6;
    long    fromBit = 1L << from;
    long    toBit   = 1L << to;

    if (type == 3 && !gen.castleLegal(bb, from, to))
      return false;

    long h        = bb[HASH];
    long oldHash  = h;
    int  metaOld  = (int) bb[META];
    int  oldCR    = (metaOld & CR_BITS) >>> CR_SHIFT;
    int  oldEP    = (metaOld & EP_BITS) >>> EP_SHIFT;

    int sp = (int) bb[COOKIE_SP];
    bb[COOKIE_BASE + sp] =
            (bb[DIFF_META] & 0xFFFF_FFFFL) << 32 |
                    (bb[DIFF_INFO] & 0xFFFF_FFFFL);
    bb[COOKIE_SP] = sp + 1;

    int captured = 15;
    if (type <= 1) {
      long enemy = white
              ? (bb[BP]|bb[BN]|bb[BB]|bb[BR]|bb[BQ]|bb[BK])
              : (bb[WP]|bb[WN]|bb[WB]|bb[WR]|bb[WQ]|bb[WK]);
      if ((enemy & toBit) != 0) {
        captured = (bb[white?BP:WP] & toBit)!=0 ? (white?BP:WP) :
                (bb[white?BN:WN] & toBit)!=0 ? (white?BN:WN) :
                        (bb[white?BB:WB] & toBit)!=0 ? (white?BB:WB) :
                                (bb[white?BR:WR] & toBit)!=0 ? (white?BR:WR) :
                                        (bb[white?BQ:WQ] & toBit)!=0 ? (white?BQ:WQ) :
                                                (white?BK:WK);
        bb[captured] &= ~toBit;
        h ^= PIECE_SQUARE[captured][to];
      }
    } else if (type == 2) {
      int capSq   = white ? to - 8 : to + 8;
      captured    = white ? BP : WP;
      bb[captured] &= ~(1L << capSq);
      h ^= PIECE_SQUARE[captured][capSq];
    }

    bb[mover] ^= fromBit;
    h ^= PIECE_SQUARE[mover][from];

    if (type == 1) {
      int promIdx = (white ? WN : BN) + promo;
      bb[promIdx] |= toBit;
      h ^= PIECE_SQUARE[promIdx][to];
    } else {
      bb[mover]   |= toBit;
      h ^= PIECE_SQUARE[mover][to];
    }

    if (type == 3) switch (to) {
      case  6 -> { bb[WR] ^= (1L<<7)|(1L<<5); h ^= PIECE_SQUARE[WR][7] ^ PIECE_SQUARE[WR][5]; }
      case  2 -> { bb[WR] ^= (1L<<0)|(1L<<3); h ^= PIECE_SQUARE[WR][0] ^ PIECE_SQUARE[WR][3]; }
      case 62 -> { bb[BR] ^= (1L<<63)|(1L<<61);h ^= PIECE_SQUARE[BR][63] ^ PIECE_SQUARE[BR][61];}
      case 58 -> { bb[BR] ^= (1L<<56)|(1L<<59);h ^= PIECE_SQUARE[BR][56] ^ PIECE_SQUARE[BR][59];}
    }

    int meta = metaOld;
    int ep = (int) EP_NONE;
    if ((mover == WP || mover == BP) && ((from ^ to) == 16))
      ep = white ? from + 8 : from - 8;

    if (ep != oldEP) {
      meta = (meta & ~EP_BITS) | (ep << EP_SHIFT);
      if (oldEP != EP_NONE) h ^= EP_FILE[oldEP & 7];
      if (ep != EP_NONE)    h ^= EP_FILE[ep & 7];
    }

    int cr = oldCR & CR_MASK_LOST_FROM[from] & CR_MASK_LOST_TO[to];
    if (cr != oldCR) {
      meta = (meta & ~CR_BITS) | (cr << CR_SHIFT);
      h ^= CASTLING[oldCR] ^ CASTLING[cr];
    }

    int newHC = ((mover == WP || mover == BP) || captured != 15)
            ? 0
            : ((metaOld & HC_BITS) >>> HC_SHIFT) + 1;
    meta = (meta & ~HC_BITS) | (newHC << HC_SHIFT);

    int fm = (meta >>> FM_SHIFT) & 0x1FF;
    if (!white) fm++;
    meta ^= STM_MASK;
    meta = (meta & ~((int)FM_MASK)) | (fm << FM_SHIFT);
    h ^= SIDE_TO_MOVE;

    bb[DIFF_INFO] = (int) packDiff(from, to, captured, mover, type, promo);
    bb[DIFF_META] = (int) (bb[META] ^ meta);
    bb[META]      = meta;
    bb[HASH]      = h;

    if (gen.kingAttacked(bb, white)) {
      bb[HASH] = oldHash;
      fastUndo(bb);
      bb[COOKIE_SP] = sp;
      long prev = bb[COOKIE_BASE + sp];
      bb[DIFF_INFO] = (int)  prev;
      bb[DIFF_META] = (int) (prev >>> 32);
      return false;
    }
    return true;
  }

  @Override
  public void undoMoveInPlace(long[] bb) {
    long diff   = bb[DIFF_INFO];
    long metaΔ  = bb[DIFF_META];

    long h          = bb[HASH];
    int  metaAfter  = (int) bb[META];
    int  crAfter    = (metaAfter & CR_BITS) >>> CR_SHIFT;
    int  epAfter    = (metaAfter & EP_BITS) >>> EP_SHIFT;

    bb[META] ^= metaΔ;
    int metaBefore = (int) bb[META];
    int crBefore   = (metaBefore & CR_BITS) >>> CR_SHIFT;
    int epBefore   = (metaBefore & EP_BITS) >>> EP_SHIFT;

    h ^= SIDE_TO_MOVE;
    if (crAfter != crBefore) h ^= CASTLING[crAfter] ^ CASTLING[crBefore];

    int from   = dfFrom(diff);
    int to     = dfTo(diff);
    int capIdx = dfCap(diff);
    int mover  = dfMover(diff);
    int type   = dfType(diff);
    int promo  = dfPromo(diff);

    long fromBit = 1L << from;
    long toBit   = 1L << to;

    if (type == 1) {
      int promIdx = (mover < 6 ? WN : BN) + promo;
      bb[promIdx] ^= toBit;
      bb[mover]   |= fromBit;
      h ^= PIECE_SQUARE[promIdx][to] ^ PIECE_SQUARE[mover][from];
    } else {
      bb[mover] ^= fromBit | toBit;
      h ^= PIECE_SQUARE[mover][to] ^ PIECE_SQUARE[mover][from];
    }

    if (type == 3) switch (to) {
      case  6 -> { bb[WR] ^= (1L<<7)|(1L<<5); h ^= PIECE_SQUARE[WR][7] ^ PIECE_SQUARE[WR][5]; }
      case  2 -> { bb[WR] ^= (1L<<0)|(1L<<3); h ^= PIECE_SQUARE[WR][0] ^ PIECE_SQUARE[WR][3]; }
      case 62 -> { bb[BR] ^= (1L<<63)|(1L<<61);h ^= PIECE_SQUARE[BR][63] ^ PIECE_SQUARE[BR][61];}
      case 58 -> { bb[BR] ^= (1L<<56)|(1L<<59);h ^= PIECE_SQUARE[BR][56] ^ PIECE_SQUARE[BR][59];}
    }

    if (capIdx != 15) {
      int capSq = (type == 2) ? ((mover < 6) ? to - 8 : to + 8) : to;
      bb[capIdx] |= 1L << capSq;
      h ^= PIECE_SQUARE[capIdx][capSq];
    }

    int sp = (int) bb[COOKIE_SP] - 1;
    long ck = bb[COOKIE_BASE + sp];
    bb[COOKIE_SP] = sp;
    bb[DIFF_INFO] = (int)  ck;
    bb[DIFF_META] = (int) (ck >>> 32);

    if (epAfter != epBefore) {
      if (epAfter != EP_NONE)  h ^= EP_FILE[epAfter & 7];
      if (epBefore != EP_NONE) h ^= EP_FILE[epBefore & 7];
    }

    bb[HASH] = h;
  }

  private static void fastUndo(long[] bb) {
    long diff  = bb[DIFF_INFO];
    long metaΔ = bb[DIFF_META];
    bb[META]  ^= metaΔ;

    int from   = dfFrom(diff);
    int to     = dfTo(diff);
    int capIdx = dfCap(diff);
    int mover  = dfMover(diff);
    int type   = dfType(diff);
    int promo  = dfPromo(diff);

    long fromBit = 1L << from;
    long toBit   = 1L << to;

    if (type == 1) {
      bb[(mover < 6 ? WN : BN) + promo] ^= toBit;
      bb[(mover < 6) ? WP : BP]        |= fromBit;
    } else {
      bb[mover] ^= fromBit | toBit;
    }

    if (type == 3) switch (to) {
      case  6 -> bb[WR] ^= (1L<<7)  | (1L<<5);
      case  2 -> bb[WR] ^= (1L<<0)  | (1L<<3);
      case 62 -> bb[BR] ^= (1L<<63) | (1L<<61);
      case 58 -> bb[BR] ^= (1L<<56) | (1L<<59);
    }

    if (capIdx != 15) {
      long capMask = (type == 2) ? 1L << ((mover < 6) ? to - 8 : to + 8) : toBit;
      bb[capIdx] |= capMask;
    }
  }

  private static long[] fenToBitboards(String fen) {
    long[] bb = new long[BB_LEN];
    String[] parts = fen.trim().split("\\s+");
    String board = parts[0];
    int rank = 7, file = 0;
    for (char c : board.toCharArray()) {
      if (c == '/') {
        rank--;
        file = 0;
        continue;
      }
      if (Character.isDigit(c)) {
        file += c - '0';
        continue;
      }
      int sq = rank * 8 + file++;
      int idx =
              switch (c) {
                case 'P' -> WP; case 'N' -> WN; case 'B' -> WB; case 'R' -> WR; case 'Q' -> WQ; case 'K' -> WK;
                case 'p' -> BP; case 'n' -> BN; case 'b' -> BB; case 'r' -> BR; case 'q' -> BQ; case 'k' -> BK;
                default -> throw new IllegalArgumentException("bad fen piece: " + c);
              };
      bb[idx] |= 1L << sq;
    }
    long meta = parts[1].equals("b") ? 1L : 0L;
    int cr = 0;
    if (parts[2].indexOf('K') >= 0) cr |= 0b0001;
    if (parts[2].indexOf('Q') >= 0) cr |= 0b0010;
    if (parts[2].indexOf('k') >= 0) cr |= 0b0100;
    if (parts[2].indexOf('q') >= 0) cr |= 0b1000;
    meta |= (long) cr << CR_SHIFT;

    int epSq = (int) EP_NONE;
    if (!parts[3].equals("-")) {
      int f = parts[3].charAt(0) - 'a';
      int r = parts[3].charAt(1) - '1';
      epSq = r * 8 + f;
    }
    meta |= (long) epSq << EP_SHIFT;

    int hc = (parts.length > 4) ? Integer.parseInt(parts[4]) : 0;
    int fm = (parts.length > 5) ? Integer.parseInt(parts[5]) - 1 : 0;
    meta |= (long) hc << HC_SHIFT;
    meta |= (long) fm << FM_SHIFT;

    bb[META] = meta;
    return bb;
  }

  public long fullHash(long[] bb) {
    long k = 0;
    for (int pc = WP; pc <= BK; ++pc) {
      long bits = bb[pc];
      while (bits != 0) {
        int sq = Long.numberOfTrailingZeros(bits);
        k ^= PIECE_SQUARE[pc][sq];
        bits &= bits - 1;
      }
    }

    if ((bb[META] & STM_MASK) != 0)
      k ^= SIDE_TO_MOVE;

    int cr = (int) ((bb[META] & CR_MASK) >>> CR_SHIFT);
    k ^= CASTLING[cr];

    int ep = (int) ((bb[META] & EP_MASK) >>> EP_SHIFT);
    if (ep != EP_NONE)
      k ^= EP_FILE[ep & 7];

    return k;
  }

  private static long packDiff(int from, int to, int cap, int mover, int typ, int pro) {
    return (from) | ((long) to << 6) | ((long) cap << 12) | ((long) mover << 16) | ((long) typ << 20) | ((long) pro << 22);
  }

  private static int dfFrom(long d) { return (int) (d & 0x3F); }
  private static int dfTo(long d) { return (int) ((d >>> 6) & 0x3F); }
  private static int dfCap(long d) { return (int) ((d >>> 12) & 0x0F); }
  private static int dfMover(long d) { return (int) ((d >>> 16) & 0x0F); }
  private static int dfType(long d) { return (int) ((d >>> 20) & 0x03); }
  private static int dfPromo(long d) { return (int) ((d >>> 22) & 0x03); }
}
C:\dev\Helios\src>(echo.   & echo // File: PreCompMoveGenTables.java   & type "C:\dev\Helios\src\main\java\core\impl\PreCompMoveGenTables.java" ) 
 
// File: PreCompMoveGenTables.java 
package core.impl;

import java.util.Locale;

public final class PreCompMoveGenTables {
  private PreCompMoveGenTables() {}

  public static final long[] ROOKMASK_PEXT = {
    0x000101010101017EL, 0x000202020202027CL, 0x000404040404047AL, 0x0008080808080876L,
    0x001010101010106EL, 0x002020202020205EL, 0x004040404040403EL, 0x008080808080807EL,
    0x0001010101017E00L, 0x0002020202027C00L, 0x0004040404047A00L, 0x0008080808087600L,
    0x0010101010106E00L, 0x0020202020205E00L, 0x0040404040403E00L, 0x0080808080807E00L,
    0x00010101017E0100L, 0x00020202027C0200L, 0x00040404047A0400L, 0x0008080808760800L,
    0x00101010106E1000L, 0x00202020205E2000L, 0x00404040403E4000L, 0x00808080807E8000L,
    0x000101017E010100L, 0x000202027C020200L, 0x000404047A040400L, 0x0008080876080800L,
    0x001010106E101000L, 0x002020205E202000L, 0x004040403E404000L, 0x008080807E808000L,
    0x0001017E01010100L, 0x0002027C02020200L, 0x0004047A04040400L, 0x0008087608080800L,
    0x0010106E10101000L, 0x0020205E20202000L, 0x0040403E40404000L, 0x0080807E80808000L,
    0x00017E0101010100L, 0x00027C0202020200L, 0x00047A0404040400L, 0x0008760808080800L,
    0x00106E1010101000L, 0x00205E2020202000L, 0x00403E4040404000L, 0x00807E8080808000L,
    0x007E010101010100L, 0x007C020202020200L, 0x007A040404040400L, 0x0076080808080800L,
    0x006E101010101000L, 0x005E202020202000L, 0x003E404040404000L, 0x007E808080808000L,
    0x7E01010101010100L, 0x7C02020202020200L, 0x7A04040404040400L, 0x7608080808080800L,
    0x6E10101010101000L, 0x5E20202020202000L, 0x3E40404040404000L, 0x7E80808080808000L,
  };

  public static final long[] BISHOPMASK_PEXT = {
    0x0040201008040200L, 0x0000402010080400L, 0x0000004020100A00L, 0x0000000040221400L,
    0x0000000002442800L, 0x0000000204085000L, 0x0000020408102000L, 0x0002040810204000L,
    0x0020100804020000L, 0x0040201008040000L, 0x00004020100A0000L, 0x0000004022140000L,
    0x0000000244280000L, 0x0000020408500000L, 0x0002040810200000L, 0x0004081020400000L,
    0x0010080402000200L, 0x0020100804000400L, 0x004020100A000A00L, 0x0000402214001400L,
    0x0000024428002800L, 0x0002040850005000L, 0x0004081020002000L, 0x0008102040004000L,
    0x0008040200020400L, 0x0010080400040800L, 0x0020100A000A1000L, 0x0040221400142200L,
    0x0002442800284400L, 0x0004085000500800L, 0x0008102000201000L, 0x0010204000402000L,
    0x0004020002040800L, 0x0008040004081000L, 0x00100A000A102000L, 0x0022140014224000L,
    0x0044280028440200L, 0x0008500050080400L, 0x0010200020100800L, 0x0020400040201000L,
    0x0002000204081000L, 0x0004000408102000L, 0x000A000A10204000L, 0x0014001422400000L,
    0x0028002844020000L, 0x0050005008040200L, 0x0020002010080400L, 0x0040004020100800L,
    0x0000020408102000L, 0x0000040810204000L, 0x00000A1020400000L, 0x0000142240000000L,
    0x0000284402000000L, 0x0000500804020000L, 0x0000201008040200L, 0x0000402010080400L,
    0x0002040810204000L, 0x0004081020400000L, 0x000A102040000000L, 0x0014224000000000L,
    0x0028440200000000L, 0x0050080402000000L, 0x0020100804020000L, 0x0040201008040200L,
  };

  public static final int[] ROOKOFFSET_PEXT = {
    0, 4160, 6240, 8320,
    10400, 12480, 14560, 16640,
    20800, 22880, 23936, 24992,
    26048, 27104, 28160, 29216,
    31296, 33376, 34432, 35584,
    36736, 37888, 39040, 40096,
    42176, 44256, 45312, 46464,
    48000, 49536, 50688, 51744,
    53824, 55904, 56960, 58112,
    59648, 61184, 62336, 63392,
    65472, 67552, 68608, 69760,
    70912, 72064, 73216, 74272,
    76352, 78432, 79488, 80544,
    81600, 82656, 83712, 84768,
    86848, 91008, 93088, 95168,
    97248, 99328, 101408, 103488,
  };

  public static final int[] BISHOPOFFSET_PEXT = {
    4096, 6208, 8288, 10368,
    12448, 14528, 16608, 20736,
    22848, 23904, 24960, 26016,
    27072, 28128, 29184, 31264,
    33344, 34400, 35456, 36608,
    37760, 38912, 40064, 42144,
    44224, 45280, 46336, 47488,
    49024, 50560, 51712, 53792,
    55872, 56928, 57984, 59136,
    60672, 62208, 63360, 65440,
    67520, 68576, 69632, 70784,
    71936, 73088, 74240, 76320,
    78400, 79456, 80512, 81568,
    82624, 83680, 84736, 86816,
    90944, 93056, 95136, 97216,
    99296, 101376, 103456, 107584,
  };

  /** flattened triples: offset, mask, hash */
  public static final long[] B_MAGICS = {
    66157L,
    0xFFBFDFEFF7FBFDFFL,
    1187473109101317119L,
    71730L,
    0xFFFFBFDFEFF7FBFFL,
    9223336714375004157L,
    37781L,
    0xFFFFFFBFDFEFF5FFL,
    288441550701068800L,
    21015L,
    0xFFFFFFFFBFDDEBFFL,
    1170795303134035968L,
    47590L,
    0xFFFFFFFFFDBBD7FFL,
    0xC03FE00100000000L,
    835L,
    0xFFFFFFFDFBF7AFFFL,
    2648129775020802048L,
    23592L,
    0xFFFFFDFBF7EFDFFFL,
    578730278520913668L,
    30599L,
    0xFFFDFBF7EFDFBFFFL,
    1155182238468407424L,
    68776L,
    0xFFDFEFF7FBFDFFFFL,
    0xFFA2FEFFBFEFB7FFL,
    19959L,
    0xFFBFDFEFF7FBFFFFL,
    593981333727348737L,
    21783L,
    0xFFFFBFDFEFF5FFFFL,
    288653413114708096L,
    64836L,
    0xFFFFFFBFDDEBFFFFL,
    306245323880337408L,
    23417L,
    0xFFFFFFFDBBD7FFFFL,
    2310347158529769472L,
    66724L,
    0xFFFFFDFBF7AFFFFFL,
    1187261314343337984L,
    74542L,
    0xFFFDFBF7EFDFFFFFL,
    9188469001234153344L,
    67266L,
    0xFFFBF7EFDFBFFFFFL,
    578171627018125376L,
    26575L,
    0xFFEFF7FBFDFFFDFFL,
    9222949822267379705L,
    67543L,
    0xFFDFEFF7FBFFFBFFL,
    9223020191524333565L,
    24409L,
    0xFFBFDFEFF5FFF5FFL,
    2306265224900983809L,
    30779L,
    0xFFFFBFDDEBFFEBFFL,
    4647151869788945290L,
    17384L,
    0xFFFFFDBBD7FFD7FFL,
    2314815028390789136L,
    18778L,
    0xFFFDFBF7AFFFAFFFL,
    0xFFDFEFFFDE39FFEFL,
    65109L,
    0xFFFBF7EFDFFFDFFFL,
    9223363241302802431L,
    20184L,
    0xFFF7EFDFBFFFBFFFL,
    9221115838862475263L,
    38240L,
    0xFFF7FBFDFFFDFBFFL,
    1090988818544L,
    16459L,
    0xFFEFF7FBFFFBF7FFL,
    9223230887045427193L,
    17432L,
    0xFFDFEFF5FFF5EFFFL,
    9223090009958119421L,
    81040L,
    0xFFBFDDEBFFEBDDFFL,
    4570867472252272639L,
    84946L,
    0xFFFDBBD7FFD7BBFFL,
    292734589976199165L,
    18276L,
    0xFFFBF7AFFFAFF7FFL,
    2305878434105819152L,
    8512L,
    0xFFF7EFDFFFDFEFFFL,
    612472197655543809L,
    78544L,
    0xFFEFDFBFFFBFDFFFL,
    2265045493362695L,
    19974L,
    0xFFFBFDFFFDFBF7FFL,
    553992241216L,
    23850L,
    0xFFF7FBFFFBF7EFFFL,
    276996120608L,
    11056L,
    0xFFEFF5FFF5EFDFFFL,
    27023813833162784L,
    68019L,
    0xFFDDEBFFEBDDBFFFL,
    0xD003FEFE04404080L,
    85965L,
    0xFFBBD7FFD7BBFDFFL,
    1152957239137415242L,
    80524L,
    0xFFF7AFFFAFF7FBFFL,
    9205355920559695872L,
    38221L,
    0xFFEFDFFFDFEFF7FFL,
    1188932777689485200L,
    64647L,
    0xFFDFBFFFBFDFEFFFL,
    9191846633066727416L,
    61320L,
    0xFFFDFFFDFBF7EFFFL,
    279189160064L,
    67281L,
    0xFFFBFFFBF7EFDFFFL,
    139594580032L,
    79076L,
    0xFFF5FFF5EFDFBFFFL,
    279198499008L,
    17115L,
    0xFFEBFFEBDDBFFFFFL,
    4503601791385728L,
    50718L,
    0xFFD7FFD7BBFDFFFFL,
    1152921764453941296L,
    24659L,
    0xFFAFFFAFF7FBFDFFL,
    2307531983360360472L,
    38291L,
    0xFFDFFFDFEFF7FBFFL,
    0xFFFFFFBFEFF80FDCL,
    30605L,
    0xFFBFFFBFDFEFF7FFL,
    68988172306L,
    37759L,
    0xFFFFFDFBF7EFDFFFL,
    576460886529573376L,
    4639L,
    0xFFFFFBF7EFDFBFFFL,
    594475220056658440L,
    21759L,
    0xFFFFF5EFDFBFFFFFL,
    576460752563503233L,
    67799L,
    0xFFFFEBDDBFFFFFFFL,
    1125900041076608L,
    22841L,
    0xFFFFD7BBFDFFFFFFL,
    576460756600479808L,
    66689L,
    0xFFFFAFF7FBFDFFFFL,
    603338863802321408L,
    62548L,
    0xFFFFDFEFF7FBFDFFL,
    0xFFFFFEFFBFEFF81DL,
    66597L,
    0xFFFFBFDFEFF7FBFFL,
    0xFFBFFFEFEFDFF70FL,
    86749L,
    0xFFFDFBF7EFDFBFFFL,
    1152921573842288770L,
    69558L,
    0xFFFBF7EFDFBFFFFFL,
    9203950263191257135L,
    61589L,
    0xFFF5EFDFBFFFFFFFL,
    9188469139741638527L,
    62533L,
    0xFFEBDDBFFFFFFFFFL,
    0xFFF1FFFFFFF7FFC1L,
    64387L,
    0xFFD7BBFDFFFFFFFFL,
    610242147571982367L,
    26581L,
    0xFFAFF7FBFDFFFFFFL,
    26177172852973578L,
    76355L,
    0xFFDFEFF7FBFDFFFFL,
    594615890450845658L,
    11140L,
    0xFFBFDFEFF7FBFDFFL,
    1152922330840178696L
  };

  /** flattened triples: offset, mask, hash */
  public static final long[] R_MAGICS = {
    10890L,
    0xFFFEFEFEFEFEFE81L,
    0x80280013FF84FFFFL,
    56054L,
    0xFFFDFDFDFDFDFD83L,
    6916402019615277055L,
    67495L,
    0xFFFBFBFBFBFBFB85L,
    0xFFEFFAFFEFFDFFFFL,
    72797L,
    0xFFF7F7F7F7F7F789L,
    13511417407733898L,
    17179L,
    0xFFEFEFEFEFEFEF91L,
    13512448205127728L,
    63978L,
    0xFFDFDFDFDFDFDFA1L,
    9008441047646240L,
    56650L,
    0xFFBFBFBFBFBFBFC1L,
    13511211211554864L,
    15929L,
    0xFF7F7F7F7F7F7F81L,
    0xFFA8008DFF09FFF8L,
    55905L,
    0xFFFEFEFEFEFE81FFL,
    9205348825003917308L,
    26301L,
    0xFFFDFDFDFDFD83FFL,
    21992397144066L,
    78100L,
    0xFFFBFBFBFBFB85FFL,
    26389411528776L,
    86245L,
    0xFFF7F7F7F7F789FFL,
    9223345648611360696L,
    75228L,
    0xFFEFEFEFEFEF91FFL,
    0xFFFFCFFE7FCFFFAFL,
    31661L,
    0xFFDFDFDFDFDFA1FFL,
    26391501865056L,
    38053L,
    0xFFBFBFBFBFBFC1FFL,
    0xFFFFE7FF8FBFFFE8L,
    37433L,
    0xFF7F7F7F7F7F81FFL,
    26389090795544L,
    74747L,
    0xFFFEFEFEFE81FEFFL,
    13510901978890243L,
    53847L,
    0xFFFDFDFDFD83FDFFL,
    844476478521343L,
    70952L,
    0xFFFBFBFBFB85FBFFL,
    0xFFFDFFF7FBFEFFF7L,
    49447L,
    0xFFF7F7F7F789F7FFL,
    9205920450792660991L,
    62629L,
    0xFFEFEFEFEF91EFFFL,
    0xFFFEFFDFFDFFDFFFL,
    58996L,
    0xFFDFDFDFDFA1DFFFL,
    8939786031088007199L,
    36009L,
    0xFFBFBFBFBFC1BFFFL,
    2323998178495432720L,
    21230L,
    0xFF7F7F7F7F817FFFL,
    288371136597606656L,
    51882L,
    0xFFFEFEFE81FEFEFFL,
    18049583150530568L,
    11841L,
    0xFFFDFDFD83FDFDFFL,
    4505798785105924L,
    25794L,
    0xFFFBFBFB85FBFBFFL,
    0xFFFDFEFFF7FBFFF7L,
    49689L,
    0xFFF7F7F789F7F7FFL,
    0xFEBF7DFFF8FEFFF9L,
    63400L,
    0xFFEFEFEF91EFEFFFL,
    0xC00000FFE001FFE0L,
    33958L,
    0xFFDFDFDFA1DFDFFFL,
    2308130543272738823L,
    21991L,
    0xFFBFBFBFC1BFBFFFL,
    0xBFFBFAFFFB683F7FL,
    45618L,
    0xFF7F7F7F817F7FFFL,
    578702106657038400L,
    70134L,
    0xFFFEFE81FEFEFEFFL,
    2305852801742274608L,
    75944L,
    0xFFFDFD83FDFDFDFFL,
    581969641496L,
    68392L,
    0xFFFBFB85FBFBFBFFL,
    1112398102552L,
    66472L,
    0xFFF7F789F7F7F7FFL,
    4611686574627225624L,
    23236L,
    0xFFEFEF91EFEFEFFFL,
    36169744961110010L,
    19067L,
    0xFFDFDFA1DFDFDFFFL,
    4611712960757628934L,
    0L,
    0xFFBFBFC1BFBFBFFFL,
    0xFFFFFF7FFFBFBFFFL,
    43566L,
    0xFF7F7F817F7F7FFFL,
    140874929406016L,
    29810L,
    0xFFFE81FEFEFEFEFFL,
    2305845220786317312L,
    65558L,
    0xFFFD83FDFDFDFDFFL,
    0xFFFFF9FF7CFFF3FFL,
    77684L,
    0xFFFB85FBFBFBFBFFL,
    276144592896L,
    73350L,
    0xFFF789F7F7F7F7FFL,
    2305843214839435264L,
    61765L,
    0xFFEF91EFEFEFEFFFL,
    0xFFFFFF6FFE7FCFFDL,
    49282L,
    0xFFDFA1DFDFDFDFFFL,
    0xBFF7EFFFBFC00FFFL,
    78840L,
    0xFFBFC1BFBFBFBFFFL,
    68853737476L,
    82904L,
    0xFF7F817F7F7F7FFFL,
    0xFFFBFFEFA7FFA7FEL,
    24594L,
    0xFF81FEFEFEFEFEFFL,
    5669358141480L,
    9513L,
    0xFF83FDFDFDFDFDFFL,
    571239694356L,
    29012L,
    0xFF85FBFBFBFBFBFFL,
    0x8000002B00408028L,
    27684L,
    0xFF89F7F7F7F7F7FFL,
    4611686156948013096L,
    27901L,
    0xFF91EFEFEFEFEFFFL,
    8646911422261395496L,
    61477L,
    0xFFA1DFDFDFDFDFFFL,
    103093927960L,
    25719L,
    0xFFC1BFBFBFBFBFFFL,
    1769914688190546000L,
    50020L,
    0xFF817F7F7F7F7FFFL,
    2306924928660668456L,
    41547L,
    0x81FEFEFEFEFEFEFFL,
    0xFFFFF37EEFEFDFBEL,
    4750L,
    0x83FDFDFDFDFDFDFFL,
    4611688767357457345L,
    6014L,
    0x85FBFBFBFBFBFBFFL,
    0xBF7FFEFFBFFAF71FL,
    41529L,
    0x89F7F7F7F7F7F7FFL,
    0xFFFDFFFF777B7D6EL,
    84192L,
    0x91EFEFEFEFEFEFFFL,
    0xEEFFFFEFF0080BFEL,
    33433L,
    0xA1DFDFDFDFDFDFFFL,
    0xAFE0000FFF780402L,
    8555L,
    0xC1BFBFBFBFBFBFFFL,
    0xEE73FFFBFFBB77FEL,
    1009L,
    0x817F7F7F7F7F7FFFL,
    562962977269890L
  };

  /** 88507 entries loaded from PrecomputedTables.bin */
  public static final long[] LOOKUP_TABLE = new long[88507];

  public static final long[] SLIDER_PEXT;

  public static final int[] B_BASE = new int[64];
  public static final long[] B_MASK = new long[64];
  public static final long[] B_HASH = new long[64];
  public static final int[] R_BASE = new int[64];
  public static final long[] R_MASK = new long[64];
  public static final long[] R_HASH = new long[64];

  public static final long[] PAWN_ATK_W = new long[64];
  public static final long[] PAWN_ATK_B = new long[64];

  public static final long[] KING_ATK = new long[64];
  public static final long[] KNIGHT_ATK = new long[64];
  public static final long[] BETWEEN = new long[64 * 64];

  /** True iff Long.compress (→ PEXT) is available *and* not disabled by property. */
  public static final boolean USE_PEXT = true;

  static {
    try (var in = PreCompMoveGenTables.class.getResourceAsStream("PrecomputedTables.Magic.bin")) {
      if (in == null) throw new IllegalStateException("PrecomputedTables.Magic.bin missing");
      var buf = java.nio.ByteBuffer.wrap(in.readAllBytes()).order(java.nio.ByteOrder.LITTLE_ENDIAN);
      buf.asLongBuffer().get(LOOKUP_TABLE);
    } catch (Exception e) {
      throw new ExceptionInInitializerError(e);
    }
    try (var in = PreCompMoveGenTables.class.getResourceAsStream("PrecomputedTables.Pext.bin")) {
      if (in == null) throw new IllegalStateException("PrecomputedTables.Pext.bin missing");

      byte[] raw = in.readAllBytes(); // full file
      int n = raw.length >>> 3; // 8-bytes → longs

      SLIDER_PEXT = new long[n]; // exact fit
      java.nio.ByteBuffer.wrap(raw)
          .order(java.nio.ByteOrder.LITTLE_ENDIAN)
          .asLongBuffer()
          .get(SLIDER_PEXT);
    } catch (Exception e) {
      throw new ExceptionInInitializerError(e);
    }
    for (int s = 0; s < 64; ++s) {
      B_BASE[s] = (int) B_MAGICS[s * 3];
      B_MASK[s] = B_MAGICS[s * 3 + 1];
      B_HASH[s] = B_MAGICS[s * 3 + 2];
      R_BASE[s] = (int) R_MAGICS[s * 3];
      R_MASK[s] = R_MAGICS[s * 3 + 1];
      R_HASH[s] = R_MAGICS[s * 3 + 2];
    }
    for (int sq = 0; sq < 64; ++sq) {
      int r = sq >>> 3, f = sq & 7;
      if (r < 7 && f > 0) PAWN_ATK_W[sq] |= 1L << (sq + 7);
      if (r < 7 && f < 7) PAWN_ATK_W[sq] |= 1L << (sq + 9);
      if (r > 0 && f > 0) PAWN_ATK_B[sq] |= 1L << (sq - 9);
      if (r > 0 && f < 7) PAWN_ATK_B[sq] |= 1L << (sq - 7);
    }
    for (int sq = 0; sq < 64; ++sq) {
      int r = sq >>> 3, f = sq & 7;

      /* king & knight tables */
      long k = 0;
      for (int dr = -1; dr <= 1; ++dr)
        for (int df = -1; df <= 1; ++df) if ((dr | df) != 0) k = addToMask(k, r + dr, f + df);
      KING_ATK[sq] = k;
      KNIGHT_ATK[sq] = knightMask(r, f);
    }
    for (int a = 0; a < 64; ++a)
      for (int b = 0; b < 64; ++b) BETWEEN[a * 64 + b] = between(a, b); // strict – no end-points
  }

  private static long addToMask(long m, int r, int f) {
    return (r >= 0 && r < 8 && f >= 0 && f < 8) ? m | (1L << ((r << 3) | f)) : m;
  }

  private static long knightMask(int r, int f) {
    long m = 0;
    int[] dr = {-2, -1, 1, 2, 2, 1, -1, -2};
    int[] df = {1, 2, 2, 1, -1, -2, -2, -1};
    for (int i = 0; i < 8; i++) m = addToMask(m, r + dr[i], f + df[i]);
    return m;
  }

  private static boolean initUsePext() {
    /* 1) platform screen ─ JDK 21+ on x86-64 only ──────────────────── */
    if (Runtime.version().feature() < 21) return false;

    String archRaw = System.getProperty("os.arch");
    String arch = (archRaw == null) ? "" : archRaw.toLowerCase(Locale.ROOT);

    // Accept all typical spellings: “x86_64”, “amd64”, “x64”, “x86-64”
    boolean isX86_64 =
        arch.equals("x86_64")
            || arch.equals("amd64")
            || arch.equals("x64")
            || arch.equals("x86-64");

    if (!isX86_64) return false;

    /* 2) was BMI2 explicitly disabled? ─────────────────────────────── */
    try {
      // 2a) command-line flags
      var rtArgs = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments();
      for (String a : rtArgs) if (a.equals("-XX:-UseBMI2Instructions")) return false;

      // 2b) live VM option (HotSpot only, optional module)
      Class<?> raw =
          Class.forName(
              "com.sun.management.HotSpotDiagnosticMXBean",
              false,
              ClassLoader.getSystemClassLoader());

      var bean =
          java.lang.management.ManagementFactory.getPlatformMXBean(
              raw.asSubclass(java.lang.management.PlatformManagedObject.class));

      if (bean != null) {
        Object opt = raw.getMethod("getVMOption", String.class).invoke(bean, "UseBMI2Instructions");
        String val = (String) opt.getClass().getMethod("getValue").invoke(opt);
        if (!Boolean.parseBoolean(val)) // BMI2 turned off
        return false;
      }
    } catch (Throwable ignored) {
      /* Non-HotSpot VM or jdk.management absent → fall through        */
    }

    /* All checks passed → enable PEXT path */
    return true;
  }

  /** squares strictly between two aligned squares (0 if not on same ray) */
  private static long between(int from, int to) {

    if (from == to) return 0L;

    int df = (to & 7) - (from & 7); // file  difference  (-7 … +7)
    int dr = (to >>> 3) - (from >>> 3); // rank difference  (-7 … +7)

    int step;

    /*  ── determine ray direction (rank, file, or diagonal) ─────────── */
    if (dr == 0) step = (df > 0 ? 1 : -1); // same rank
    else if (df == 0) step = (dr > 0 ? 8 : -8); // same file
    else if (Math.abs(df) == Math.abs(dr)) // true diagonal
    step =
          (dr > 0
              ? (df > 0 ? 9 : 7) // up-right  or up-left
              : (df > 0 ? -7 : -9)); // down-right or down-left
    else return 0L; // not aligned → nothing in-between

    /*  ── walk from+step to (exclusive) ─────────────────────────────── */
    long bb = 0L;
    for (int sq = from + step; sq != to; sq += step) bb |= 1L << sq;

    return bb;
  }
}

C:\dev\Helios\src>(echo.   & echo // File: SearchImpl.java   & type "C:\dev\Helios\src\main\java\core\impl\SearchImpl.java" ) 
 
// File: SearchImpl.java 
package core.impl;

import core.contracts.*;
import core.records.SearchResult;
import core.records.SearchSpec;

import java.util.concurrent.CompletableFuture;

/**
 * Thin façade that delegates all heavy lifting to the configured WorkerPool.
 * Nothing here is pool-specific – you can plug in LazySmpWorkerPoolImpl or any
 * other WorkerPool implementation.
 */
public final class SearchImpl implements Search {

    /* immutable engine parts */
    private final PositionFactory positionFactory;
    private final MoveGenerator   moveGenerator;

    /* configurable services */
    private Evaluator           evaluator;
    private TranspositionTable  transpositionTable;
    private WorkerPool          workerPool;
    private TimeManager         timeManager;

    /* thread option remembered for future pool swaps */
    private int requestedThreads = 1;

    public SearchImpl(PositionFactory pf,
                      MoveGenerator   mg,
                      Evaluator       eval,
                      WorkerPool      pool,
                      TimeManager     tm) {

        this.positionFactory = pf;
        this.moveGenerator   = mg;
        this.evaluator       = eval;
        this.workerPool      = pool;
        this.timeManager     = tm;
    }

    /* ── setters required by Search interface ───────────────────── */

    @Override public void setEvaluator(Evaluator e)              { this.evaluator = e; }
    @Override public void setTranspositionTable(TranspositionTable tt) { this.transpositionTable = tt; }

    @Override public void setThreads(int n) {
        this.requestedThreads = n;
        if (workerPool != null) workerPool.setParallelism(n);
    }

    @Override public void setWorkerPool(WorkerPool pool) {
        if (this.workerPool != null) {
            try { this.workerPool.close(); } catch (Exception ignored) {}
        }
        this.workerPool = pool;
        if (pool != null) pool.setParallelism(requestedThreads);
    }

    @Override public void setTimeManager(TimeManager tm) { this.timeManager = tm; }

    /* ── synchronous / asynchronous search ─────────────────────── */

    @Override
    public SearchResult search(long[] bb, SearchSpec spec, InfoHandler ih) {
        if (workerPool == null)
            throw new IllegalStateException("WorkerPool not set");
        return workerPool
                .startSearch(bb, spec,
                        positionFactory, moveGenerator,
                        evaluator, transpositionTable,
                        timeManager, ih)
                .join(); // block caller
    }

    @Override
    public CompletableFuture<SearchResult> searchAsync(long[] bb,
                                                       SearchSpec spec,
                                                       InfoHandler ih) {
        return CompletableFuture.supplyAsync(() -> search(bb, spec, ih));
    }

    /* ── UCI helpers ───────────────────────────────────────────── */

    @Override public void stop()       { if (workerPool != null) workerPool.stopSearch(); }
    @Override public void ponderHit()  { /* not implemented */  }

    @Override
    public void close() {
        if (workerPool != null) {
            try { workerPool.close(); } catch (Exception ignored) {}
        }
    }
}

C:\dev\Helios\src>(echo.   & echo // File: TimeManagerImpl.java   & type "C:\dev\Helios\src\main\java\core\impl\TimeManagerImpl.java" ) 
 
// File: TimeManagerImpl.java 
package core.impl;

import core.contracts.TimeManager;
import core.contracts.UciOptions;
import core.records.SearchSpec;
import core.records.TimeAllocation;

/** 1-for-1 port of Stockfish’s TimeMan::calcOptimumTime() */
public final class TimeManagerImpl implements TimeManager {

    private static final int DEFAULT_MOVE_OVERHEAD_MS = 50;
    private static final int DEFAULT_MOVES_TO_GO      = 50;  // ← Stockfish uses 50

    private final UciOptions options;

    public TimeManagerImpl(UciOptions options) {
        this.options = options;
    }

    @Override
    public TimeAllocation calculate(SearchSpec spec, boolean whiteToMove) {

        /* “go infinite / ponder” → think forever */
        if (spec.infinite() || spec.ponder())
            return new TimeAllocation(Long.MAX_VALUE, Long.MAX_VALUE);

        /* strict “movetime N” from the GUI */
        if (spec.moveTimeMs() > 0) {
            long slice = Math.max(1, spec.moveTimeMs() - moveOverhead());
            return new TimeAllocation(slice, slice);
        }

        /* regular clock */
        long myTime = whiteToMove ? spec.wTimeMs() : spec.bTimeMs();
        long myInc  = whiteToMove ? spec.wIncMs()  : spec.bIncMs();

        int  mtg    = spec.movesToGo() > 0
                ? Math.min(spec.movesToGo(), 50)   // Stockfish caps at 50
                : DEFAULT_MOVES_TO_GO;

        long overhead = moveOverhead();

        /* “effective” remaining time (SF formula) */
        long timeLeft = Math.max(
                1,
                myTime + myInc * (mtg - 1) - overhead * (2 + mtg)
        );

        /* decide how much of it we spend now */
        double optScale;
        if (spec.movesToGo() == 0) {                // sudden-death
            optScale = Math.min(0.025,
                    0.214 * myTime / (double) timeLeft);
        } else {                                    // fixed moves-to-go
            optScale = Math.min(0.95 / mtg,
                    0.88 * myTime / (double) timeLeft);
        }

        long optimum = Math.max(1, (long) (optScale * timeLeft));
        long maximum = Math.max(1, (long) (myTime * 0.8) - overhead);

        if (optimum > maximum) optimum = maximum;   // paranoia

        return new TimeAllocation(optimum, maximum);
    }

    /* helper ---------------------------------------------------------------- */

    private int moveOverhead() {
        String v = options.getOptionValue("Move Overhead");
        return v != null ? Integer.parseInt(v) : DEFAULT_MOVE_OVERHEAD_MS;
    }
}

C:\dev\Helios\src>(echo.   & echo // File: TranspositionTableImpl.java   & type "C:\dev\Helios\src\main\java\core\impl\TranspositionTableImpl.java" ) 
 
// File: TranspositionTableImpl.java 
package core.impl;

import core.contracts.TranspositionTable;

import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;
import java.util.Arrays;

import static core.constants.CoreConstants.*;

/** Lock-free, bucketed transposition table – zero object allocation. */
public final class TranspositionTableImpl implements TranspositionTable {

    /* ── addressing & meta ──────────────────────────────────── */

    private static final int INDEX_BITS  = 30;               // 2ⁿ buckets ≤ int
    private static final int INDEX_MASK  = (1 << INDEX_BITS) - 1;
    private static final int HIT_MASK    = 1 << INDEX_BITS;  // mark probe hit

    private static int tagOf(long zobrist)   { return (int) zobrist & 0xFFFF; }

    /* ── storage ───────────────────────────────────────────── */

    private EntryImpl[] entries;       // flat array (bucketed view)
    private int         bucketCount;   // (#entries / ENTRIES_PER_BUCKET)
    private byte        age;           // 0-31, wraps

    /* VarHandle for cheap volatile / acquire access */
    private static final VarHandle ENTRY_H;

    static {
        ENTRY_H = MethodHandles.arrayElementVarHandle(EntryImpl[].class);
    }

    /* ── ctor & life-cycle ─────────────────────────────────── */

    public TranspositionTableImpl(int megaBytes) { resize(megaBytes); }

    @Override
    public synchronized void resize(int megaBytes) {
        long bytesRequested = (long) megaBytes * 1_048_576;
        long wantedBuckets  = bytesRequested / Bucket.BYTES;

        long maxBuckets = INDEX_MASK / ENTRIES_PER_BUCKET;
        if (wantedBuckets == 0 || wantedBuckets > maxBuckets)
            throw new IllegalArgumentException("Illegal TT size: " + megaBytes + " MB");

        bucketCount        = (int) wantedBuckets;
        int slots          = bucketCount * ENTRIES_PER_BUCKET;
        entries            = new EntryImpl[slots];
        for (int i = 0; i < slots; i++) entries[i] = new EntryImpl();

        clear();
    }

    @Override public void clear()        { Arrays.stream(entries).forEach(EntryImpl::clear); age = 0; }
    @Override public void incrementAge() { age = (byte) ((age + 1) & (MAX_AGE - 1)); }

    /* ── bucket addressing ─────────────────────────────────── */

    private int bucketBase(long zKey) {
        long hi = Math.unsignedMultiplyHigh(zKey, Integer.toUnsignedLong(bucketCount));
        return (int) (hi * ENTRIES_PER_BUCKET);             // 0 … slots-ENTRIES
    }

    /* ── primary API ───────────────────────────────────────── */

    @Override
    public Entry probe(long zKey) {

        int base = bucketBase(zKey);
        int tag  = tagOf(zKey);

        /* 1) exact hit? */
        for (int i = 0; i < ENTRIES_PER_BUCKET; i++) {
            EntryImpl e = (EntryImpl) ENTRY_H.getAcquire(entries, base + i);
            if (e.key16 == tag && !e.isEmpty()) return e;         // live hit
        }

        /* 2) otherwise pick worst victim */
        EntryImpl victim = (EntryImpl) ENTRY_H.get(entries, base);
        int worstQ       = qualityOf(victim);

        for (int i = 1; i < ENTRIES_PER_BUCKET; i++) {
            EntryImpl e = (EntryImpl) ENTRY_H.get(entries, base + i);
            int q       = qualityOf(e);
            if (q < worstQ) { worstQ = q; victim = e; }
        }
        return victim;
    }

    /* ── helpers ───────────────────────────────────────────── */

    private int qualityOf(EntryImpl e) {
        if (e.isEmpty()) return Integer.MIN_VALUE;
        int ageDist = e.getAgeDistance(age);
        return e.depth - 8 * ageDist;                        // Stockfish heuristic
    }

    @Override
    public int hashfull() {
        int filled = 0, sample = Math.min(1000 * ENTRIES_PER_BUCKET, entries.length);
        for (int i = 0; i < sample; i++) {
            EntryImpl e = entries[i];
            if (!e.isEmpty() && e.getAge() == age) ++filled;
        }
        return (filled * 1000) / sample;
    }

    /* ── internal entry impl ──────────────────────────────── */

    private static final class EntryImpl implements TranspositionTable.Entry {

        /* layout matches the C++ version, but as fields */
        short  key16;        // 0
        short  staticEval;   // 2
        byte   agePvBound;   // 4
        byte   depth;        // 5
        int    move;         // 6 (20 bits used)
        short  score;        // 10
        // ---- total 12 bytes; padded to 16 by JVM ----

        /* constant helpers */
        private static final byte PV_MASK   = 4;
        private static final byte BOUND_MASK= 3;

        @Override public boolean matches(long z)        { return key16 == (short) z; }
        @Override public boolean isEmpty()              { return score == 0 && agePvBound == 0; }
        @Override public int  getAge()                  { return (agePvBound >>> 3) & 0x1F; }
        @Override public int  getAgeDistance(byte tblAge){
            return (MAX_AGE + tblAge - getAge()) & (MAX_AGE - 1);
        }
        @Override public int  getDepth()                { return depth & 0xFF; }
        @Override public int  getBound()                { return agePvBound & BOUND_MASK; }
        @Override public int  getMove()                 { return move; }
        @Override public int  getStaticEval()           { return staticEval; }
        @Override public boolean wasPv()                { return (agePvBound & PV_MASK) != 0; }

        @Override public int getScore(int ply) {
            int s = score;
            if (s == SCORE_NONE)                   return SCORE_NONE;
            if (s >= SCORE_TB_WIN_IN_MAX_PLY)      return s - ply;
            if (s <= SCORE_TB_LOSS_IN_MAX_PLY)     return s + ply;
            return s;
        }

        @Override
        public void store(long zKey, int flag, int depth, int move,
                          int score, int staticEval, boolean isPv,
                          int ply, byte tblAge) {

            /* slot’s current quality for overwrite test */
            boolean hit         = matches(zKey);
            int     curDepth    = hit ? this.depth & 0xFF : 0;
            int     ageDist     = hit ? getAgeDistance(tblAge) : 0;

            boolean overwrite = (flag == FLAG_EXACT)
                    || (!hit)
                    || (ageDist != 0)
                    || (depth + (isPv ? 6 : 4) > curDepth);

            if (!overwrite) return;

            if (move == 0 && hit) move = this.move;          // keep old best

            /* mate-distance encoding (SF style) */
            if (score != SCORE_NONE) {
                if (score >= SCORE_TB_WIN_IN_MAX_PLY)      score += ply;
                else if (score <= SCORE_TB_LOSS_IN_MAX_PLY) score -= ply;
            }

            /* commit – single thread owns the entry, so plain writes fine */
            this.key16       = (short) zKey;
            this.staticEval  = (short) staticEval;
            this.agePvBound  = (byte) (flag | (isPv ? PV_MASK : 0) | (tblAge << 3));
            this.depth       = (byte) depth;
            this.move        = move;
            this.score       = (short) score;
        }

        /* helper for clear() */
        void clear() { key16 = staticEval = score = 0; agePvBound = depth = 0; move = 0; }
    }

    /* dummy struct just for size calculation */
    private static final class Bucket { static final int BYTES = ENTRIES_PER_BUCKET * 16; }
}

C:\dev\Helios\src>(echo.   & echo // File: UciHandlerImpl.java   & type "C:\dev\Helios\src\main\java\core\impl\UciHandlerImpl.java" ) 
 
// File: UciHandlerImpl.java 
package core.impl;

import core.contracts.*;
import core.records.SearchInfo;
import core.records.SearchResult;
import core.records.SearchSpec;
import main.Main;

import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Universal-Chess-Interface front-end.
 *
 * <p>All interaction with {@link Search} happens behind a single
 * monitor ({@code searchLock}) so that:</p>
 * <ul>
 *   <li>only <em>one</em> search can run at a time</li>
 *   <li>“info …” and “bestmove …” from an <em>old</em> search are
 *       never printed after a new position / search has started</li>
 * </ul>
 */
public final class UciHandlerImpl implements UciHandler {
    public static final List<String> BENCH_FENS = List.of(
            "r3k2r/2pb1ppp/2pp1q2/p7/1nP1B3/1P2P3/P2N1PPP/R2QK2R w KQkq a6 0 14",
            "4rrk1/2p1b1p1/p1p3q1/4p3/2P2n1p/1P1NR2P/PB3PP1/3R1QK1 b - - 2 24",
            "r3qbrk/6p1/2b2pPp/p3pP1Q/PpPpP2P/3P1B2/2PB3K/R5R1 w - - 16 42",
            "6k1/1R3p2/6p1/2Bp3p/3P2q1/P7/1P2rQ1K/5R2 b - - 4 44",
            "8/8/1p2k1p1/3p3p/1p1P1P1P/1P2PK2/8/8 w - - 3 54",
            "7r/2p3k1/1p1p1qp1/1P1Bp3/p1P2r1P/P7/4R3/Q4RK1 w - - 0 36",
            "r1bq1rk1/pp2b1pp/n1pp1n2/3P1p2/2P1p3/2N1P2N/PP2BPPP/R1BQ1RK1 b - - 2 10",
            "3r3k/2r4p/1p1b3q/p4P2/P2Pp3/1B2P3/3BQ1RP/6K1 w - - 3 87",
            "2r4r/1p4k1/1Pnp4/3Qb1pq/8/4BpPp/5P2/2RR1BK1 w - - 0 42",
            "4q1bk/6b1/7p/p1p4p/PNPpP2P/KN4P1/3Q4/4R3 b - - 0 37",
            "2q3r1/1r2pk2/pp3pp1/2pP3p/P1Pb1BbP/1P4Q1/R3NPP1/4R1K1 w - - 2 34",
            "1r2r2k/1b4q1/pp5p/2pPp1p1/P3Pn2/1P1B1Q1P/2R3P1/4BR1K b - - 1 37",
            "r3kbbr/pp1n1p1P/3ppnp1/q5N1/1P1pP3/P1N1B3/2P1QP2/R3KB1R b KQkq b3 0 17",
            "8/6pk/2b1Rp2/3r4/1R1B2PP/P5K1/8/2r5 b - - 16 42",
            "1r4k1/4ppb1/2n1b1qp/pB4p1/1n1BP1P1/7P/2PNQPK1/3RN3 w - - 8 29",
            "8/p2B4/PkP5/4p1pK/4Pb1p/5P2/8/8 w - - 29 68",
            "3r4/ppq1ppkp/4bnp1/2pN4/2P1P3/1P4P1/PQ3PBP/R4K2 b - - 2 20",
            "5rr1/4n2k/4q2P/P1P2n2/3B1p2/4pP2/2N1P3/1RR1K2Q w - - 1 49",
            "1r5k/2pq2p1/3p3p/p1pP4/4QP2/PP1R3P/6PK/8 w - - 1 51",
            "q5k1/5ppp/1r3bn1/1B6/P1N2P2/BQ2P1P1/5K1P/8 b - - 2 34",
            "r1b2k1r/5n2/p4q2/1ppn1Pp1/3pp1p1/NP2P3/P1PPBK2/1RQN2R1 w - - 0 22",
            "r1bqk2r/pppp1ppp/5n2/4b3/4P3/P1N5/1PP2PPP/R1BQKB1R w KQkq - 0 5",
            "r1bqr1k1/pp1p1ppp/2p5/8/3N1Q2/P2BB3/1PP2PPP/R3K2n b Q - 1 12",
            "r1bq2k1/p4r1p/1pp2pp1/3p4/1P1B3Q/P2B1N2/2P3PP/4R1K1 b - - 2 19",
            "r4qk1/6r1/1p4p1/2ppBbN1/1p5Q/P7/2P3PP/5RK1 w - - 2 25",
            "r7/6k1/1p6/2pp1p2/7Q/8/p1P2K1P/8 w - - 0 32",
            "r3k2r/ppp1pp1p/2nqb1pn/3p4/4P3/2PP4/PP1NBPPP/R2QK1NR w KQkq - 1 5",
            "3r1rk1/1pp1pn1p/p1n1q1p1/3p4/Q3P3/2P5/PP1NBPPP/4RRK1 w - - 0 12",
            "5rk1/1pp1pn1p/p3Brp1/8/1n6/5N2/PP3PPP/2R2RK1 w - - 2 20",
            "8/1p2pk1p/p1p1r1p1/3n4/8/5R2/PP3PPP/4R1K1 b - - 3 27",
            "8/4pk2/1p1r2p1/p1p4p/Pn5P/3R4/1P3PP1/4RK2 w - - 1 33",
            "8/5k2/1pnrp1p1/p1p4p/P6P/4R1PK/1P3P2/4R3 b - - 1 38",
            "8/8/1p1kp1p1/p1pr1n1p/P6P/1R4P1/1P3PK1/1R6 b - - 15 45",
            "8/8/1p1k2p1/p1prp2p/P2n3P/6P1/1P1R1PK1/4R3 b - - 5 49",
            "8/8/1p4p1/p1p2k1p/P2npP1P/4K1P1/1P6/3R4 w - - 6 54"
    );
    /* ── engine singletons ─────────────────────────────────────── */
    private final Search          search;
    private final PositionFactory pf;
    private final UciOptions      opts;
    private final MoveGenerator mg;

    /* ── mutable engine state (guarded by searchLock) ──────────── */
    private final Object searchLock = new Object();

    /** side effect-free copy of the current position */
    private long[] currentPos;
    /** all previous Zobrist keys (for 3-fold repetition) */
    private final List<Long> history = new ArrayList<>();

    /** handle of the search currently in flight (nullable) */
    private CompletableFuture<SearchResult> searchFuture;
    /** incremented for every new “go”, used to ignore stale callbacks */
    private int searchId = 0;

    /* ── construction ──────────────────────────────────────────── */
    public UciHandlerImpl(Search search,
                          PositionFactory pf,
                          UciOptions opts,
                          MoveGenerator mg) {
        this.search = search;
        this.pf     = pf;
        this.opts   = opts;
        this.mg    = mg;

        // start-pos
        this.currentPos = pf.fromFen(
                "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
    }

    /* ── main loop ─────────────────────────────────────────────── */
    @Override public void runLoop() {
        try (Scanner in = new Scanner(System.in)) {
            while (in.hasNextLine()) {
                String line = in.nextLine().trim();
                if (!line.isEmpty() && handle(line)) break;   // “quit” → exit
            }
        }
    }

    /* ── router ───────────────────────────────────────────────── */
    private boolean handle(String cmd) {
        String[] t = cmd.split("\\s+");

        return switch (t[0]) {
            case "uci"          -> { cmdUci();        yield false; }
            case "isready"      -> { System.out.println("readyok"); yield false; }
            case "ucinewgame"   -> { cmdNewGame();    yield false; }
            case "setoption"    -> { opts.setOption(cmd); yield false; }
            case "position"     -> { cmdPosition(t);  yield false; }
            case "go"           -> { cmdGo(t);        yield false; }
            case "stop"         -> { cmdStop();       yield false; }
            case "ponderhit"    -> { search.ponderHit(); yield false; }
            case "quit"         -> { cmdStop();       yield true;  }
            default             -> { // unknown
                System.out.println("info string Unknown command: " + cmd);
                yield false;
            }
        };
    }

    /* ── UCI commands ─────────────────────────────────────────── */

    private void cmdUci() {
        System.out.println("id name Helios");
        System.out.println("id author Your Name");
        opts.printOptions();
        System.out.println("uciok");
    }

    private void cmdNewGame() {
        synchronized (searchLock) {
            cancelRunningSearch();
            opts.getTranspositionTable().clear();
            history.clear();
        }
    }

    private void cmdStop() {
        synchronized (searchLock) { cancelRunningSearch(); }
    }

    private void cmdPosition(String[] t) {
        synchronized (searchLock) {
            cancelRunningSearch();

            int i = 1;
            if ("startpos".equals(t[i])) {                       // startpos
                currentPos = pf.fromFen(
                        "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
                i++;
            } else if ("fen".equals(t[i])) {                     // FEN …
                StringBuilder fen = new StringBuilder();
                while (++i < t.length && !"moves".equals(t[i]))
                    fen.append(t[i]).append(' ');
                currentPos = pf.fromFen(fen.toString().trim());
            } else {
                return;                                          // malformed
            }

            history.clear();
            history.add(currentPos[PositionFactory.HASH]);

            /* optional move list */
            if (i < t.length && "moves".equals(t[i])) {
                MoveGenerator mg = new MoveGeneratorImpl();
                for (int k = i + 1; k < t.length; k++) {
                    int mv = UciMove.stringToMove(currentPos, t[k], mg);
                    if (mv != 0 && pf.makeMoveInPlace(currentPos, mv, mg))
                        history.add(currentPos[PositionFactory.HASH]);
                }
                history.remove(history.size() - 1);              // last == current
            }
        }
    }

    private void cmdGo(String[] t) {
        /* 1) build SearchSpec ---------------------------------- */
        SearchSpec.Builder b = new SearchSpec.Builder();
        for (int i = 1; i < t.length; i++)
            switch (t[i]) {
                case "wtime"     -> b.wTimeMs(Long.parseLong(t[++i]));
                case "btime"     -> b.bTimeMs(Long.parseLong(t[++i]));
                case "winc"      -> b.wIncMs(Long.parseLong(t[++i]));
                case "binc"      -> b.bIncMs(Long.parseLong(t[++i]));
                case "movestogo" -> b.movesToGo(Integer.parseInt(t[++i]));
                case "depth"     -> b.depth(Integer.parseInt(t[++i]));
                case "nodes"     -> b.nodes(Long.parseLong(t[++i]));
                case "movetime"  -> b.moveTimeMs(Long.parseLong(t[++i]));
                case "infinite"  -> b.infinite(true);
                case "ponder"    -> b.ponder(true);
            }

        final int myId;
        synchronized (searchLock) {
            cancelRunningSearch();

            myId = ++searchId;
            b.history(new ArrayList<>(history));

            opts.getTranspositionTable().incrementAge();

            searchFuture = search.searchAsync(
                    currentPos.clone(),
                    b.build(),
                    info -> { if (myId == searchId) printInfo(info); });
        }

        /* handle completion asynchronously */
        searchFuture.thenAccept(r -> {
            synchronized (searchLock) {
                if (myId == searchId) printResult(r);
            }
        }).exceptionally(ex -> {
            System.out.println("info string search error: " + ex);
            return null;
        });
    }

    /* ── local helpers ────────────────────────────────────────── */
    private static List<String> readAllLinesSilently(String file) {
        try { return Files.readAllLines(Paths.get(file)); }
        catch (IOException ex) {
            System.out.printf("info string bench: cannot read %s (%s)%n", file, ex);
            return List.of();
        }
    }

    private static List<String> loadResourceLines(String r) {     // <-- unused now
        try (var in = UciHandlerImpl.class.getResourceAsStream(r);
             var br = new java.io.BufferedReader(new InputStreamReader(in))) {
            return br.lines().filter(l -> !l.isBlank())
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static int  toInt (String s, int  d) { try { return Integer.parseInt(s);} catch(Exception e){return d;}}
    private static long toLong(String s, long d) { try { return Long.parseLong(s);} catch(Exception e){return d;}}



    /* ── helpers ─────────────────────────────────────────────── */

    /** stop & wait for any running search */
    private void cancelRunningSearch() {
        if (searchFuture != null && !searchFuture.isDone()) {
            search.stop();
            searchFuture.join();     // wait until fully stopped
        }
        searchFuture = null;
    }

    private void printInfo(SearchInfo si) {
        StringBuilder sb = new StringBuilder("info");
        sb.append(" depth ").append(si.depth());
        if (si.selDepth() > 0) sb.append(" seldepth ").append(si.selDepth());
        sb.append(" score ").append(UciScore.format(si.scoreCp(), si.isMate()));
        sb.append(" nodes ").append(si.nodes());
        sb.append(" nps ").append(si.nps());
        sb.append(" time ").append(si.timeMs());
        if (si.hashFullPermil() >= 0) sb.append(" hashfull ").append(si.hashFullPermil());
        if (!si.pv().isEmpty()) {
            sb.append(" pv");
            si.pv().forEach(mv -> sb.append(' ').append(UciMove.moveToUci(mv)));
        }
        System.out.println(sb);
    }

    private void printResult(SearchResult r) {
        String best   = UciMove.moveToUci(r.bestMove());
        String ponder = r.ponderMove() == 0 ? "" :
                " ponder " + UciMove.moveToUci(r.ponderMove());
        System.out.println("bestmove " + best + ponder);
    }

    /* ── tiny utility helpers ────────────────────────────────── */

    private static final class UciMove {

        static String moveToUci(int m) {
            if (m == 0) return "0000";
            int from = (m >>> 6) & 63, to = m & 63;
            String res = sq(from) + sq(to);
            if (((m >>> 14) & 3) == 1)                       // promotion
                res += "nbrq".charAt((m >>> 12) & 3);
            return res;
        }

        static int stringToMove(long[] pos, String s, MoveGenerator mg) {
            int[] list = new int[256];
            boolean inCheck = PositionFactory.whiteToMove(
                    pos[PositionFactory.META])
                    ? mg.kingAttacked(pos, true)
                    : mg.kingAttacked(pos, false);

            int n = inCheck ? mg.generateEvasions(pos, list, 0)
                    : mg.generateQuiets(pos, list,
                    mg.generateCaptures(pos, list, 0));

            for (int i = 0; i < n; i++)
                if (moveToUci(list[i]).equals(s)) return list[i];
            return 0;
        }

        private static String sq(int s) {
            return "" + (char) ('a' + (s & 7)) + (1 + (s >>> 3));
        }
    }

    private static final class UciScore {
        static String format(int cp, boolean mate) {
            return mate
                    ? "mate " + (cp > 0 ? (32000 - cp + 1) / 2
                    : -(32000 + cp) / 2)
                    : "cp " + cp;
        }
    }
}

C:\dev\Helios\src>(echo.   & echo // File: UciOptionsImpl.java   & type "C:\dev\Helios\src\main\java\core\impl\UciOptionsImpl.java" ) 
 
// File: UciOptionsImpl.java 
package core.impl;

import core.contracts.Search;
import core.contracts.TranspositionTable;
import core.contracts.UciOptions;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.function.Consumer;

/**
 * Implements the UciOptions contract to manage engine settings.
 */
public class UciOptionsImpl implements UciOptions {

    private Search search;
    private final TranspositionTable transpositionTable;

    private record UciOption(String type, String defaultValue, String min, String max, Consumer<String> onSet) {
        void print(String name) {
            System.out.print("option name " + name + " type " + type);
            if (defaultValue != null) System.out.print(" default " + defaultValue);
            if (min != null) System.out.print(" min " + min);
            if (max != null) System.out.print(" max " + max);
            System.out.println();
        }
    }

    private final Map<String, UciOption> options = new LinkedHashMap<>();

    public UciOptionsImpl(Search search, TranspositionTable transpositionTable) {
        this.search = search;
        this.transpositionTable = transpositionTable;
        initializeOptions();
    }

    @Override
    public TranspositionTable getTranspositionTable() {
        return this.transpositionTable;
    }

    private void initializeOptions() {
        options.put("Hash", new UciOption("spin", "64", "1", "1024",
                value -> this.transpositionTable.resize(Integer.parseInt(value))));
        options.put("Threads", new UciOption("spin", "1", "1", "128",
                value -> this.search.setThreads(Integer.parseInt(value))));
        options.put("Clear Hash", new UciOption("button", null, null, null,
                value -> this.transpositionTable.clear()));
        // inside initializeOptions()
        options.put("Move Overhead",             // identical name
                new UciOption("spin", "50",      // default 50 ms
                        "0", "5000",
                        v -> { /* value read by TimeManagerImpl */ }));
        options.put("MultiPV",
                new UciOption("spin", "1",       // default 1 line
                        "1", "8",
                        v -> {}));
        options.put("Minimal",
                new UciOption("check", "false", null, null,
                        v -> {}));
    }

    public String getOptionValue(String name) {
        UciOption o = options.get(name);
        return o != null ? o.defaultValue /* or cached current value */ : null;
    }

    public void attachSearch(Search s) { this.search = s; }

    @Override
    public void setOption(String line) {
        try {
            String[] parts = line.split(" value ");
            String namePart = parts[0].replace("setoption name ", "").trim();
            String valuePart = parts.length > 1 ? parts[1].trim() : "";

            UciOption option = options.get(namePart);
            if (option != null) {
                if (option.onSet != null) {
                    option.onSet.accept(valuePart);
                }
            } else {
                System.out.println("info string Unknown option: " + namePart);
            }
        } catch (Exception e) {
            System.out.println("info string Error setting option: " + line);
        }
    }

    @Override
    public void printOptions() {
        for (Map.Entry<String, UciOption> entry : options.entrySet()) {
            entry.getValue().print(entry.getKey());
        }
    }
}
C:\dev\Helios\src>(echo.   & echo // File: SearchInfo.java   & type "C:\dev\Helios\src\main\java\core\records\SearchInfo.java" ) 
 
// File: SearchInfo.java 
package core.records;

import java.util.List;

/**
 * Immutable snapshot of a *single* “info” line that the searcher feeds to
 * a {@link core.contracts.InfoHandler}.
 *
 * @param depth           Principal depth (in plies) reached so far.
 * @param selDepth        Maximum selective depth (extensions, checks, etc.).
 * @param multiPvIdx      1-based index when {@code multiPV > 1}.
 * @param scoreCp         Evaluation in centipawns from the root mover’s
 * perspective, or <i>(MateValue ± ply)</i>.
 * @param isMate          True if the score represents a forced mate.
 * @param nodes           Total nodes searched so far.
 * @param nps             Average speed in nodes per second.
 * @param timeMs          Wall-clock time elapsed (milliseconds).
 * @param pv              Principal variation as a list of encoded moves.
 * @param hashFullPermil  Transposition-table saturation in ‰.
 * @param tbHits          Number of Syzygy WDL/DTZ probes done so far.
 */
public record SearchInfo(
        int           depth,
        int           selDepth,
        int           multiPvIdx,
        int           scoreCp,
        boolean       isMate,
        long          nodes,
        long          nps,
        long          timeMs,
        List<Integer> pv,
        int           hashFullPermil,
        long          tbHits
) {}
C:\dev\Helios\src>(echo.   & echo // File: SearchResult.java   & type "C:\dev\Helios\src\main\java\core\records\SearchResult.java" ) 
 
// File: SearchResult.java 
package core.records;

import java.util.List;

/**
 * Final result produced when a search completes normally or is stopped.
 *
 * <p>All fields are immutable so callers can freely cache or forward
 * the object across threads.</p>
 *
 * @param bestMove   Engine-chosen move to play (0 ⇒ none legal).
 * @param ponderMove Expected reply by the opponent (0 ⇒ unknown).
 * @param pv         Full principal variation starting with {@code bestMove}.
 * @param scoreCp    Centipawn score, or <i>(MateValue ± ply)</i>
 *                   if {@code mateFound} is {@code true}.
 * @param mateFound  Indicates the score encodes a forced mate.
 * @param depth      Principal depth actually completed.
 * @param nodes      Total nodes searched.
 * @param timeMs     Wall-clock time consumed by the search.
 */
public record SearchResult(
        int              bestMove,
        int              ponderMove,
        List<Integer>    pv,
        int              scoreCp,
        boolean          mateFound,
        int              depth,
        long             nodes,
        long             timeMs
) {}

C:\dev\Helios\src>(echo.   & echo // File: SearchSpec.java   & type "C:\dev\Helios\src\main\java\core\records\SearchSpec.java" ) 
 
// File: SearchSpec.java 
package core.records;

import java.util.Collections;
import java.util.List;

/**
 * Immutable set of <em>search limits / directives</em>.
 *
 * Use the nested {@link Builder} to construct an instance of this record.
 *
 * @param depth            Fixed search depth in plies.
 * @param nodes            Hard node budget (0 = unlimited).
 * @param moveTimeMs       Exact move-time (0 = unused).
 * @param wTimeMs          White’s remaining clock time.
 * @param wIncMs           White’s increment per move.
 * @param bTimeMs          Black’s remaining clock time.
 * @param bIncMs           Black’s increment per move.
 * @param movesToGo        Moves until the next time control (0 = unknown).
 * @param infinite         Run until {@code stop()} – <i>ignores</i> other limits.
 * @param ponder           {@code true} ⇢ GUI clock still ticking.
 * @param history          List of Zobrist keys from previous positions in the game.
 */
public record SearchSpec(
        int   depth,
        long  nodes,
        long  moveTimeMs,
        long  wTimeMs, long wIncMs,
        long  bTimeMs, long bIncMs,
        int   movesToGo,
        boolean infinite,
        boolean ponder,
        List<Long> history
) {
    /**
     * A builder for creating {@link SearchSpec} instances. This provides a fluent API
     * for setting search parameters and is more readable than a large constructor.
     */
    public static class Builder {
        private int depth = 0;
        private long nodes = 0;
        private long moveTimeMs = 0;
        private long wTimeMs = 0;
        private long wIncMs = 0;
        private long bTimeMs = 0;
        private long bIncMs = 0;
        private int movesToGo = 0;
        private boolean infinite = false;
        private boolean ponder = false;
        private List<Long> history = Collections.emptyList();

        public Builder depth(int depth) { this.depth = depth; return this; }
        public Builder nodes(long nodes) { this.nodes = nodes; return this; }
        public Builder moveTimeMs(long moveTimeMs) { this.moveTimeMs = moveTimeMs; return this; }
        public Builder wTimeMs(long wTimeMs) { this.wTimeMs = wTimeMs; return this; }
        public Builder wIncMs(long wIncMs) { this.wIncMs = wIncMs; return this; }
        public Builder bTimeMs(long bTimeMs) { this.bTimeMs = bTimeMs; return this; }
        public Builder bIncMs(long bIncMs) { this.bIncMs = bIncMs; return this; }
        public Builder movesToGo(int movesToGo) { this.movesToGo = movesToGo; return this; }
        public Builder infinite(boolean infinite) { this.infinite = infinite; return this; }
        public Builder ponder(boolean ponder) { this.ponder = ponder; return this; }
        public Builder history(List<Long> history) { this.history = history; return this; }

        public SearchSpec build() {
            return new SearchSpec(depth, nodes, moveTimeMs, wTimeMs, wIncMs, bTimeMs, bIncMs,
                    movesToGo, infinite, ponder, history);
        }
    }
}
C:\dev\Helios\src>(echo.   & echo // File: TimeAllocation.java   & type "C:\dev\Helios\src\main\java\core\records\TimeAllocation.java" ) 
 
// File: TimeAllocation.java 
package core.records;

/**
 * A record to hold the calculated optimal and maximum thinking time for a move.
 *
 * @param optimal The target time in milliseconds the engine should aim for.
 * @param maximum The hard limit in milliseconds the engine must not exceed.
 */
public record TimeAllocation(long optimal, long maximum) {}
C:\dev\Helios\src>(echo.   & echo // File: Main.java   & type "C:\dev\Helios\src\main\java\main\Main.java" ) 
 
// File: Main.java 
// File: Main.java
package main;

import core.contracts.*;
import core.impl.*;

import java.util.List;

/**
 * Wire everything together and run the UCI loop.
 * <p>
 * The first CLI argument can be the literal word {@code bench}. In that case we
 * run a <b>pure PERFT benchmark</b> (no search, no TT, no evaluator) over the
 * internal FEN suite and exit – exactly what the OpenBench client expects.
 * <pre>
 *   ./Helios-<sha> bench [ttMB] [threads] [depth]
 * </pre>
 * The "ttMB" and "threads" parameters are now ignored but kept for CLI
 * compatibility; only the optional <i>depth</i> value is used.
 */
public final class Main {

    /* ------------------------------------------------------------------
     *  Entry‑point
     * ---------------------------------------------------------------- */
    public static void main(String[] args) {

        /* ── 1) standalone BENCH mode ─────────────────────────── */
        if (args.length > 0 && "bench".equalsIgnoreCase(args[0])) {

            int depth = 4; // default depth 4
            runPerftBench(depth);
            return; // do not enter the interactive loop
        }

        /* ── 2) regular interactive UCI mode ─────────────────── */
        System.out.println("Helios Chess Engine");

        /* ─── stateless singletons ───────────────────────────── */
        PositionFactory pf = new PositionFactoryImpl();
        MoveGenerator   mg = new MoveGeneratorImpl();
        Evaluator       ev = new EvaluatorImpl();

        /* ─── TT + Options (Options only needs TT) ───────────── */
        TranspositionTable tt   = new TranspositionTableImpl(64);
        UciOptionsImpl     opts = new UciOptionsImpl(null /* search yet */, tt);

        /* ─── Time‑manager ───────────────────────────────────── */
        TimeManager tm = new TimeManagerImpl(opts);

        /* ─── Lazy‑SMP worker‑pool ───────────────────────────── */
        SearchWorkerFactory swf = (isMain, pool) ->
                new LazySmpSearchWorkerImpl(isMain, (LazySmpWorkerPoolImpl) pool);
        WorkerPool pool = new LazySmpWorkerPoolImpl(swf);
        pool.setParallelism(1);

        /* ─── Search façade ──────────────────────────────────── */
        Search search = new SearchImpl(pf, mg, ev, pool, tm);
        search.setTranspositionTable(tt);

        /* now the options handler can finally talk to Search */
        opts.attachSearch(search);

        /* ─── UCI front‑end ─────────────────────────────────── */
        UciHandler uci = new UciHandlerImpl(search, pf, opts, mg);

        try   { uci.runLoop(); }  // blocks until "quit"
        finally { search.close(); }
    }

    private static void runPerftBench(int depth) {
        PositionFactory pf = new PositionFactoryImpl();
        MoveGenerator   mg = new MoveGeneratorImpl();
        List<String> FENS  = core.impl.UciHandlerImpl.BENCH_FENS; // reuse existing suite

        long totalNodes = 0, totalTimeMs = 0;

        for (int i = 0; i < FENS.size(); i++) {
            long[] root = pf.fromFen(FENS.get(i));

            long t0 = System.nanoTime();
            long nodes = perft(root, depth, 0, pf, mg);
            long ms    = (System.nanoTime() - t0) / 1_000_000;

            long nps = ms > 0 ? (1000L * nodes) / ms : 0;

            totalNodes += nodes;
            totalTimeMs += ms;
        }

        long totalNps = totalTimeMs > 0 ? (1000L * totalNodes) / totalTimeMs : 0;
        System.out.printf("Nodes searched: %d%n", totalNodes);
        System.out.printf("nps: %d%n",             totalNps);
        System.out.println("benchok");
    }

    /* --------------------------------------------------------- */
    private static final int MAX_PLY  = 64;
    private static final int LIST_CAP = 256;
    private static final int[][] MOVES = new int[MAX_PLY][LIST_CAP];

    private static long perft(long[] bb, int depth, int ply,
                              PositionFactory pf, MoveGenerator mg) {
        if (depth == 0) return 1;

        int[] list = MOVES[ply];
        boolean white = PositionFactory.whiteToMove(bb[PositionFactory.META]);
        int nMoves = (mg.kingAttacked(bb, white))
                ? mg.generateEvasions(bb, list, 0)
                : mg.generateQuiets(bb, list,
                mg.generateCaptures(bb, list, 0));

        long nodes = 0;
        for (int i = 0; i < nMoves; i++) {
            int mv = list[i];
            if (!pf.makeMoveInPlace(bb, mv, mg)) continue; // illegal
            nodes += perft(bb, depth - 1, ply + 1, pf, mg);
            pf.undoMoveInPlace(bb);
        }
        return nodes;
    }
}

C:\dev\Helios\src>(echo.   & echo // File: MoveGeneratorPerftAllTest.java   & type "C:\dev\Helios\src\test\java\core\MoveGeneratorPerftAllTest.java" ) 
 
// File: MoveGeneratorPerftAllTest.java 
package core;

import static core.contracts.PositionFactory.*;

import core.contracts.MoveGenerator;
import core.contracts.PositionFactory;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;
import java.util.stream.Stream;

import core.impl.MoveGeneratorImpl;
import core.impl.PositionFactoryImpl;
import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class MoveGeneratorPerftAllTest {

    /* ── wiring identical to MoveGeneratorPerftTest ─────────────── */
    private static final PositionFactory POS_FACTORY = new PositionFactoryImpl();
    private static final MoveGenerator   GEN         = new MoveGeneratorImpl();

    /* test-vector record (qbbAll.txt has 7 columns) */
    private record Vec(String fen,int depth,long expNodes,long expPseudo,
                       long expCaps,long expQuiets,long expEvas) {}

    private List<Vec> vecs;

    /* ── load vectors once ───────────────────────────────────────── */
    @BeforeAll
    void load() throws Exception {
        vecs = new ArrayList<>();
        try (InputStream in = getClass().getResourceAsStream("/perft/qbbAll.txt");
             BufferedReader br = new BufferedReader(new InputStreamReader(
                     Objects.requireNonNull(in, "qbbAll.txt not on classpath")))) {

            br.lines().map(String::trim)
                    .filter(l -> !(l.isEmpty() || l.startsWith("#")))
                    .forEach(l -> {
                        String[] p = l.split(";");
                        if (p.length < 7) return;
                        vecs.add(new Vec(
                                p[0].trim(),
                                Integer.parseInt(p[1].replaceAll("\\D","")),
                                Long.parseLong(p[2].replaceAll("\\D","")),
                                Long.parseLong(p[3].replaceAll("\\D","")),
                                Long.parseLong(p[4].replaceAll("\\D","")),
                                Long.parseLong(p[5].replaceAll("\\D","")),
                                Long.parseLong(p[6].replaceAll("\\D",""))));
                    });
        }
        Assertions.assertFalse(vecs.isEmpty(), "qbbAll.txt missing / empty");
    }

    /* aggregated totals for a nice one-liner at the end */
    private long totNodes, totPseudo, totCaps, totQuiets, totEvas, timeNs;
    private long expNodesTot, expPseudoTot, expCapsTot, expQuietsTot, expEvasTot;

    Stream<Vec> vecStream(){ return vecs.stream(); }

    /* lightweight counter bundle */
    private static final class C { long nodes,pseudo,caps,quiets,evas; }

    /* ── parameterised test itself ───────────────────────────────── */
    @ParameterizedTest(name="xPerft {index}")
    @MethodSource("vecStream")
    void perft(Vec v){
        long[] root = POS_FACTORY.fromFen(v.fen());   // ← simply parse the FEN
        C c = new C();

        long t0 = System.nanoTime();
        long got = perft(root, v.depth(), 0, c);
        timeNs += System.nanoTime() - t0;

        totNodes  += got;
        totPseudo += c.pseudo;
        totCaps   += c.caps;
        totQuiets += c.quiets;
        totEvas   += c.evas;

        Assertions.assertAll(
                () -> Assertions.assertEquals(v.expNodes(),  got,    "nodes"),
                () -> Assertions.assertEquals(v.expPseudo(), c.pseudo,"pseudo"),
                () -> Assertions.assertEquals(v.expCaps(),   c.caps,  "captures"),
                () -> Assertions.assertEquals(v.expQuiets(), c.quiets,"quiets"),
                () -> Assertions.assertEquals(v.expEvas(),   c.evas,  "evasions")
        );
        expNodesTot  += v.expNodes();
        expPseudoTot += v.expPseudo();
        expCapsTot   += v.expCaps(); //test
        expQuietsTot += v.expQuiets();
        expEvasTot   += v.expEvas();
    }

    /* ── final summary ───────────────────────────────────────────── */
    @AfterAll
    void report() {
        double secs = timeNs / 1_000_000_000.0;

        System.out.printf("""
        ── xPERFT SUMMARY ────────────────────────────────────────────
        counter      actual        expected        Δ
        --------------------------------------------------------------
        nodes   : %,15d  / %,15d  (%+d)
        pseudo  : %,15d  / %,15d  (%+d)
        caps    : %,15d  / %,15d  (%+d)
        quiets  : %,15d  / %,15d  (%+d)
        evas    : %,15d  / %,15d  (%+d)
        --------------------------------------------------------------
        time    : %.3f s   → %,d NPS
        ───────────────────────────────────────────────────────────────
        """,
                totNodes,  expNodesTot,  totNodes  - expNodesTot,
                totPseudo, expPseudoTot, totPseudo - expPseudoTot,
                totCaps,   expCapsTot,   totCaps   - expCapsTot,
                totQuiets, expQuietsTot, totQuiets - expQuietsTot,
                totEvas,   expEvasTot,   totEvas   - expEvasTot,
                secs, (long)(totNodes / Math.max(1e-9, secs)));
    }

    private static final int MAX_PLY  = 64;
    private static final int LIST_CAP = 256;
    private static final int[][] MOVES = new int[MAX_PLY][LIST_CAP];

    private long perft(long[] bb,int depth,int ply,C cnt){
        if (depth == 0){ return 1; }

        boolean stmWhite = (bb[META] & 1L) == 0;
        boolean inCheck  = GEN.kingAttacked(bb, stmWhite);

        int[] moves = MOVES[ply];
        int legalCnt;

        if (inCheck){
            legalCnt     = GEN.generateEvasions(bb, moves, 0);
            cnt.evas    += legalCnt;
            cnt.pseudo  += legalCnt;
        } else {
            int caps     = GEN.generateCaptures(bb, moves, 0);
            int total    = GEN.generateQuiets  (bb, moves, caps);
            int quiets   = total - caps;

            legalCnt     = total;
            cnt.caps    += caps;
            cnt.quiets  += quiets;
            cnt.pseudo  += total;
        }

        long nodes = 0;
        for (int i = 0; i < legalCnt; ++i){
            int mv = moves[i];

            /* guard against illegal “king-capture” pseudo moves */
            if (capturesKing(mv, bb, stmWhite))
                throw new AssertionError("Generated king capture: "
                        + moveToUci(mv) + "  FEN " + POS_FACTORY.toFen(bb));

            if (!POS_FACTORY.makeMoveInPlace(bb, mv, GEN)) continue;
            nodes += perft(bb, depth-1, ply+1, cnt);
            POS_FACTORY.undoMoveInPlace(bb);
        }
        return nodes;
    }

    /* helper: does the move land on the enemy king? */
    private static boolean capturesKing(int mv,long[] bb,boolean stmWhite){
        int to   = mv & 0x3F;
        int enemyK = stmWhite ? BK : WK;
        return (bb[enemyK] & (1L << to)) != 0;
    }

    /* helper: packed-move → UCI (promotion bits are 3->q … 0->n) */
    private static String moveToUci(int mv){
        int from  = (mv>>>6) & 63;
        int to    =  mv      & 63;
        int type  = (mv>>>14)&3;
        int promo = (mv>>>12)&3;
        String s = sq(from) + sq(to);
        if (type == 1) s += "nbrq".charAt(3 - promo);
        return s;
    }
    private static String sq(int sq){
        return "" + (char)('a'+(sq&7)) + (char)('1'+(sq>>>3));
    }
}

C:\dev\Helios\src>(echo.   & echo // File: MoveGeneratorPerftTest.java   & type "C:\dev\Helios\src\test\java\core\MoveGeneratorPerftTest.java" ) 
 
// File: MoveGeneratorPerftTest.java 
package core;

import core.contracts.MoveGenerator;
import core.contracts.PositionFactory;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;
import java.util.stream.Stream;

import core.impl.MoveGeneratorImpl;
import core.impl.PositionFactoryImpl;
import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class MoveGeneratorPerftTest {

  /* ── wiring ───────────────────────────────────────────────────── */
  private static final PositionFactory POS_FACTORY = new PositionFactoryImpl();
  private static final MoveGenerator GEN = new MoveGeneratorImpl();

  /* ── per‑test‑case record ─────────────────────────────────────── */
  private record TestCase(String fen, int depth, long expected) {}

  private List<TestCase> cases;
  private long nodes = 0, timeNs = 0;

  /* ── load the perft vectors once (from /perft/qbb.txt) ────────── */
  @BeforeAll
  void loadVectors() throws Exception {
    cases = new ArrayList<>();
    try (InputStream is = getClass().getResourceAsStream("/perft/qbb.txt");
         BufferedReader br =
                 new BufferedReader(new InputStreamReader(Objects.requireNonNull(is)))) {

      br.lines()
              .map(String::trim)
              .filter(l -> !(l.isEmpty() || l.startsWith("#")))
              .forEach(
                      l -> {
                        String[] p = l.split(";");
                        if (p.length < 3) return;
                        cases.add(
                                new TestCase(
                                        p[0].trim(),
                                        Integer.parseInt(p[1].replaceAll("[^0-9]", "")),
                                        Long.parseLong(p[2].replaceAll("[^0-9]", ""))));
                      });
    }
    Assertions.assertFalse(cases.isEmpty(), "no perft vectors found");
  }

  /* ── JUnit parameter source ───────────────────────────────────── */
  Stream<TestCase> caseStream() {
    return cases.stream();
  }

  /* ── the actual test method ───────────────────────────────────── */
  @ParameterizedTest(name = "fast‑HQ {index}")
  @MethodSource("caseStream")
  void perft(TestCase tc) {
    long[] root = POS_FACTORY.fromFen(tc.fen);
    boolean moverIsWhite = tc.fen.split("\\s+")[1].charAt(0) == 'w';

    long t0 = System.nanoTime();
    long got = perft(root, moverIsWhite, tc.depth, 0);
    timeNs += System.nanoTime() - t0;
    nodes += got;
    Assertions.assertEquals(tc.expected, got, () -> "mismatch depth=" + tc.depth + " FEN=" + tc.fen);
  }

  /* ── aggregate speed report ───────────────────────────────────── */
  @AfterAll
  void report() {
    double s = timeNs / 1_000_000_000.0;
    System.out.printf("FAST : %,d nodes  %.3f s  %,d NPS%n", nodes, s, (long) (nodes / Math.max(1e-9, s)));
  }

  private static final int MAX_PLY = 64;
  private static final int LIST_CAP = 256;

  private static final int[][] MOVES = new int[MAX_PLY][LIST_CAP];

  private static long perft(long[] bb, boolean moverIsWhite, int depth, int ply) {
    if (depth == 0) return 1;

    int[] moves = MOVES[ply];
    int cnt;

    // 1. Decide which move list to generate depending on check state
    if (GEN.kingAttacked(bb, moverIsWhite)) {
      cnt = GEN.generateEvasions(bb, moves, 0);
    } else {
      cnt = GEN.generateCaptures(bb, moves, 0);          // noisy first
      cnt = GEN.generateQuiets(bb, moves, cnt);          // then quiets appended
    }

    long nodes = 0;

    // 2. DFS over the move list
    for (int i = 0; i < cnt; ++i) {
      if (!POS_FACTORY.makeMoveInPlace(bb, moves[i], GEN)) {
        continue; // illegal → parent position (and its cookies) remain intact
      }

      nodes += perft(bb, !moverIsWhite, depth - 1, ply + 1);
      POS_FACTORY.undoMoveInPlace(bb); // restores board & per‑ply cookie snapshots
    }

    return nodes;
  }
}

C:\dev\Helios\src>(echo.   & echo // File: PositionFactoryZobristTest.java   & type "C:\dev\Helios\src\test\java\core\PositionFactoryZobristTest.java" ) 
 
// File: PositionFactoryZobristTest.java 
package core;

import static org.junit.jupiter.api.Assertions.*;

import core.contracts.MoveGenerator;
import core.contracts.PositionFactory;
import core.impl.MoveGeneratorImpl;
import core.impl.PositionFactoryImpl;
import java.lang.reflect.Field;
import java.util.*;
import org.junit.jupiter.api.*;

/**
 * *Exhaustive* verification that Zobrist hashing – *both* the full
 * recomputation and the incremental updates – is correct.
 *
 * The test is split into two parts:
 *
 * 1.  **Primitive-invariant tests** – prove that fullHash() returns
 * exactly the XOR of the individual table entries. This does
 * *not* call fullHash internally for the comparison; instead we
 * rebuild the hash manually from the private PIECE_SQUARE,
 * CASTLING, … tables obtained via reflection. When these pass we
 * can trust fullHash as a reference oracle.
 *
 * 2.  **Random walk + edge script** – same as usual, but guarded by
 * the proven-correct oracle, which in turn guarantees that the
 * incremental `make/undo` path is right.
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class PositionFactoryZobristTest {

    /* ─── reference to the engine objects ───────────────────────── */
    private static final PositionFactoryImpl PF  = new PositionFactoryImpl();
    private static final MoveGenerator       GEN = new MoveGeneratorImpl();
    private static final Random              RNG = new Random(0xDEADBEEF);

    /* ─── reflect private static fields we need for ground truth ── */
    private static final long[][] PSQ   = getStatic("PIECE_SQUARE");
    private static final long[]   CAST  = getStatic("CASTLING");
    private static final long[]   EPF   = getStatic("EP_FILE");
    private static final long     STM_K = getStatic("SIDE_TO_MOVE");
    private static final int      EP_NONE = (int) PositionFactory.EP_NONE;

    /* piece indices copied to avoid reflection inside hot loop      */
    private static final int WP = getIntConst("WP"),
            WN = getIntConst("WN"),
            WB = getIntConst("WB"),
            WR = getIntConst("WR"),
            WQ = getIntConst("WQ"),
            WK = getIntConst("WK"),
            BP = getIntConst("BP"),
            BN = getIntConst("BN"),
            BB = getIntConst("BB"),
            BR = getIntConst("BR"),
            BQ = getIntConst("BQ"),
            BK = getIntConst("BK");
    private static final int HASH = getIntConst("HASH");
    private static final int META = getIntConst("META");
    private static final long STM_MASK = getLongConst("STM_MASK");
    private static final long CR_MASK  = getLongConst("CR_MASK");
    private static final long EP_MASK  = getLongConst("EP_MASK");

    /* ————————————————— 1 ─  primitive invariants  ————————————————— */

    /** Empty board, no STM bit, CR=0, EP = EP_NONE → hash == CASTLING[0]. */
    @Test @Order(1)
    void emptyBoardBaseline() {
        long[] bb = blank();
        long expected = CAST[0]; // The only non-zero component should be the empty castling rights key
        long actual   = PF.fullHash(bb);
        assertEquals(expected, actual, "baseline hash wrong");
    }

    /** Every piece / square flips exactly PIECE_SQUARE[p][sq]. */
    @Test @Order(2)
    void pieceSquareContributionExact() {
        long[] bb = blank();
        for (int p = WP; p <= BK; ++p) {
            for (int sq = 0; sq < 64; ++sq) {
                bb[p] = 1L << sq;
                long got = PF.fullHash(bb);
                long want = CAST[0] ^ PSQ[p][sq]; // baseline XOR piece
                int finalP = p;
                int finalSq = sq;
                assertEquals(want, got,
                        () -> "piece idx " + finalP + " on sq " + finalSq + " wrong");
                bb[p] = 0;
            }
        }
    }

    /** Side-to-move toggles exactly SIDE_TO_MOVE constant. */
    @Test @Order(3)
    void sideToMoveXorCorrect() {
        long[] bb = blank();
        long hashWhite = PF.fullHash(bb);
        bb[META] |= STM_MASK;              // make it black to move
        long hashBlack = PF.fullHash(bb);
        assertEquals(hashWhite ^ STM_K, hashBlack, "STM XOR wrong");
    }

    /** Each of 16 castling codes injects its own CASTLING index. */
    @Test @Order(4)
    void castlingXorCorrect() {
        long[] bb = blank();
        for (int cr = 0; cr < 16; ++cr) {
            bb[META] = (bb[META] & ~CR_MASK) | ((long) cr << 1);
            long h = PF.fullHash(bb);
            long want = CAST[cr];
            assertEquals(want, h, "CR code " + cr + " wrong");
        }
    }

    /** Each EP file 0-7 toggles the matching EP_FILE entry. */
    @Test @Order(5)
    void enPassantXorCorrect() {
        long[] bb = blank();
        long base = PF.fullHash(bb);
        for (int f = 0; f < 8; ++f) {
            int epSq = f; // any square with same file works
            bb[META] = (bb[META] & ~EP_MASK) | ((long) epSq << 5);
            long h = PF.fullHash(bb);
            assertEquals(base ^ EPF[f], h, "EP file " + f + " wrong");
        }
    }

    /* ————————————————— 2 ─  incremental vs proven-full  —————————— */

    @Test @Order(6)
    void perftKeepsHashCorrect() {
        long[] bb = PF.fromFen(
                "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
        verifyPerft(bb, 4); // Depth 5 is slow, reducing to 4 for reasonable test time
        bb = PF.fromFen(
                "r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1");
        verifyPerft(bb, 3);
        bb = PF.fromFen(
                "8/2p5/3p4/KP5r/1R3p1k/8/4P1P1/8 w - - 0 1");
        verifyPerft(bb, 4);
        bb = PF.fromFen(
                "r3k2r/Pppp1ppp/1b3nbN/nP6/BBP1P3/q4N2/Pp1P2PP/R2Q1RK1 w kq - 0 1");
        verifyPerft(bb, 3);
        bb = PF.fromFen(
                "rnbqkb1r/pp1p1ppp/2p5/4P3/2B5/8/PPP1NnPP/RNBQK2R w KQkq - 0 6");
        verifyPerft(bb, 4);
    }

    /* ————————————————— helpers ——————————————————————————— */
    private static long[] COPY_TMP;

    private static void assertHashesEqual(long[] bb) {
        COPY_TMP = Arrays.copyOf(bb, bb.length);
        long full = PF.fullHash(bb);
        long inc  = PF.zobrist(bb);
        if (full == inc) return;

        // Fallback for debugging if hashes mismatch
        dumpAndFail("Hash mismatch", full, inc);
    }

    private static void dumpAndFail(String tag, long exp, long act) {
        System.err.println("Failure reason: " + tag);
        System.err.printf("Expected: 0x%016X%nActual:   0x%016X%n", exp, act);
        System.err.println("FEN at failure: " + new PositionFactoryImpl().toFen(COPY_TMP));
        fail("incremental != proven-full (" + tag + ")");
    }


    private static long[] blank() {
        long[] a = new long[getIntConst("BB_LEN")];
        a[getIntConst("META")] = ((long)EP_NONE) << 5;
        return a;
    }

    private static int legalMoves(long[] bb, int[] dst) {
        int[] pseudo = new int[256];
        boolean white = (bb[META] & STM_MASK) == 0;
        int n = GEN.kingAttacked(bb, white)
                ? GEN.generateEvasions(bb, pseudo, 0)
                : GEN.generateQuiets(bb, pseudo,
                GEN.generateCaptures(bb, pseudo, 0));
        int len = 0;
        for (int i = 0; i < n; ++i) {
            int mv = pseudo[i];
            if (!PF.makeMoveInPlace(bb, mv, GEN))
                continue;
            PF.undoMoveInPlace(bb);
            dst[len++] = mv;
        }
        return len;
    }

    private static void verifyPerft(long[] bb, int depth) {
        assertHashesEqual(bb); // Check upon entering the node

        if (depth == 0) return;

        int[] moves = new int[256];
        int cnt = legalMoves(bb, moves);

        for (int i = 0; i < cnt; ++i) {
            int mv = moves[i];
            PF.makeMoveInPlace(bb, mv, GEN);
            assertHashesEqual(bb); // Check after making a move

            verifyPerft(bb, depth - 1);

            PF.undoMoveInPlace(bb);
            assertHashesEqual(bb); // Check after undoing the move
        }
    }


    @SuppressWarnings("unchecked")
    private static <T> T getStatic(String name) {
        try {
            // First, try to get the field from the interface where public constants are defined.
            Field f = PositionFactory.class.getDeclaredField(name);
            f.setAccessible(true);
            return (T) f.get(null);
        } catch (NoSuchFieldException e) {
            // If not found, it must be a private/package-private constant in the implementation
            // (like the Zobrist arrays).
            try {
                Field f = PositionFactoryImpl.class.getDeclaredField(name);
                f.setAccessible(true);
                return (T) f.get(null);
            } catch (Exception e2) {
                throw new RuntimeException("Failed to reflect field '" + name + "' from PositionFactoryImpl", e2);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to reflect field '" + name + "' from PositionFactory", e);
        }
    }

    private static int getIntConst(String n){return (Integer)getStatic(n);}
    private static long getLongConst(String n){return (Long)getStatic(n);}
}